#!/usr/bin/env node
/**
 * Event Schema Test Harness
 *
 * Validates event schema consistency across all layers:
 * 1. JSON Schema validation (via Ajv)
 * 2. ApiSchemas.gs field alignment
 * 3. Surface header comments consistency
 *
 * Usage:
 *   node scripts/test-event-schema.js
 *   npm run test:schemas:event
 *
 * Exit codes:
 *   0 - All validations passed
 *   1 - One or more validations failed
 *
 * @see /schemas/event.schema.json (MVP-frozen v2.2)
 * @see src/mvp/ApiSchemas.gs
 * @see src/mvp/TemplateService.gs
 */

const fs = require('fs');
const path = require('path');
const Ajv2020 = require('ajv/dist/2020');

// ============================================================================
// Configuration
// ============================================================================

const ROOT = path.join(__dirname, '..');
const SCHEMAS_DIR = path.join(ROOT, 'schemas');
const MVP_DIR = path.join(ROOT, 'src/mvp');

// Colors for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  dim: '\x1b[2m'
};

// ============================================================================
// Fixture: Canonical Event matching TemplateService output
// ============================================================================

/**
 * Fixture that mirrors what TemplateService + _buildEventContract_ produces.
 * This represents the canonical shape of an event as returned by the API.
 */
const TEMPLATE_SERVICE_FIXTURE = {
  // MVP REQUIRED - Identity
  id: 'evt_test_summer2024_abc123',
  slug: 'summer-tournament-2024',
  name: 'Summer Tournament 2024',
  startDateISO: '2024-07-15',
  venue: 'Central Park Arena',
  templateId: 'rec_league', // MVP Optional

  // MVP REQUIRED - Links (generated by _buildEventContract_)
  links: {
    publicUrl: 'https://script.google.com/macros/s/xxx/exec?surface=public&eventId=evt_test_summer2024_abc123',
    displayUrl: 'https://script.google.com/macros/s/xxx/exec?surface=display&eventId=evt_test_summer2024_abc123',
    posterUrl: 'https://script.google.com/macros/s/xxx/exec?surface=poster&eventId=evt_test_summer2024_abc123',
    signupUrl: 'https://docs.google.com/forms/d/e/xxx/viewform',
    sharedReportUrl: null // V2 Optional
  },

  // MVP REQUIRED - QR Codes (generated by _buildEventContract_)
  qr: {
    public: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==',
    signup: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
  },

  // MVP REQUIRED - CTAs
  ctas: {
    primary: {
      label: 'Sign Up Now',
      url: 'https://docs.google.com/forms/d/e/xxx/viewform'
    },
    secondary: null // V2 Optional
  },

  // MVP REQUIRED - Settings (shaped by TemplateService)
  settings: {
    // MVP Required
    showSchedule: true,
    showStandings: true,
    showBracket: false,
    // MVP Optional
    showSponsors: true,
    // Template-aware toggles (Feature 4)
    showVideo: true,
    showMap: true,
    showGallery: false,
    // Surface-specific toggles
    showSponsorBanner: true,
    showSponsorStrip: true,
    showLeagueStrip: true,
    showQRSection: true
  },

  // MVP REQUIRED - Timestamps
  createdAtISO: '2024-01-15T10:30:00.000Z',
  updatedAtISO: '2024-07-01T14:00:00.000Z',

  // MVP Optional - Content sections
  schedule: [
    { time: '9:00 AM', title: 'Registration', description: 'Check-in at main entrance' },
    { time: '10:00 AM', title: 'Opening Ceremony', description: null }
  ],
  standings: [
    { rank: 1, team: 'Thunder', wins: 8, losses: 2, points: 24 },
    { rank: 2, team: 'Lightning', wins: 7, losses: 3, points: null }
  ],
  bracket: {
    rounds: [
      {
        name: 'Semifinals',
        matches: [
          { id: 'sf1', team1: 'Thunder', team2: 'Storm', score1: 3, score2: 1, winner: 'Thunder' },
          { id: 'sf2', team1: 'Lightning', team2: 'Rain', score1: null, score2: null, winner: null }
        ]
      }
    ]
  },

  // V2 Optional - Sponsors
  sponsors: [
    {
      id: 'sp_acme_001',
      name: 'Acme Corp',
      logoUrl: 'https://example.com/logos/acme.png',
      linkUrl: 'https://acmecorp.com',
      placement: 'public'
    }
  ],

  // V2 Optional - Media
  media: {
    videoUrl: 'https://www.youtube.com/embed/dQw4w9WgXcQ',
    mapUrl: 'https://maps.google.com/maps?q=Central+Park',
    gallery: null
  },

  // V2 Optional - External data sources
  externalData: {
    scheduleUrl: null,
    standingsUrl: 'https://example.com/api/standings',
    bracketUrl: null
  },

  // Reserved - Analytics
  analytics: null,

  // Reserved - Payments
  payments: null
};

/**
 * Minimal event fixture with only MVP REQUIRED fields
 */
const MINIMAL_EVENT_FIXTURE = {
  id: 'evt_minimal_001',
  slug: 'minimal-event',
  name: 'Minimal Event',
  startDateISO: '2024-12-01',
  venue: 'Test Venue',
  links: {
    publicUrl: 'https://example.com/public',
    displayUrl: 'https://example.com/display',
    posterUrl: 'https://example.com/poster',
    signupUrl: 'https://example.com/signup'
  },
  qr: {
    public: 'data:image/png;base64,abc',
    signup: 'data:image/png;base64,xyz'
  },
  ctas: {
    primary: { label: 'Register', url: 'https://example.com/signup' }
  },
  settings: {
    showSchedule: false,
    showStandings: false,
    showBracket: false
  },
  createdAtISO: '2024-01-01T00:00:00.000Z',
  updatedAtISO: '2024-01-01T00:00:00.000Z'
};

// ============================================================================
// Schema Utilities
// ============================================================================

/**
 * Load and parse JSON schema file
 */
function loadJsonSchema(filename) {
  const filepath = path.join(SCHEMAS_DIR, filename);
  return JSON.parse(fs.readFileSync(filepath, 'utf8'));
}

/**
 * Extract all field paths from JSON Schema (including nested $defs)
 */
function extractSchemaFields(schema, prefix = '', defs = null) {
  const fields = new Set();
  const definitions = defs || schema.$defs || {};

  if (!schema || typeof schema !== 'object') return fields;

  // Handle $ref
  if (schema.$ref) {
    const refPath = schema.$ref.replace(/^#\/\$defs\//, '');
    if (definitions[refPath]) {
      return extractSchemaFields(definitions[refPath], prefix, definitions);
    }
    return fields;
  }

  // Handle oneOf (take first non-null option)
  if (schema.oneOf) {
    for (const option of schema.oneOf) {
      if (option.type !== 'null' && option.$ref) {
        return extractSchemaFields(option, prefix, definitions);
      }
      if (option.type !== 'null' && option.properties) {
        return extractSchemaFields(option, prefix, definitions);
      }
    }
    return fields;
  }

  // Handle properties
  if (schema.properties) {
    for (const key of Object.keys(schema.properties)) {
      const fieldPath = prefix ? `${prefix}.${key}` : key;
      fields.add(fieldPath);
    }
  }

  return fields;
}

/**
 * Parse ApiSchemas.gs and extract field information
 */
function parseApiSchemasGs() {
  const filepath = path.join(MVP_DIR, 'ApiSchemas.gs');
  const content = fs.readFileSync(filepath, 'utf8');

  const result = {
    eventFields: new Set(),
    settingsFields: new Set(),
    linksFields: new Set(),
    sponsorFields: new Set()
  };

  // Extract _eventShape properties using improved regex
  const eventMatch = content.match(/_eventShape:\s*\{[\s\S]*?properties:\s*\{([\s\S]*?)\n\s{6}\}/);
  if (eventMatch) {
    const propsBlock = eventMatch[1];
    const propMatches = propsBlock.matchAll(/^\s{8}(\w+):\s*\{/gm);
    for (const match of propMatches) {
      result.eventFields.add(match[1]);
    }
  }

  // Also extract from required array
  const requiredMatch = content.match(/_eventShape:\s*\{[^}]*?required:\s*\[([\s\S]*?)\]/);
  if (requiredMatch) {
    const requiredFields = requiredMatch[1].match(/'([^']+)'/g)?.map(s => s.replace(/'/g, '')) || [];
    requiredFields.forEach(f => result.eventFields.add(f));
  }

  // Extract _settings properties
  const settingsMatch = content.match(/_settings:\s*\{[\s\S]*?properties:\s*\{([\s\S]*?)\n\s{6}\}/);
  if (settingsMatch) {
    const propsBlock = settingsMatch[1];
    const propMatches = propsBlock.matchAll(/^\s+(\w+):\s*\{/gm);
    for (const match of propMatches) {
      result.settingsFields.add(match[1]);
    }
  }

  // Extract links properties from _eventShape.links
  const linksMatch = content.match(/links:\s*\{[\s\S]*?properties:\s*\{([\s\S]*?)\n\s{10}\}/);
  if (linksMatch) {
    const propsBlock = linksMatch[1];
    const propMatches = propsBlock.matchAll(/^\s+(\w+):\s*\{/gm);
    for (const match of propMatches) {
      result.linksFields.add(match[1]);
    }
  }

  // Extract _sponsor properties
  const sponsorMatch = content.match(/_sponsor:\s*\{[\s\S]*?properties:\s*\{([\s\S]*?)\n\s{6}\}/);
  if (sponsorMatch) {
    const propsBlock = sponsorMatch[1];
    const propMatches = propsBlock.matchAll(/^\s+(\w+):\s*\{/gm);
    for (const match of propMatches) {
      result.sponsorFields.add(match[1]);
    }
  }

  return result;
}

/**
 * Parse surface HTML files for READS FROM blocks
 */
function parseSurfaceHeaders() {
  const surfaces = ['Admin.html', 'Public.html', 'Display.html', 'Poster.html', 'SharedReport.html'];
  const result = {};

  for (const surface of surfaces) {
    const filepath = path.join(MVP_DIR, surface);
    if (!fs.existsSync(filepath)) {
      continue;
    }

    const content = fs.readFileSync(filepath, 'utf8');
    const headerMatch = content.match(/<!--([\s\S]*?)-->/);
    if (!headerMatch) continue;

    const header = headerMatch[1];
    const fields = new Set();

    // Extract READS FROM section specifically (not the whole header)
    // Match from "READS FROM" until "WRITES TO", "SECTION GATES", or divider lines
    const readsSection = header.match(/READS FROM[\s\S]*?(?=WRITES TO|SECTION GATES|DO NOT|─{5,}|$)/i);
    if (!readsSection) {
      result[surface] = fields;
      continue;
    }

    const readsBlock = readsSection[0];

    // Extract all event.XXX top-level field references
    // Pattern: event.fieldName (followed by . or , or [ or whitespace or end)
    const fieldMatches = readsBlock.matchAll(/event\.([a-z][a-zA-Z_]*)(?:[.[,\s]|$)/g);
    for (const match of fieldMatches) {
      const field = match[1];
      // Skip 'schema' which appears in 'event.schema.json'
      if (field && field !== 'schema') {
        fields.add(field);
      }
    }

    // Extract event.settings.XXX references
    const settingsMatches = readsBlock.matchAll(/event\.settings\.([a-zA-Z]+)/g);
    for (const match of settingsMatches) {
      fields.add(`settings.${match[1]}`);
    }

    // Also match standalone settings.XXX (shorthand after first reference)
    // But only on lines that start with "event.settings" or have "settings" context
    const settingsLines = readsBlock.split('\n').filter(line => line.includes('settings'));
    for (const line of settingsLines) {
      const standaloneMches = line.matchAll(/\bshow[A-Z][a-zA-Z]+/g);
      for (const match of standaloneMches) {
        fields.add(`settings.${match[0]}`);
      }
    }

    // Extract event.links.XXX references
    const linksMatches = readsBlock.matchAll(/event\.links\.([a-zA-Z]+)/g);
    for (const match of linksMatches) {
      fields.add(`links.${match[1]}`);
    }

    // Also match links.XXX shorthand
    const linksLines = readsBlock.split('\n').filter(line => line.includes('links'));
    for (const line of linksLines) {
      const linkRefs = line.matchAll(/\b(publicUrl|displayUrl|posterUrl|signupUrl|sharedReportUrl)\b/g);
      for (const match of linkRefs) {
        fields.add(`links.${match[1]}`);
      }
    }

    result[surface] = fields;
  }

  return result;
}

// ============================================================================
// Validation Functions
// ============================================================================

/**
 * Validate event fixture against JSON schema using Ajv
 */
function validateWithAjv(schema, data, label) {
  const ajv = new Ajv2020({ strict: false, allErrors: true });
  const validate = ajv.compile(schema);
  const valid = validate(data);

  return {
    valid,
    label,
    errors: valid ? [] : validate.errors.map(e => ({
      path: e.instancePath || '/',
      message: e.message,
      keyword: e.keyword,
      params: e.params
    }))
  };
}

/**
 * Compare field sets between JSON schema and ApiSchemas.gs
 */
function compareFieldSets(jsonFields, gasFields, category) {
  const missingInGas = [];
  const missingInJson = [];

  for (const field of jsonFields) {
    if (!gasFields.has(field)) {
      missingInGas.push(field);
    }
  }

  for (const field of gasFields) {
    if (!jsonFields.has(field)) {
      missingInJson.push(field);
    }
  }

  return { missingInGas, missingInJson, category };
}

/**
 * Validate surface header references against schema
 */
function validateSurfaceHeaders(surfaceFields, schemaFields, settingsFields, linksFields) {
  const issues = [];

  for (const [surface, fields] of Object.entries(surfaceFields)) {
    // SharedReport.html uses shared-analytics schema, not event schema
    // Skip validation for it here (validated separately)
    if (surface === 'SharedReport.html') {
      continue;
    }

    for (const field of fields) {
      if (field.startsWith('settings.')) {
        const settingName = field.replace('settings.', '');
        if (!settingsFields.has(settingName)) {
          issues.push({ surface, field, message: `Setting '${settingName}' not in schema` });
        }
      } else if (field.startsWith('links.')) {
        const linkName = field.replace('links.', '');
        if (!linksFields.has(linkName)) {
          issues.push({ surface, field, message: `Link '${linkName}' not in schema` });
        }
      } else if (!schemaFields.has(field)) {
        issues.push({ surface, field, message: `Field '${field}' not in event schema` });
      }
    }
  }

  return issues;
}

// ============================================================================
// Output Formatting
// ============================================================================

function printHeader(text) {
  console.log(`\n${colors.cyan}${'═'.repeat(70)}${colors.reset}`);
  console.log(`${colors.cyan}  ${text}${colors.reset}`);
  console.log(`${colors.cyan}${'═'.repeat(70)}${colors.reset}\n`);
}

function printSection(text) {
  console.log(`${colors.dim}${'─'.repeat(50)}${colors.reset}`);
  console.log(`${text}`);
}

function printSuccess(message) {
  console.log(`  ${colors.green}✓${colors.reset} ${message}`);
}

function printFailure(message) {
  console.log(`  ${colors.red}✗${colors.reset} ${message}`);
}

function printWarning(message) {
  console.log(`  ${colors.yellow}⚠${colors.reset} ${message}`);
}

function printDetail(message) {
  console.log(`    ${colors.dim}${message}${colors.reset}`);
}

// ============================================================================
// Main Test Harness
// ============================================================================

function main() {
  console.log(`\n${colors.cyan}Event Schema Test Harness${colors.reset}`);
  console.log(`${colors.dim}Validating TemplateService + ApiSchemas alignment${colors.reset}`);

  let totalErrors = 0;
  let totalWarnings = 0;

  // ─────────────────────────────────────────────────────────────────────────
  // 1. Load JSON Schema
  // ─────────────────────────────────────────────────────────────────────────
  printHeader('1. JSON Schema Validation (via Ajv)');

  let eventSchema;
  try {
    eventSchema = loadJsonSchema('event.schema.json');
    printSuccess('Loaded /schemas/event.schema.json');
  } catch (e) {
    printFailure(`Failed to load event.schema.json: ${e.message}`);
    process.exit(1);
  }

  // ─────────────────────────────────────────────────────────────────────────
  // 2. Validate TemplateService fixture
  // ─────────────────────────────────────────────────────────────────────────
  printSection('Validating TemplateService fixture...');

  const fullResult = validateWithAjv(eventSchema, TEMPLATE_SERVICE_FIXTURE, 'Full Event (TemplateService output)');
  if (fullResult.valid) {
    printSuccess(fullResult.label);
  } else {
    printFailure(`${fullResult.label} - ${fullResult.errors.length} error(s)`);
    fullResult.errors.forEach(e => {
      printDetail(`${e.path}: ${e.message}`);
    });
    totalErrors += fullResult.errors.length;
  }

  // Validate minimal fixture
  const minimalResult = validateWithAjv(eventSchema, MINIMAL_EVENT_FIXTURE, 'Minimal Event (MVP Required only)');
  if (minimalResult.valid) {
    printSuccess(minimalResult.label);
  } else {
    printFailure(`${minimalResult.label} - ${minimalResult.errors.length} error(s)`);
    minimalResult.errors.forEach(e => {
      printDetail(`${e.path}: ${e.message}`);
    });
    totalErrors += minimalResult.errors.length;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // 3. ApiSchemas.gs vs JSON Schema diff
  // ─────────────────────────────────────────────────────────────────────────
  printHeader('2. ApiSchemas.gs ↔ JSON Schema Alignment');

  let gasSchemas;
  try {
    gasSchemas = parseApiSchemasGs();
    printSuccess('Parsed ApiSchemas.gs');
  } catch (e) {
    printFailure(`Failed to parse ApiSchemas.gs: ${e.message}`);
    totalErrors++;
    gasSchemas = { eventFields: new Set(), settingsFields: new Set(), linksFields: new Set(), sponsorFields: new Set() };
  }

  // Extract fields from JSON schema
  const jsonEventFields = new Set(Object.keys(eventSchema.properties));
  const jsonSettingsFields = new Set(Object.keys(eventSchema.$defs.Settings.properties));
  const jsonLinksFields = new Set(Object.keys(eventSchema.$defs.Links.properties));
  const jsonSponsorFields = new Set(Object.keys(eventSchema.$defs.Sponsor.properties));

  // Compare event top-level fields
  printSection('Comparing event top-level fields...');
  const eventComparison = compareFieldSets(jsonEventFields, gasSchemas.eventFields, 'Event');
  if (eventComparison.missingInGas.length === 0 && eventComparison.missingInJson.length === 0) {
    printSuccess(`Event fields aligned (${jsonEventFields.size} fields)`);
  } else {
    if (eventComparison.missingInGas.length > 0) {
      printFailure(`Missing in ApiSchemas.gs: ${eventComparison.missingInGas.join(', ')}`);
      totalErrors++;
    }
    if (eventComparison.missingInJson.length > 0) {
      printWarning(`Extra in ApiSchemas.gs (not in schema): ${eventComparison.missingInJson.join(', ')}`);
      totalWarnings++;
    }
  }

  // Compare links fields
  printSection('Comparing links fields...');
  const expectedLinks = ['publicUrl', 'displayUrl', 'posterUrl', 'signupUrl', 'sharedReportUrl'];
  const missingLinks = expectedLinks.filter(l => !jsonLinksFields.has(l));
  if (missingLinks.length === 0) {
    printSuccess(`Links: publicUrl, displayUrl, posterUrl, signupUrl ✓`);
    printSuccess(`Links: sharedReportUrl (V2 optional) ✓`);
  } else {
    printFailure(`Missing link fields in schema: ${missingLinks.join(', ')}`);
    totalErrors++;
  }

  // Compare settings fields
  printSection('Comparing settings fields...');
  const expectedSettings = {
    required: ['showSchedule', 'showStandings', 'showBracket'],
    mvpOptional: ['showSponsors', 'showSponsorBanner', 'showSponsorStrip', 'showLeagueStrip', 'showQRSection'],
    templateAware: ['showVideo', 'showMap', 'showGallery']
  };

  let settingsOk = true;
  expectedSettings.required.forEach(s => {
    if (!jsonSettingsFields.has(s)) {
      printFailure(`Missing MVP required setting: ${s}`);
      settingsOk = false;
      totalErrors++;
    }
  });
  if (settingsOk) {
    printSuccess(`MVP required settings: ${expectedSettings.required.join(', ')}`);
  }

  const mvpTogglesPresent = expectedSettings.mvpOptional.every(s => jsonSettingsFields.has(s));
  if (mvpTogglesPresent) {
    printSuccess(`MVP optional toggles: showSponsors, showSponsorBanner, showSponsorStrip, etc.`);
  } else {
    const missing = expectedSettings.mvpOptional.filter(s => !jsonSettingsFields.has(s));
    printFailure(`Missing MVP optional toggles: ${missing.join(', ')}`);
    totalErrors++;
  }

  const templateTogglesPresent = expectedSettings.templateAware.every(s => jsonSettingsFields.has(s));
  if (templateTogglesPresent) {
    printSuccess(`Template-aware toggles: showVideo, showMap, showGallery`);
  } else {
    const missing = expectedSettings.templateAware.filter(s => !jsonSettingsFields.has(s));
    printFailure(`Missing template-aware toggles: ${missing.join(', ')}`);
    totalErrors++;
  }

  // Compare sponsor fields
  printSection('Comparing sponsor fields...');
  const expectedSponsorFields = ['id', 'name', 'logoUrl', 'linkUrl', 'placement'];
  const missingSponsorFields = expectedSponsorFields.filter(f => !jsonSponsorFields.has(f));
  if (missingSponsorFields.length === 0) {
    printSuccess(`Sponsor fields: ${expectedSponsorFields.join(', ')}`);
  } else {
    printFailure(`Missing sponsor fields: ${missingSponsorFields.join(', ')}`);
    totalErrors++;
  }

  // ─────────────────────────────────────────────────────────────────────────
  // 4. Surface Header Consistency Check
  // ─────────────────────────────────────────────────────────────────────────
  printHeader('3. Surface Header Comments Consistency');

  let surfaceFields;
  try {
    surfaceFields = parseSurfaceHeaders();
    printSuccess(`Parsed ${Object.keys(surfaceFields).length} surface files`);
  } catch (e) {
    printFailure(`Failed to parse surface headers: ${e.message}`);
    totalErrors++;
    surfaceFields = {};
  }

  // Validate each surface
  const surfaceIssues = validateSurfaceHeaders(surfaceFields, jsonEventFields, jsonSettingsFields, jsonLinksFields);

  if (surfaceIssues.length === 0) {
    for (const [surface, fields] of Object.entries(surfaceFields)) {
      printSuccess(`${surface}: ${fields.size} field references validated`);
    }
  } else {
    for (const issue of surfaceIssues) {
      printFailure(`${issue.surface}: ${issue.message}`);
      totalErrors++;
    }
  }

  // ─────────────────────────────────────────────────────────────────────────
  // Summary
  // ─────────────────────────────────────────────────────────────────────────
  printHeader('Summary');

  if (totalErrors === 0) {
    console.log(`${colors.green}✓ All schema validations passed!${colors.reset}`);
    if (totalWarnings > 0) {
      console.log(`${colors.yellow}  (${totalWarnings} warning(s) - non-blocking)${colors.reset}`);
    }
    console.log(`\n${colors.dim}Event schema is locked and consistent across:${colors.reset}`);
    console.log(`${colors.dim}  - /schemas/event.schema.json${colors.reset}`);
    console.log(`${colors.dim}  - src/mvp/ApiSchemas.gs${colors.reset}`);
    console.log(`${colors.dim}  - Surface HTML headers${colors.reset}\n`);
    process.exit(0);
  } else {
    console.log(`${colors.red}✗ ${totalErrors} validation error(s) found${colors.reset}`);
    if (totalWarnings > 0) {
      console.log(`${colors.yellow}  (${totalWarnings} warning(s))${colors.reset}`);
    }
    console.log(`\n${colors.dim}Fix the issues above to ensure schema consistency.${colors.reset}`);
    console.log(`${colors.dim}See /schemas/event.schema.json for the canonical definition.${colors.reset}\n`);
    process.exit(1);
  }
}

// Run if executed directly
if (require.main === module) {
  main();
}

// Export for testing
module.exports = {
  TEMPLATE_SERVICE_FIXTURE,
  MINIMAL_EVENT_FIXTURE,
  loadJsonSchema,
  parseApiSchemasGs,
  parseSurfaceHeaders,
  validateWithAjv
};
