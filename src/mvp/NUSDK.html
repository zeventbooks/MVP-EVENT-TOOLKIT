<!--
═══════════════════════════════════════════════════════════════════════════════
NUSDK - Zeventbook Client SDK for Google Apps Script
═══════════════════════════════════════════════════════════════════════════════

RESPONSIBILITY: This file provides the RPC client for frontend→backend calls ONLY.
It does NOT implement business logic - that belongs in Code.gs.

WINDOW ADDITION: window.NU

RESPONSE ENVELOPE CONTRACT (all API endpoints follow this pattern):

SUCCESS:
{
  ok: true,
  etag?: string,           // Optional cache tag for SWR
  notModified?: boolean,   // True if content unchanged (304 equivalent)
  value: { ... }           // Endpoint-specific payload per ApiSchemas.gs
}

ERROR:
{
  ok: false,
  code: "BAD_INPUT" | "NOT_FOUND" | "RATE_LIMITED" | "INTERNAL" | "UNAUTHORIZED",
  message: "Human-readable error description"
}

USAGE:
  const res = await NU.rpc('api_getPublicBundle', { brandId, scope, id });
  if (!res.ok) {
    console.error(res.code, res.message);
    return;
  }
  const { event, config } = res.value;

See ApiSchemas.gs for full endpoint inventory and schemas.
═══════════════════════════════════════════════════════════════════════════════
-->
<script>
window.NU = {
  /**
   * Error telemetry: structured error log buffer
   * Prevents spam by deduplicating errors within a short time window
   * @private
   */
  _errorLog: [],
  _errorDedupeWindow: 5000, // 5 seconds deduplication window

  /**
   * Structured error logging for telemetry
   * Logs a single structured error when API returns ok:false (no spam)
   *
   * @param {object} params - Error parameters
   * @param {string} params.method - API method that failed
   * @param {string} params.code - Error code from response
   * @param {string} params.message - Error message
   * @param {string} params.corrId - Correlation ID if available
   * @private
   */
  _logError(params) {
    const { method, code, message, corrId } = params;
    const timestamp = new Date().toISOString();

    // Dedupe key: method + code within time window
    const dedupeKey = `${method}:${code}`;
    const now = Date.now();

    // Check for recent duplicate
    const recentError = NU._errorLog.find(e =>
      e.key === dedupeKey && (now - e.time) < NU._errorDedupeWindow
    );

    if (recentError) {
      // Skip duplicate error within time window
      return;
    }

    // Add to error log (keep last 50 entries)
    NU._errorLog.push({ key: dedupeKey, time: now });
    if (NU._errorLog.length > 50) {
      NU._errorLog.shift();
    }

    // Build structured error entry
    const errorEntry = {
      timestamp,
      method,
      code: code || 'UNKNOWN',
      message: message || 'Unknown error'
    };
    if (corrId) errorEntry.corrId = corrId;

    // Single structured console output for telemetry
    console.error('[NUSDK:Error]', JSON.stringify(errorEntry));
  },

  /**
   * Make an RPC call to the backend
   *
   * Uses fetch('/api/rpc') when available (Cloudflare Worker proxy),
   * falls back to google.script.run for direct GAS serving.
   *
   * @param {string} method - API method name (e.g., 'api_getPublicBundle')
   * @param {object} payload - Request parameters
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async rpc(method, payload) {
    // Try fetch first (works with Cloudflare Worker proxy)
    // This enables friendly URLs like eventangle.com/events
    try {
      const response = await fetch('/api/rpc', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ method, payload }),
        credentials: 'same-origin'
      });

      if (!response.ok) {
        // HTTP error - try to parse JSON error response
        try {
          const errorData = await response.json();
          console.error('[NUSDK] HTTP error for', method, ':', response.status, errorData);
          return errorData;
        } catch {
          console.error('[NUSDK] HTTP error for', method, ':', response.status);
          return { ok: false, code: 'INTERNAL', message: `HTTP ${response.status}` };
        }
      }

      const data = await response.json();
      return data;

    } catch (fetchError) {
      // Fetch failed - fall back to google.script.run if available
      // This happens when:
      // 1. Page is served directly from GAS (no worker proxy)
      // 2. Network error
      console.debug('[NUSDK] fetch failed, trying google.script.run:', fetchError.message);

      return new Promise((resolve) => {
        // Check if google.script.run is available
        if (!window.google || !window.google.script || !window.google.script.run) {
          console.error('[NUSDK] Neither fetch nor google.script.run available');
          resolve({ ok: false, code: 'NETWORK_ERROR', message: 'Cannot connect to backend. Check your connection.' });
          return;
        }

        try {
          google.script.run
            .withSuccessHandler(res => resolve(res))
            .withFailureHandler(err => {
              console.error('[NUSDK] Server error for', method, ':', err);
              resolve({ ok: false, code: 'INTERNAL', message: String(err) });
            })
            [method](payload);
        } catch (e) {
          console.error('[NUSDK] Exception calling', method, ':', e);
          resolve({ ok: false, code: 'INTERNAL', message: String(e) });
        }
      });
    }
  },

  /**
   * Stale-while-revalidate pattern for cached data
   * Returns cached data immediately, then fetches fresh data
   * @param {string} method - API method name
   * @param {object} payload - Request parameters
   * @param {object} options - { staleMs, onUpdate }
   */
  swr(method, payload, { staleMs = 120000, onUpdate } = {}) {
    const key = `swr:${method}:${JSON.stringify(payload || {})}`;
    const cached = JSON.parse(localStorage.getItem(key) || '{}');
    if (cached.data) setTimeout(() => onUpdate && onUpdate(cached.data), 0);
    NU.rpc(method, { ...(payload || {}), ifNoneMatch: cached.etag }).then(res => {
      if (res && res.notModified) return;
      if (res && res.ok && res.value) {
        localStorage.setItem(key, JSON.stringify({ etag: res.etag, data: res.value, t: Date.now() }));
        onUpdate && onUpdate(res.value);
      }
    });
  },

  /**
   * Escapes HTML special characters to prevent XSS
   * @param {string} s - String to escape
   * @returns {string} HTML-safe string
   */
  esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  },

  /**
   * Safe RPC wrapper with graceful error handling for UI display
   * Normalizes all error types to a consistent format for StateRenderer
   * Logs structured errors for telemetry when API returns ok:false
   *
   * @param {string} method - API method name
   * @param {object} payload - Request parameters
   * @param {object} options - { onError, silent }
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async safeRpc(method, payload, options = {}) {
    const { onError, silent = false } = options;

    try {
      const res = await NU.rpc(method, payload);

      // Handle backend error responses (ok: false)
      if (!res.ok) {
        const errorInfo = {
          ok: false,
          code: res.code || 'UNKNOWN',
          message: res.message || 'An unexpected error occurred',
          corrId: res.corrId
        };

        // Log single structured error for telemetry (no spam via dedupe)
        if (!silent) {
          NU._logError({
            method,
            code: errorInfo.code,
            message: errorInfo.message,
            corrId: errorInfo.corrId
          });
        }

        if (onError) {
          onError(errorInfo);
        }

        return errorInfo;
      }

      return res;

    } catch (e) {
      // Handle network/runtime errors
      const errorInfo = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'We\'re having trouble connecting. Please check your connection and try again.'
      };

      // Log structured error for network failures
      if (!silent) {
        NU._logError({
          method,
          code: errorInfo.code,
          message: e?.message || errorInfo.message
        });
      }

      if (onError) {
        onError(errorInfo);
      }

      return errorInfo;
    }
  },

  /**
   * Fire-and-forget analytics logging that NEVER throws or blocks UI
   * Analytics failures are silently logged but don't affect page functionality
   *
   * Use this for:
   * - CTA click tracking
   * - Impression logging
   * - Dwell time tracking
   * - Any non-critical telemetry
   *
   * @param {string} method - Analytics API method (e.g., 'api_logExternalClick', 'api_logEvents')
   * @param {object} payload - Analytics data
   * @returns {void} - Does not return a promise to ensure fire-and-forget behavior
   */
  safeAnalytics(method, payload) {
    // Fire and forget - don't await, don't block
    (async () => {
      try {
        // Try fetch first (works with Cloudflare Worker proxy)
        const response = await fetch('/api/rpc', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({ method, payload }),
          credentials: 'same-origin'
        });

        if (!response.ok) {
          console.debug(`[NUSDK] Analytics ${method} HTTP ${response.status}`);
        }

      } catch (fetchError) {
        // Fetch failed - try google.script.run as fallback
        try {
          if (!window.google || !window.google.script || !window.google.script.run) {
            console.debug('[NUSDK] Analytics skipped: no backend available');
            return;
          }

          google.script.run
            .withSuccessHandler(() => {})
            .withFailureHandler((err) => {
              console.debug(`[NUSDK] Analytics ${method} failed silently:`, err?.message || err);
            })
            [method](payload);

        } catch (e) {
          console.debug(`[NUSDK] Analytics ${method} exception (suppressed):`, e?.message || e);
        }
      }
    })();
  },

  /**
   * Safe analytics batch logger - fire-and-forget version of api_logEvents
   * For bulk logging impressions, clicks, etc.
   *
   * @param {Array} items - Array of analytics items [{eventId, surface, metric, sponsorId?, value?}]
   */
  safeLogEvents(items) {
    if (!items || !items.length) return;
    NU.safeAnalytics('api_logEvents', { items });
  },

  /**
   * Safe external click logger - fire-and-forget version
   * Logs CTA/sponsor clicks without blocking navigation
   *
   * @param {object} params - { eventId, sponsorId, surface, linkType?, ua? }
   */
  safeLogClick(params) {
    NU.safeAnalytics('api_logExternalClick', {
      ...params,
      ua: params.ua || navigator.userAgent
    });
  }
};
</script>
