<!--
═══════════════════════════════════════════════════════════════════════════════
NUSDK - Zeventbook Client SDK for Google Apps Script
═══════════════════════════════════════════════════════════════════════════════

RESPONSIBILITY: This file provides the RPC client for frontend→backend calls ONLY.
It does NOT implement business logic - that belongs in Code.gs.

WINDOW ADDITION: window.NU

RESPONSE ENVELOPE CONTRACT (all API endpoints follow this pattern):

SUCCESS:
{
  ok: true,
  etag?: string,           // Optional cache tag for SWR
  notModified?: boolean,   // True if content unchanged (304 equivalent)
  value: { ... }           // Endpoint-specific payload per ApiSchemas.gs
}

ERROR:
{
  ok: false,
  code: "BAD_INPUT" | "NOT_FOUND" | "RATE_LIMITED" | "INTERNAL" | "UNAUTHORIZED",
  message: "Human-readable error description"
}

USAGE:
  const res = await NU.rpc('api_getPublicBundle', { brandId, scope, id });
  if (!res.ok) {
    console.error(res.code, res.message);
    return;
  }
  const { event, config } = res.value;

See ApiSchemas.gs for full endpoint inventory and schemas.
═══════════════════════════════════════════════════════════════════════════════
-->
<script>
window.NU = {
  /**
   * Make an RPC call to the Google Apps Script backend
   * @param {string} method - API method name (e.g., 'api_getPublicBundle')
   * @param {object} payload - Request parameters
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  rpc(method, payload) {
    return new Promise((resolve) => {
      // Check if google.script.run is available (required for GAS HTML pages)
      if (!window.google || !window.google.script || !window.google.script.run) {
        console.error('[NUSDK] google.script.run is not available');
        resolve({ ok: false, code: 'INTERNAL', message: 'google.script.run not available - page must be served from Apps Script' });
        return;
      }

      try {
        google.script.run
          .withSuccessHandler(res => resolve(res))
          .withFailureHandler(err => {
            console.error('[NUSDK] Server error for', method, ':', err);
            resolve({ ok: false, code: 'INTERNAL', message: String(err) });
          })
          [method](payload);
      } catch (e) {
        console.error('[NUSDK] Exception calling', method, ':', e);
        resolve({ ok: false, code: 'INTERNAL', message: String(e) });
      }
    });
  },

  /**
   * Stale-while-revalidate pattern for cached data
   * Returns cached data immediately, then fetches fresh data
   * @param {string} method - API method name
   * @param {object} payload - Request parameters
   * @param {object} options - { staleMs, onUpdate }
   */
  swr(method, payload, { staleMs = 120000, onUpdate } = {}) {
    const key = `swr:${method}:${JSON.stringify(payload || {})}`;
    const cached = JSON.parse(localStorage.getItem(key) || '{}');
    if (cached.data) setTimeout(() => onUpdate && onUpdate(cached.data), 0);
    NU.rpc(method, { ...(payload || {}), ifNoneMatch: cached.etag }).then(res => {
      if (res && res.notModified) return;
      if (res && res.ok && res.value) {
        localStorage.setItem(key, JSON.stringify({ etag: res.etag, data: res.value, t: Date.now() }));
        onUpdate && onUpdate(res.value);
      }
    });
  },

  /**
   * Escapes HTML special characters to prevent XSS
   * @param {string} s - String to escape
   * @returns {string} HTML-safe string
   */
  esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  },

  /**
   * Safe RPC wrapper with graceful error handling for UI display
   * Normalizes all error types to a consistent format for StateRenderer
   *
   * @param {string} method - API method name
   * @param {object} payload - Request parameters
   * @param {object} options - { onError, silent }
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async safeRpc(method, payload, options = {}) {
    const { onError, silent = false } = options;

    try {
      const res = await NU.rpc(method, payload);

      // Handle backend error responses (ok: false)
      if (!res.ok) {
        const errorInfo = {
          ok: false,
          code: res.code || 'UNKNOWN',
          message: res.message || 'An unexpected error occurred',
          corrId: res.corrId
        };

        if (!silent) {
          console.warn(`[NUSDK] API error for ${method}:`, errorInfo.code, errorInfo.message);
        }

        if (onError) {
          onError(errorInfo);
        }

        return errorInfo;
      }

      return res;

    } catch (e) {
      // Handle network/runtime errors
      const errorInfo = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'We\'re having trouble connecting. Please check your connection and try again.'
      };

      if (!silent) {
        console.error(`[NUSDK] Network/runtime error for ${method}:`, e);
      }

      if (onError) {
        onError(errorInfo);
      }

      return errorInfo;
    }
  },

  /**
   * Fire-and-forget analytics logging that NEVER throws or blocks UI
   * Analytics failures are silently logged but don't affect page functionality
   *
   * Use this for:
   * - CTA click tracking
   * - Impression logging
   * - Dwell time tracking
   * - Any non-critical telemetry
   *
   * @param {string} method - Analytics API method (e.g., 'api_logExternalClick', 'api_logEvents')
   * @param {object} payload - Analytics data
   * @returns {void} - Does not return a promise to ensure fire-and-forget behavior
   */
  safeAnalytics(method, payload) {
    // Fire and forget - don't await, don't block
    (async () => {
      try {
        // Check if google.script.run is available
        if (!window.google || !window.google.script || !window.google.script.run) {
          // Silently fail - analytics shouldn't break the page
          console.debug('[NUSDK] Analytics skipped: google.script.run not available');
          return;
        }

        google.script.run
          .withSuccessHandler(() => {
            // Success - no action needed
          })
          .withFailureHandler((err) => {
            // Log quietly but don't propagate error
            console.debug(`[NUSDK] Analytics ${method} failed silently:`, err?.message || err);
          })
          [method](payload);

      } catch (e) {
        // Catch any synchronous errors and log quietly
        console.debug(`[NUSDK] Analytics ${method} exception (suppressed):`, e?.message || e);
      }
    })();
  },

  /**
   * Safe analytics batch logger - fire-and-forget version of api_logEvents
   * For bulk logging impressions, clicks, etc.
   *
   * @param {Array} items - Array of analytics items [{eventId, surface, metric, sponsorId?, value?}]
   */
  safeLogEvents(items) {
    if (!items || !items.length) return;
    NU.safeAnalytics('api_logEvents', { items });
  },

  /**
   * Safe external click logger - fire-and-forget version
   * Logs CTA/sponsor clicks without blocking navigation
   *
   * @param {object} params - { eventId, sponsorId, surface, linkType?, ua? }
   */
  safeLogClick(params) {
    NU.safeAnalytics('api_logExternalClick', {
      ...params,
      ua: params.ua || navigator.userAgent
    });
  }
};
</script>
