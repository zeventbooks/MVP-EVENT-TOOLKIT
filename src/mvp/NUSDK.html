<!--
═══════════════════════════════════════════════════════════════════════════════
NUSDK v2.0 - Fetch-Based NU SDK for Google Apps Script
═══════════════════════════════════════════════════════════════════════════════

RESPONSIBILITY: This file provides the RPC client for frontend→backend calls ONLY.
It does NOT implement business logic - that belongs in Code.gs.

WINDOW ADDITIONS:
- window.NU        - Main SDK object
- window.__NU_LOGS__ - Rolling log buffer for diagnostics
- window.NU_DIAG   - Diagnostic helper for Test.html

TRANSPORT: Fetch-based (/api/<path>) with google.script.run fallback

LOGGING LEVELS:
- Staging: 'debug' (all logs)
- Production: 'error' (errors only)

RESPONSE ENVELOPE CONTRACT (all API endpoints follow this pattern):

SUCCESS:
{
  ok: true,
  etag?: string,           // Optional cache tag for SWR
  notModified?: boolean,   // True if content unchanged (304 equivalent)
  value: { ... }           // Endpoint-specific payload per ApiSchemas.gs
}

ERROR:
{
  ok: false,
  code: "BAD_INPUT" | "NOT_FOUND" | "RATE_LIMITED" | "INTERNAL" | "UNAUTHORIZED",
  message: "Human-readable error description"
}

USAGE:
  const res = await NU.rpc('events/list', { brandId });
  if (!res.ok) {
    console.error(res.code, res.message);
    return;
  }
  const { events } = res.value;

See ApiSchemas.gs for full endpoint inventory and schemas.
═══════════════════════════════════════════════════════════════════════════════
-->
<script>
// =============================================================================
// Rolling Log Buffer - Global diagnostic storage
// =============================================================================
window.__NU_LOGS__ = [];

// =============================================================================
// NU SDK - Main SDK Object
// =============================================================================
window.NU = {
  /**
   * SDK Version
   */
  VERSION: '2.0.0',

  /**
   * Configuration
   * @private
   */
  _config: {
    logLevel: 'debug', // 'debug' | 'error' | 'none' - auto-detected from environment
    maxLogs: 100,      // Max entries in rolling log buffer
    apiBase: '/api',   // Base path for API endpoints
    dedupeWindow: 5000 // Error deduplication window (ms)
  },

  /**
   * Log level constants
   * @private
   */
  _LOG_LEVELS: Object.freeze({ none: 0, error: 1, debug: 2 }),

  /**
   * Pending requests for flush tracking
   * @private
   */
  _pending: [],

  /**
   * Error deduplication tracking
   * @private
   */
  _errorDedupeMap: new Map(),

  /**
   * Environment flags - detected once at init
   * @private
   */
  _env: {
    isStaging: false,
    isProduction: false,
    hostname: ''
  },

  /**
   * Initialize SDK - auto-detect environment and set log level
   * @private
   */
  _init() {
    // Auto-detect environment from hostname
    // SECURITY: Use exact match or suffix match to prevent subdomain spoofing
    // e.g., "fake-eventangle.com" should NOT match as production
    const hostname = window.location?.hostname || '';

    // Helper for safe domain suffix check
    const isDomain = (host, domain) =>
      host === domain || host.endsWith('.' + domain);

    const isStaging = isDomain(hostname, 'stg.eventangle.com') ||
                      hostname === 'localhost' ||
                      hostname === '127.0.0.1';
    const isProduction = isDomain(hostname, 'eventangle.com') && !isStaging;

    // Store environment flags for use by other components
    NU._env = { isStaging, isProduction, hostname };

    // Set log level based on environment
    if (isProduction) {
      NU._config.logLevel = 'error';
    } else {
      NU._config.logLevel = 'debug';
    }

    NU._log('debug', 'init', {
      version: NU.VERSION,
      logLevel: NU._config.logLevel,
      hostname,
      isStaging,
      isProduction
    });
  },

  /**
   * Check if running in staging environment
   * Useful for showing diagnostic information in staging only
   * @returns {boolean} True if staging environment
   */
  isStaging() {
    return NU._env.isStaging;
  },

  /**
   * Check if running in production environment
   * @returns {boolean} True if production environment
   */
  isProduction() {
    return NU._env.isProduction;
  },

  /**
   * Internal logging with rolling buffer
   * Logs to both __NU_LOGS__ buffer and console (based on log level)
   *
   * @param {string} level - 'debug' | 'error'
   * @param {string} type - Log type: 'start' | 'ok' | 'network_fail' | 'http_fail' | 'json_fail' | 'error'
   * @param {object} data - Log data
   * @private
   */
  _log(level, type, data = {}) {
    const entry = {
      timestamp: new Date().toISOString(),
      level,
      type,
      ...data
    };

    // Add timing if startTime provided
    if (data.startTime) {
      entry.durationMs = Date.now() - data.startTime;
      delete entry.startTime;
    }

    // Add to rolling buffer
    window.__NU_LOGS__.push(entry);
    if (window.__NU_LOGS__.length > NU._config.maxLogs) {
      window.__NU_LOGS__.shift();
    }

    // Console output based on log level
    const currentLevel = NU._LOG_LEVELS[NU._config.logLevel] || 0;
    const entryLevel = NU._LOG_LEVELS[level] || 0;

    if (entryLevel <= currentLevel) {
      const prefix = '[NUSDK]';
      const logData = { ...entry };
      delete logData.timestamp;
      delete logData.level;

      if (level === 'error') {
        console.error(prefix, type, JSON.stringify(logData));
      } else {
        console.debug(prefix, type, JSON.stringify(logData));
      }
    }
  },

  /**
   * Check for duplicate error (deduplication within time window)
   * @private
   */
  _isDuplicateError(path, code) {
    const key = `${path}:${code}`;
    const now = Date.now();
    const lastTime = NU._errorDedupeMap.get(key);

    if (lastTime && (now - lastTime) < NU._config.dedupeWindow) {
      return true;
    }

    NU._errorDedupeMap.set(key, now);

    // Clean old entries periodically
    if (NU._errorDedupeMap.size > 100) {
      for (const [k, t] of NU._errorDedupeMap.entries()) {
        if (now - t > NU._config.dedupeWindow) {
          NU._errorDedupeMap.delete(k);
        }
      }
    }

    return false;
  },

  /**
   * Make an RPC call to the backend via Cloudflare Worker proxy
   *
   * Uses fetch('/api/<path>') for all requests. NO google.script.run fallback
   * as it fails when proxied through Cloudflare.
   *
   * @param {string} path - API path (e.g., 'events/list', 'getPublicBundle')
   * @param {object} payload - Request parameters
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async rpc(path, payload = {}) {
    const startTime = Date.now();
    const requestId = Math.random().toString(36).slice(2, 10);

    // Log request start
    NU._log('debug', 'start', { path, requestId, payloadKeys: Object.keys(payload) });

    // Track pending request
    const pendingEntry = { path, requestId, startTime };
    NU._pending.push(pendingEntry);

    try {
      // Build API URL - support both path formats:
      // - 'events/list' -> '/api/events/list'
      // - 'api_getPublicBundle' -> '/api/rpc' with method in body (legacy)
      const isLegacyMethod = path.startsWith('api_');
      const url = isLegacyMethod
        ? `${NU._config.apiBase}/rpc`
        : `${NU._config.apiBase}/${path}`;

      const body = isLegacyMethod
        ? JSON.stringify({ method: path, payload })
        : JSON.stringify(payload);

      // Make fetch request (NO google.script.run fallback - fails through Cloudflare)
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-Request-Id': requestId
        },
        body,
        credentials: 'same-origin'
      });

      // Handle HTTP errors
      // Story 4: Preserve status and errorCode from Worker for frontend error classification
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          errorData = { ok: false, code: 'INTERNAL', message: `HTTP ${response.status}` };
        }

        // Ensure status is always present for error classification
        // Story 4: Worker may return { ok, errorCode, status, message }
        if (!errorData.status) {
          errorData.status = response.status;
        }

        NU._log('error', 'http_fail', {
          path,
          requestId,
          status: errorData.status,
          code: errorData.code || errorData.errorCode,
          errorCode: errorData.errorCode,
          startTime
        });

        return errorData;
      }

      // Parse JSON response
      let data;
      try {
        data = await response.json();
      } catch (jsonError) {
        NU._log('error', 'json_fail', {
          path,
          requestId,
          error: jsonError.message,
          startTime
        });
        return { ok: false, code: 'INTERNAL', message: 'Invalid JSON response' };
      }

      // Log success with timing
      NU._log('debug', 'ok', {
        path,
        requestId,
        hasValue: !!data?.value,
        startTime
      });

      return data;

    } catch (fetchError) {
      // Network error - NO fallback to google.script.run (fails through Cloudflare)
      NU._log('error', 'network_fail', {
        path,
        requestId,
        error: fetchError.message,
        startTime
      });
      return {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Cannot connect to backend. Check your connection.'
      };

    } finally {
      // Remove from pending
      const idx = NU._pending.indexOf(pendingEntry);
      if (idx > -1) NU._pending.splice(idx, 1);
    }
  },

  /**
   * Flush all pending requests
   * Waits for all in-flight requests to complete
   *
   * @returns {Promise<void>}
   */
  async flush() {
    if (NU._pending.length === 0) {
      NU._log('debug', 'flush', { message: 'No pending requests' });
      return;
    }

    NU._log('debug', 'flush', { pendingCount: NU._pending.length });

    // Wait for all pending requests (with timeout)
    const timeout = 5000;
    const startTime = Date.now();

    while (NU._pending.length > 0 && (Date.now() - startTime) < timeout) {
      await new Promise(r => setTimeout(r, 100));
    }

    if (NU._pending.length > 0) {
      NU._log('error', 'flush', {
        message: 'Timeout waiting for pending requests',
        remaining: NU._pending.length
      });
    } else {
      NU._log('debug', 'flush', { message: 'All requests completed' });
    }
  },

  /**
   * Stale-while-revalidate pattern for cached data
   * Returns cached data immediately, then fetches fresh data
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - { staleMs, onUpdate }
   */
  swr(path, payload, { staleMs = 120000, onUpdate } = {}) {
    const key = `swr:${path}:${JSON.stringify(payload || {})}`;
    const cached = JSON.parse(localStorage.getItem(key) || '{}');

    if (cached.data) {
      setTimeout(() => onUpdate && onUpdate(cached.data), 0);
    }

    NU.rpc(path, { ...(payload || {}), ifNoneMatch: cached.etag }).then(res => {
      if (res?.notModified) return;
      if (res?.ok && res.value) {
        localStorage.setItem(key, JSON.stringify({
          etag: res.etag,
          data: res.value,
          t: Date.now()
        }));
        onUpdate && onUpdate(res.value);
      }
    });
  },

  /**
   * Escapes HTML special characters to prevent XSS
   *
   * @param {string} s - String to escape
   * @returns {string} HTML-safe string
   */
  esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  },

  /**
   * Safe RPC wrapper with graceful error handling for UI display
   * Normalizes all error types to a consistent format for StateRenderer
   *
   * Story 4: Preserves status and errorCode from Worker for error classification:
   * - status: HTTP status code (400-599)
   * - errorCode: Specific error code like 'GAS_UPSTREAM_NON_JSON'
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - { onError, silent }
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string, status?: number, errorCode?: string}>}
   */
  async safeRpc(path, payload, options = {}) {
    const { onError, silent = false } = options;

    try {
      const res = await NU.rpc(path, payload);

      // Handle backend error responses (ok: false)
      if (!res.ok) {
        // Story 4: Preserve status and errorCode for frontend error classification
        const errorInfo = {
          ok: false,
          code: res.code || res.errorCode || 'UNKNOWN',
          errorCode: res.errorCode,  // Specific error code from Worker (e.g., GAS_UPSTREAM_NON_JSON)
          status: res.status,         // HTTP status code for classification
          message: res.message || 'An unexpected error occurred',
          corrId: res.corrId
        };

        // Log error (with deduplication)
        if (!silent && !NU._isDuplicateError(path, errorInfo.code)) {
          NU._log('error', 'error', {
            path,
            code: errorInfo.code,
            errorCode: errorInfo.errorCode,
            status: errorInfo.status,
            message: errorInfo.message,
            corrId: errorInfo.corrId
          });
        }

        if (onError) onError(errorInfo);
        return errorInfo;
      }

      return res;

    } catch (e) {
      // Handle network/runtime errors
      const errorInfo = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'We\'re having trouble connecting. Please check your connection and try again.'
      };

      if (!silent && !NU._isDuplicateError(path, 'NETWORK_ERROR')) {
        NU._log('error', 'network_fail', {
          path,
          error: e?.message || errorInfo.message
        });
      }

      if (onError) onError(errorInfo);
      return errorInfo;
    }
  },

  /**
   * Fire-and-forget analytics logging that NEVER throws or blocks UI
   *
   * @param {string} path - Analytics API path
   * @param {object} payload - Analytics data
   * @returns {void}
   */
  safeAnalytics(path, payload) {
    // Fire and forget - don't await, don't block
    (async () => {
      try {
        const url = path.startsWith('api_')
          ? `${NU._config.apiBase}/rpc`
          : `${NU._config.apiBase}/${path}`;

        const body = path.startsWith('api_')
          ? JSON.stringify({ method: path, payload })
          : JSON.stringify(payload);

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body,
          credentials: 'same-origin'
        });

        if (!response.ok) {
          NU._log('debug', 'analytics_fail', { path, status: response.status });
        }

      } catch (fetchError) {
        // Fallback to google.script.run
        try {
          if (!window.google?.script?.run) {
            NU._log('debug', 'analytics_skip', { path, reason: 'no backend' });
            return;
          }

          const method = path.startsWith('api_') ? path : `api_${path.replace('/', '_')}`;
          google.script.run
            .withSuccessHandler(() => {})
            .withFailureHandler(() => {})
            [method](payload);

        } catch {
          // Silently ignore analytics failures
        }
      }
    })();
  },

  /**
   * Safe analytics batch logger
   *
   * @param {Array} items - Array of analytics items
   */
  safeLogEvents(items) {
    if (!items?.length) return;
    NU.safeAnalytics('api_logEvents', { items });
  },

  /**
   * Safe external click logger
   *
   * @param {object} params - { eventId, sponsorId, surface, linkType?, ua? }
   */
  safeLogClick(params) {
    NU.safeAnalytics('api_logExternalClick', {
      ...params,
      ua: params.ua || navigator.userAgent
    });
  },

  /**
   * Set log level manually
   *
   * @param {'debug' | 'error' | 'none'} level - Log level
   */
  setLogLevel(level) {
    if (NU._LOG_LEVELS.hasOwnProperty(level)) {
      NU._config.logLevel = level;
      NU._log('debug', 'config', { logLevel: level });
    }
  },

  /**
   * Get current configuration (for diagnostics)
   *
   * @returns {object} Current SDK configuration
   */
  getConfig() {
    return { ...NU._config, version: NU.VERSION };
  },

  // =============================================================================
  // Story 4.3: Enhanced API Wrappers with Global Error Handling
  // =============================================================================

  /**
   * Enhanced RPC with automatic retry and user feedback
   * Integrates with GlobalErrorHandler for comprehensive error handling
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Enhanced options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async resilientRpc(path, payload = {}, options = {}) {
    const {
      retry = true,
      maxAttempts = 3,
      showToast = true,
      showDialog = false,
      onError = null,
      onRetryAttempt = null,
      context = path
    } = options;

    // Use GlobalErrorHandler if available
    const handler = window.GlobalErrorHandler;

    const makeRequest = async () => {
      const res = await NU.rpc(path, payload);
      if (!res.ok) {
        // Convert to throwable error for retry logic
        const err = new Error(res.message || 'Request failed');
        err.code = res.code;
        err.corrId = res.corrId;
        err.response = res;
        throw err;
      }
      return res;
    };

    try {
      if (retry && handler) {
        // Use GlobalErrorHandler's retry with exponential backoff
        return await handler.withRetry(makeRequest, {
          attempts: maxAttempts,
          shouldRetry: (err) => {
            // Only retry network and transient errors
            const code = err?.code || err?.response?.code;
            return ['NETWORK_ERROR', 'TIMEOUT', 'SERVICE_UNAVAILABLE'].includes(code);
          },
          onRetryAttempt: (attempt, total, delay, err) => {
            NU._log('debug', 'retry', { path, attempt, total, delay, code: err?.code });
            if (onRetryAttempt) onRetryAttempt(attempt, total, delay, err);
          }
        });
      } else {
        return await makeRequest();
      }
    } catch (err) {
      // Return the original error response if available
      if (err.response) {
        if (onError) onError(err.response);

        if (handler) {
          if (showDialog) {
            handler.showErrorDialog({
              title: 'Unable to Complete Request',
              message: `We couldn't ${context}. Please try again.`,
              corrId: err.corrId,
              onRetry: () => NU.resilientRpc(path, payload, options)
            });
          } else if (showToast) {
            handler.showErrorToast(`Unable to ${context}. Please try again.`);
          }
        }

        return err.response;
      }

      // Network error without response
      const errorResponse = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Cannot connect to server. Please check your connection.'
      };

      if (onError) onError(errorResponse);

      if (handler && showToast) {
        handler.showErrorToast('Connection error. Please check your network.');
      }

      return errorResponse;
    }
  },

  /**
   * Load data with comprehensive error handling and UI state management
   * Perfect for initial page loads and data refresh
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Load options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async loadData(path, payload = {}, options = {}) {
    const {
      container = null,
      onSuccess = null,
      onError = null,
      showLoading = true,
      retry = true,
      context = 'load data'
    } = options;

    const StateRenderer = window.SharedUtils?.StateRenderer;

    // Show loading state
    if (showLoading && container && StateRenderer) {
      StateRenderer.showLoading(container, { message: 'Loading...' });
    }

    const res = await NU.resilientRpc(path, payload, {
      retry,
      showToast: false,
      context
    });

    if (res.ok) {
      if (onSuccess) onSuccess(res.value);
    } else {
      // Show error state in container
      if (container && StateRenderer) {
        StateRenderer.showFromError(container, res, {
          onRetry: () => NU.loadData(path, payload, options)
        });
      }
      if (onError) onError(res);
    }

    return res;
  },

  /**
   * Submit data with user feedback (for forms, saves, etc.)
   * Shows appropriate toast/dialog feedback
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Submit options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async submitData(path, payload = {}, options = {}) {
    const {
      successMessage = 'Saved successfully!',
      errorMessage = 'Unable to save. Please try again.',
      onSuccess = null,
      onError = null,
      button = null,
      context = 'save'
    } = options;

    const showToast = window.SharedUtils?.showToast;

    // Disable button during submit
    if (button) {
      button.disabled = true;
      button.dataset.originalText = button.textContent;
      button.textContent = 'Saving...';
    }

    try {
      const res = await NU.resilientRpc(path, payload, {
        retry: true,
        showToast: false,
        context
      });

      if (res.ok) {
        if (showToast) showToast(successMessage, 'success');
        if (onSuccess) onSuccess(res.value);
      } else {
        if (showToast) showToast(errorMessage, 'error');
        if (onError) onError(res);
      }

      return res;

    } finally {
      // Re-enable button
      if (button) {
        button.disabled = false;
        button.textContent = button.dataset.originalText || 'Save';
      }
    }
  }
};

// =============================================================================
// NU_DIAG - Diagnostic Helper for Test.html
// =============================================================================
window.NU_DIAG = {
  /**
   * Get all logs from the rolling buffer
   *
   * @param {object} options - { type?, level?, limit? }
   * @returns {Array} Filtered log entries
   */
  getLogs(options = {}) {
    const { type, level, limit = 100 } = options;
    let logs = [...window.__NU_LOGS__];

    if (type) {
      logs = logs.filter(l => l.type === type);
    }
    if (level) {
      logs = logs.filter(l => l.level === level);
    }

    return logs.slice(-limit);
  },

  /**
   * Clear all logs from the buffer
   */
  clearLogs() {
    window.__NU_LOGS__.length = 0;
    console.debug('[NU_DIAG] Logs cleared');
  },

  /**
   * Get statistics about logged requests
   *
   * @returns {object} Statistics object
   */
  getStats() {
    const logs = window.__NU_LOGS__;
    const stats = {
      totalLogs: logs.length,
      byType: {},
      byLevel: {},
      errors: [],
      avgDurationMs: 0
    };

    let totalDuration = 0;
    let durationCount = 0;

    logs.forEach(log => {
      // Count by type
      stats.byType[log.type] = (stats.byType[log.type] || 0) + 1;

      // Count by level
      stats.byLevel[log.level] = (stats.byLevel[log.level] || 0) + 1;

      // Track errors
      if (log.level === 'error') {
        stats.errors.push({
          timestamp: log.timestamp,
          type: log.type,
          path: log.path,
          code: log.code,
          error: log.error
        });
      }

      // Track durations
      if (log.durationMs) {
        totalDuration += log.durationMs;
        durationCount++;
      }
    });

    stats.avgDurationMs = durationCount > 0
      ? Math.round(totalDuration / durationCount)
      : 0;

    return stats;
  },

  /**
   * Test an RPC call and return detailed diagnostics
   *
   * @param {string} path - API path to test
   * @param {object} payload - Request payload
   * @returns {Promise<object>} Test result with timing and diagnostics
   */
  async testRpc(path, payload = {}) {
    const startTime = Date.now();
    const logsBefore = window.__NU_LOGS__.length;

    console.group(`[NU_DIAG] Testing RPC: ${path}`);
    console.debug('Payload:', payload);

    try {
      const result = await NU.rpc(path, payload);
      const endTime = Date.now();
      const newLogs = window.__NU_LOGS__.slice(logsBefore);

      const diagnostic = {
        success: result.ok,
        path,
        payload,
        result,
        durationMs: endTime - startTime,
        logs: newLogs,
        timestamp: new Date().toISOString()
      };

      console.debug('Result:', result);
      console.debug('Duration:', diagnostic.durationMs, 'ms');
      console.debug('Logs generated:', newLogs.length);
      console.groupEnd();

      return diagnostic;

    } catch (error) {
      const endTime = Date.now();
      const newLogs = window.__NU_LOGS__.slice(logsBefore);

      const diagnostic = {
        success: false,
        path,
        payload,
        error: error.message,
        durationMs: endTime - startTime,
        logs: newLogs,
        timestamp: new Date().toISOString()
      };

      console.error('Error:', error);
      console.groupEnd();

      return diagnostic;
    }
  },

  /**
   * Run a quick health check
   *
   * @returns {Promise<object>} Health check results
   */
  async healthCheck() {
    console.group('[NU_DIAG] Health Check');

    const health = {
      sdk: {
        version: NU.VERSION,
        config: NU.getConfig(),
        pendingRequests: NU._pending.length
      },
      logs: {
        count: window.__NU_LOGS__.length,
        maxSize: NU._config.maxLogs
      },
      environment: {
        hostname: window.location?.hostname,
        protocol: window.location?.protocol,
        hasGoogleScript: !!window.google?.script?.run
      },
      timestamp: new Date().toISOString()
    };

    // Test connectivity with a simple ping
    try {
      const pingStart = Date.now();
      const pingResult = await NU.rpc('status', {});
      health.connectivity = {
        ok: pingResult.ok,
        durationMs: Date.now() - pingStart,
        response: pingResult.ok ? 'connected' : pingResult.code
      };
    } catch (e) {
      health.connectivity = {
        ok: false,
        error: e.message
      };
    }

    console.debug('Health:', health);
    console.groupEnd();

    return health;
  },

  /**
   * Export logs as JSON for debugging
   *
   * @returns {string} JSON string of all logs
   */
  exportLogs() {
    const exportData = {
      sdk: {
        version: NU.VERSION,
        config: NU.getConfig()
      },
      stats: NU_DIAG.getStats(),
      logs: window.__NU_LOGS__,
      exportedAt: new Date().toISOString()
    };

    return JSON.stringify(exportData, null, 2);
  },

  /**
   * Print a summary to console
   */
  printSummary() {
    const stats = NU_DIAG.getStats();
    console.group('[NU_DIAG] Summary');
    console.log('SDK Version:', NU.VERSION);
    console.log('Log Level:', NU._config.logLevel);
    console.log('Total Logs:', stats.totalLogs);
    console.log('By Type:', stats.byType);
    console.log('By Level:', stats.byLevel);
    console.log('Avg Duration:', stats.avgDurationMs, 'ms');
    if (stats.errors.length > 0) {
      console.warn('Recent Errors:', stats.errors.slice(-5));
    }
    console.groupEnd();
  }
};

// =============================================================================
// Auto-initialize SDK
// =============================================================================
NU._init();
</script>
