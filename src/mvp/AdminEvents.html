<!--
================================================================================
MODULE: AdminEvents.html
PURPOSE: Event selector, event card display, and checklist for Admin dashboard
INCLUDED BY: Admin.html
DEPENDENCIES: NUSDK.html (NU.rpc, NU.esc), SharedUtils.html (showToast)
================================================================================
Story 4.1: Extracted from Admin.html for modularization and maintainability.
Story 2.3: Migrated from GAS to Worker endpoints for all read operations.
Story 3.2: Added createEventViaWorker() for creating events via Worker.
Story 5.3: All endpoints migrated to v2 API (/api/v2/*). GAS retired.

Functions exposed to global scope:
  Event Selector:
  - loadExistingEvents()         → Load events into dropdown (Worker)
  - onEventDropdownChange()      → Handle dropdown selection
  - loadSelectedEvent(eventId)   → Load and display specific event (Worker)
  - refreshEventList()           → Refresh the event list
  - selectEventInDropdown(id)    → Select event in dropdown

  Worker Fetch Functions (Story 5.3: v2 API):
  - fetchEventsListFromWorker()    → GET /api/v2/events
  - fetchAdminBundleFromWorker()   → GET /api/v2/events/:id/bundle/admin
  - createEventViaWorker()         → POST /api/v2/events

  Auth Helpers (Story 3.1):
  - getAdminToken()              → Get admin token from window or localStorage
  - buildAdminHeaders()          → Build headers with Authorization if token available

  Event Card:
  - showEventCard(event)         → Display event in dashboard
  - showWizard()                 → Show create wizard
  - hideWizard()                 → Hide wizard
  - clearForm()                  → Reset form for new event

  Helpers:
  - generateId()                 → Generate UUID v4
  - slugify(text)                → Convert text to slug
  - computeLifecyclePhase(date)  → Compute event lifecycle phase
  - overlay(on)                  → Show/hide loading overlay
  - copy(id)                     → Copy link to clipboard
  - copyUrl(url)                 → Copy URL to clipboard

  Checklist:
  - scrollToCard(cardId)         → Scroll to card section
  - updateChecklistStatus(event) → Update checklist from event data
================================================================================
-->
<script>
(function() {
  'use strict';

  // Module state - exposed to global scope
  window.loadedEvents = [];
  window.currentEventId = null;
  window.currentEventData = null;

  // STATE object for edit mode - preserves id, slug, createdAtISO
  window.STATE = {
    id: null,
    slug: null,
    createdAtISO: null
  };

  // ==========================================================================
  // WORKER ENDPOINT FUNCTIONS (Story 2.3)
  // ==========================================================================

  /**
   * Get Worker base URL for API calls
   * Uses current origin for same-domain Worker deployment
   */
  function getWorkerBaseUrl() {
    return window.location.origin;
  }

  /**
   * Get admin auth token for API requests.
   * Story 3.1: Admin endpoints now require Bearer token authentication.
   *
   * Token can be set via:
   * - window.ADMIN_TOKEN (injected by GAS templating)
   * - localStorage.getItem('adminToken') (for SPA flows)
   *
   * @returns {string|null} Admin token or null if not available
   */
  function getAdminToken() {
    // Priority 1: Window variable (GAS templating)
    if (window.ADMIN_TOKEN) {
      return window.ADMIN_TOKEN;
    }
    // Priority 2: localStorage (SPA/persistent session)
    const stored = localStorage.getItem('adminToken');
    if (stored) {
      return stored;
    }
    return null;
  }

  /**
   * Build headers for admin API requests.
   * Story 3.1: Include Authorization header if token is available.
   *
   * @param {object} additionalHeaders - Additional headers to include
   * @returns {object} Headers object with auth if available
   */
  function buildAdminHeaders(additionalHeaders = {}) {
    const headers = {
      'Accept': 'application/json',
      ...additionalHeaders
    };

    const token = getAdminToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    return headers;
  }

  /**
   * Fetch events list from Worker endpoint
   * GET /api/v2/events?brand=:brand
   *
   * Story 2.3: Replaces GAS api_getEventsSafe
   * Story 3.1: Now includes Authorization header for admin auth
   * Story 5.3: Uses v2 API (GAS retired)
   *
   * @param {string} brandId - Brand identifier
   * @returns {Promise<{ok: boolean, items?: object[], code?: string, message?: string}>}
   */
  async function fetchEventsListFromWorker(brandId) {
    const baseUrl = getWorkerBaseUrl();
    const endpoint = `${baseUrl}/api/v2/events`;
    const url = new URL(endpoint);
    url.searchParams.set('brand', brandId);

    try {
      const response = await fetch(url.toString(), {
        method: 'GET',
        headers: buildAdminHeaders(),
        credentials: 'same-origin'
      });

      // Handle auth errors
      if (response.status === 401) {
        console.warn('[AdminEvents] Authentication required for events list');
        return {
          ok: false,
          code: 'UNAUTHORIZED',
          message: 'Authentication required. Please reload the page or contact admin.'
        };
      }

      const data = await response.json();

      // Normalize response shape for compatibility
      // Worker returns { ok, items } but old code expects { ok, value: { items } }
      if (data.ok && data.items) {
        return {
          ok: true,
          value: { items: data.items }
        };
      }

      return data;

    } catch (error) {
      console.error('[AdminEvents] Worker fetch failed:', error);
      return {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Unable to connect to server. Please check your connection.'
      };
    }
  }

  /**
   * Fetch admin bundle from Worker endpoint
   * GET /api/v2/events/:id/bundle/admin?brand=:brand
   *
   * Story 2.3: Replaces GAS api_get for admin context
   * Story 3.1: Now includes Authorization header for admin auth
   * Story 5.3: Uses v2 API (GAS retired)
   *
   * @param {string} eventId - Event ID or slug
   * @param {string} brandId - Brand identifier
   * @param {object} options - { ifNoneMatch?: string } for conditional requests
   * @returns {Promise<{ok: boolean, value?: object, code?: string, message?: string}>} Story 3.1: Auth header included
   */
  async function fetchAdminBundleFromWorker(eventId, brandId, options = {}) {
    const baseUrl = getWorkerBaseUrl();
    const endpoint = `${baseUrl}/api/v2/events/${encodeURIComponent(eventId)}/bundle/admin`;
    const url = new URL(endpoint);
    url.searchParams.set('brand', brandId);

    // Build headers with auth and optional conditional request headers
    const additionalHeaders = {};
    if (options.ifNoneMatch) {
      additionalHeaders['If-None-Match'] = options.ifNoneMatch;
    }
    const headers = buildAdminHeaders(additionalHeaders);

    try {
      const response = await fetch(url.toString(), {
        method: 'GET',
        headers,
        credentials: 'same-origin'
      });

      // Handle 304 Not Modified
      if (response.status === 304) {
        return {
          ok: true,
          notModified: true,
          etag: response.headers.get('ETag')
        };
      }

      // Handle auth errors
      if (response.status === 401) {
        console.warn('[AdminEvents] Authentication required for admin bundle');
        return {
          ok: false,
          code: 'UNAUTHORIZED',
          message: 'Authentication required. Please reload the page or contact admin.'
        };
      }

      // Parse JSON response
      const data = await response.json();

      // Pass through response (Worker returns standard envelope)
      return data;

    } catch (error) {
      console.error('[AdminEvents] Worker fetch failed:', error);
      return {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Unable to connect to server. Please check your connection.'
      };
    }
  }

  /**
   * Create a new event via Worker endpoint
   * POST /api/v2/events
   *
   * Story 3.2: Replaces GAS api_saveEvent (create mode)
   * Story 5.3: Uses v2 API (GAS retired)
   *
   * @param {object} eventData - Event data to create
   * @param {string} eventData.name - Event name (required)
   * @param {string} eventData.startDateISO - Start date YYYY-MM-DD (required)
   * @param {string} eventData.venue - Event venue (required)
   * @param {string} [eventData.brandId] - Brand ID (optional, uses window.BRAND)
   * @param {string} [eventData.templateId] - Template ID (optional)
   * @param {string} [eventData.signupUrl] - Signup URL (optional)
   * @returns {Promise<{ok: boolean, value?: object, code?: string, message?: string}>}
   */
  async function createEventViaWorker(eventData) {
    const baseUrl = getWorkerBaseUrl();
    const endpoint = `${baseUrl}/api/v2/events`;

    // Build request body
    const body = {
      name: eventData.name,
      startDateISO: eventData.startDateISO,
      venue: eventData.venue,
      brandId: eventData.brandId || window.BRAND || 'root',
      templateId: eventData.templateId,
      signupUrl: eventData.signupUrl || eventData.ctas?.primary?.url || ''
    };

    try {
      console.log('[AdminEvents] Creating event via Worker:', body.name);

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: buildAdminHeaders({
          'Content-Type': 'application/json'
        }),
        credentials: 'same-origin',
        body: JSON.stringify(body)
      });

      // Handle auth errors
      if (response.status === 401) {
        console.warn('[AdminEvents] Authentication required for createEvent');
        return {
          ok: false,
          code: 'UNAUTHORIZED',
          message: 'Authentication required. Please reload the page or contact admin.'
        };
      }

      // Parse JSON response
      const data = await response.json();

      // Normalize response shape for compatibility with existing code
      // Worker returns { ok, status, item, message }
      // Existing code expects { ok, value: {...event data} }
      if (data.ok && data.item) {
        console.log('[AdminEvents] Event created via Worker:', data.item.id);
        return {
          ok: true,
          value: data.item,
          message: data.message
        };
      }

      // Pass through error responses
      return data;

    } catch (error) {
      console.error('[AdminEvents] Worker createEvent failed:', error);
      return {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Unable to connect to server. Please check your connection.'
      };
    }
  }

  // Expose Worker functions to global scope
  window.fetchEventsListFromWorker = fetchEventsListFromWorker;
  window.fetchAdminBundleFromWorker = fetchAdminBundleFromWorker;
  window.createEventViaWorker = createEventViaWorker;

  // Story 3.1: Expose auth helpers for other modules that need to make authenticated requests
  window.getAdminToken = getAdminToken;
  window.buildAdminHeaders = buildAdminHeaders;

  // ==========================================================================
  // HELPER FUNCTIONS
  // ==========================================================================

  /**
   * Generate UUID v4-like ID.
   */
  function generateId() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = (crypto.getRandomValues(new Uint8Array(1))[0] & 15) >> (c === 'x' ? 0 : 3);
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }

  /**
   * Convert text to URL-friendly slug.
   */
  function slugify(text) {
    return text.toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .substring(0, 50);
  }

  /**
   * Compute lifecycle phase from startDateISO.
   * Mirrors backend computeLifecyclePhase_() for parity across surfaces.
   * Same labels used by Admin, Public, Display, Poster, SharedReport.
   *
   * @param {string} startDateISO - Event start date in ISO format (YYYY-MM-DD)
   * @returns {Object} { phase: string, label: string, isLive: boolean }
   */
  function computeLifecyclePhase(startDateISO) {
    const LIFECYCLE_LABELS = {
      'pre-event': 'Pre-Event Preparation',
      'event-day': 'Event Day - Live',
      'post-event': 'Post-Event Analytics'
    };

    if (!startDateISO) {
      return { phase: 'pre-event', label: LIFECYCLE_LABELS['pre-event'], isLive: false };
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const eventDate = new Date(startDateISO);
    eventDate.setHours(0, 0, 0, 0);

    let phase = 'pre-event';
    if (eventDate.getTime() === today.getTime()) {
      phase = 'event-day';
    } else if (eventDate < today) {
      phase = 'post-event';
    }

    return {
      phase: phase,
      label: LIFECYCLE_LABELS[phase],
      isLive: phase === 'event-day'
    };
  }

  /**
   * Show/hide loading overlay.
   */
  function overlay(on) {
    const el = document.getElementById('overlay');
    if (el) {
      el.style.display = on ? 'flex' : 'none';
    }
  }

  // ==========================================================================
  // EVENT SELECTOR
  // ==========================================================================

  /**
   * Load existing events into the dropdown.
   * Called on page init and after event creation.
   *
   * Story 2.3/5.3: Uses Worker /api/v2/events endpoint (GAS retired)
   */
  async function loadExistingEvents() {
    const dropdown = document.getElementById('eventDropdown');
    if (!dropdown) return;

    const BRAND = window.BRAND || 'root';

    try {
      console.log('[EventSelector] Loading events from Worker for brand:', BRAND);

      // Story 2.3: Use Worker endpoint instead of GAS
      const res = await fetchEventsListFromWorker(BRAND);

      if (!res.ok) {
        console.warn('[EventSelector] Failed to load events:', res.message || res.error);
        return;
      }

      window.loadedEvents = res.value?.items || [];
      console.log('[EventSelector] Loaded', window.loadedEvents.length, 'events from Worker');

      // Clear existing options (keep placeholder and create option)
      while (dropdown.options.length > 2) {
        dropdown.remove(2);
      }

      // Sort by date descending (newest first)
      window.loadedEvents.sort((a, b) => {
        const dateA = a.startDateISO || '';
        const dateB = b.startDateISO || '';
        return dateB.localeCompare(dateA);
      });

      // Add events to dropdown
      window.loadedEvents.forEach(event => {
        const option = document.createElement('option');
        option.value = event.id;
        const dateStr = event.startDateISO || 'No date';
        option.textContent = `${event.name || 'Unnamed'} (${dateStr})`;
        dropdown.appendChild(option);
      });

    } catch (err) {
      console.error('[EventSelector] Error loading events:', err);
      if (window.SharedUtils) {
        SharedUtils.showToast('Could not load events', 'error');
      }
    }
  }

  /**
   * Handle dropdown selection change.
   */
  async function onEventDropdownChange() {
    const dropdown = document.getElementById('eventDropdown');
    const value = dropdown.value;

    if (value === '__create__') {
      showWizard();
      return;
    }

    if (!value) {
      showWizard();
      return;
    }

    await loadSelectedEvent(value);
  }

  /**
   * Load a specific event by ID and show in the dashboard.
   *
   * Story 2.3/5.3: Uses Worker /api/v2/events/:id/bundle/admin endpoint (GAS retired).
   * The admin bundle includes full event data plus admin-specific fields
   * (brandConfig, templates, diagnostics).
   */
  async function loadSelectedEvent(eventId) {
    if (!eventId) return;

    const BRAND = window.BRAND || 'root';

    try {
      overlay(true);
      console.log('[EventSelector] Loading event from Worker:', eventId);

      // Story 2.3: Use Worker adminBundle endpoint instead of GAS
      const res = await fetchAdminBundleFromWorker(eventId, BRAND);

      if (!res.ok) {
        if (window.SharedUtils) {
          SharedUtils.showToast('Failed to load event: ' + (res.message || 'Unknown error'), 'error');
        }
        overlay(false);
        return;
      }

      // Admin bundle returns { event, brandConfig, templates, diagnostics, allSponsors, lifecyclePhase }
      const bundle = res.value;
      const event = bundle.event;
      console.log('[EventSelector] Loaded event from Worker:', event.name);

      // Store templates and diagnostics for use by other modules
      window.currentAdminBundle = bundle;
      if (bundle.templates) {
        window.availableTemplates = bundle.templates;
      }
      if (bundle.brandConfig) {
        window.currentBrandConfig = bundle.brandConfig;
      }

      // Set current event ID
      window.currentEventId = event.id;
      window.STATE.id = event.id;
      window.STATE.slug = event.slug;
      window.STATE.createdAtISO = event.createdAtISO;

      // Hide wizard, show event card
      hideWizard();

      // Update quick links
      updateQuickLinks(event);

      // Show the event card
      showEventCard(event);

      overlay(false);

    } catch (err) {
      console.error('[EventSelector] Error loading event:', err);
      if (window.SharedUtils) {
        SharedUtils.showToast('Error loading event', 'error');
      }
      overlay(false);
    }
  }

  /**
   * Update quick links with event URLs.
   */
  function updateQuickLinks(event) {
    const quickLinksContainer = document.getElementById('eventQuickLinks');
    const publicLink = document.getElementById('quickLinkPublic');
    const displayLink = document.getElementById('quickLinkDisplay');

    if (event && event.links) {
      if (publicLink) publicLink.href = event.links.publicUrl || '#';
      if (displayLink) displayLink.href = event.links.displayUrl || '#';
      if (quickLinksContainer) quickLinksContainer.style.display = 'flex';
    } else {
      if (quickLinksContainer) quickLinksContainer.style.display = 'none';
    }
  }

  /**
   * Show the create wizard and hide event card.
   */
  function showWizard() {
    const wizard = document.getElementById('launchWizard');
    const eventCard = document.getElementById('eventCard');
    const quickLinks = document.getElementById('eventQuickLinks');

    if (wizard) wizard.style.display = 'block';
    if (eventCard) eventCard.style.display = 'none';
    if (quickLinks) quickLinks.style.display = 'none';

    // Reset dropdown to placeholder
    const dropdown = document.getElementById('eventDropdown');
    if (dropdown) dropdown.value = '__create__';
  }

  /**
   * Hide the wizard (when viewing an existing event).
   */
  function hideWizard() {
    const wizard = document.getElementById('launchWizard');
    if (wizard) wizard.style.display = 'none';
  }

  /**
   * Refresh the event list.
   */
  async function refreshEventList() {
    await loadExistingEvents();
    if (window.SharedUtils) {
      SharedUtils.showToast('Event list refreshed', 'info');
    }
  }

  /**
   * Select an event in the dropdown by ID.
   * Used after creating a new event to auto-select it.
   */
  function selectEventInDropdown(eventId) {
    const dropdown = document.getElementById('eventDropdown');
    if (dropdown) {
      dropdown.value = eventId;
    }
  }

  // ==========================================================================
  // EVENT CARD DISPLAY
  // ==========================================================================

  /**
   * Show event card with canonical event data.
   * SCHEMA: /schemas/event.schema.json
   * Simplified UX: Clean summary + output cards
   */
  function showEventCard(event) {
    // Update STATE for edit mode - preserve id, slug, createdAtISO
    window.STATE.id = event.id || null;
    window.STATE.slug = event.slug || null;
    window.STATE.createdAtISO = event.createdAtISO || null;

    // Also sync legacy currentEventId
    window.currentEventId = event.id || null;

    // Schema: event.links at top level
    const links = event.links || {};

    // Set links for the output cards
    setLink('lnkPublic', links.publicUrl);
    setLink('lnkDisplay', links.displayUrl);
    setLink('lnkPoster', links.posterUrl);
    // Set report link (uses sharedReportUrl or falls back to constructing it)
    const reportUrl = links.sharedReportUrl || (links.publicUrl ? links.publicUrl.replace('page=public', 'page=report') : '');
    setLink('lnkReport', reportUrl);

    // Show the event card, hide the Quick Start Guide and create form
    const eventCard = document.getElementById('eventCard');
    const quickStartGuide = document.getElementById('quickStartGuide');
    const createCard = document.getElementById('createCard');

    if (eventCard) eventCard.style.display = '';
    if (quickStartGuide) quickStartGuide.style.display = 'none';
    if (createCard) createCard.style.display = 'none';

    // Format date for display
    const dateStr = event.startDateISO || '';
    const eventDate = new Date(dateStr + 'T00:00:00');
    let dateDisplay = dateStr;
    if (dateStr && !isNaN(eventDate.getTime())) {
      dateDisplay = eventDate.toLocaleDateString('en-US', {
        weekday: 'short', month: 'short', day: 'numeric', year: 'numeric'
      });
    }

    // Compute lifecycle phase for consistent display across surfaces
    const lifecycle = computeLifecyclePhase(event.startDateISO);

    // Clean, simple event summary with lifecycle phase indicator
    const info = `
      <p style="font-size: 1.1rem; color: var(--color-gray-700, #334155); margin: 0 0 8px 0;">
        <strong>${NU.esc(event.name || 'Your Event')}</strong>
        <span style="color: var(--color-gray-400, #94a3b8); margin: 0 8px;">|</span>
        ${NU.esc(dateDisplay)}
        <span style="color: var(--color-gray-400, #94a3b8); margin: 0 8px;">|</span>
        ${NU.esc(event.venue || '')}
      </p>
      <div style="margin-top: 8px;">
        <span class="phase-indicator ${lifecycle.phase}" data-testid="lifecycle-indicator" data-phase="${lifecycle.phase}">
          ${NU.esc(lifecycle.label)}
        </span>
      </div>
    `;

    const eventInfo = document.getElementById('eventInfo');
    if (eventInfo) {
      eventInfo.innerHTML = info;
    }

    // Display event ID in diagnostics section
    const eventIdDisplay = document.getElementById('eventIdDisplay');
    if (eventIdDisplay) {
      eventIdDisplay.textContent = event.id || 'N/A';
    }

    // Render QR previews if functions exist
    if (typeof window.renderPublicQRPreview === 'function') {
      window.renderPublicQRPreview(links.publicUrl);
    }
    if (typeof window.renderPosterQRPreview === 'function') {
      window.renderPosterQRPreview(links.posterUrl);
    }

    // Feature 2: Render SharedReport QR Code
    const BRAND_FEATURES = window.BRAND_FEATURES || {};
    if (BRAND_FEATURES.sharedReportEnabled !== false && typeof window.renderSharedReportQR === 'function') {
      window.renderSharedReportQR(event);
    }

    // Feature 1: Render Sponsor Performance Links
    if (typeof window.renderSponsorReports === 'function') {
      window.renderSponsorReports(event);
    }

    // Update Happy Path checklist status based on event data
    updateChecklistStatus(event);

    // Scroll to the checklist at the top
    const checklist = document.getElementById('happyPathChecklist');
    if (checklist) {
      checklist.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  /**
   * Set link text and href.
   */
  function setLink(id, url) {
    const a = document.getElementById(id);
    if (!a) return;
    a.textContent = url || '';
    a.href = url || '#';
  }

  /**
   * Copy link by element ID.
   */
  async function copy(id) {
    const el = document.getElementById(id);
    if (!el) return;
    const url = el.textContent;
    await navigator.clipboard.writeText(url);
    if (window.SharedUtils) {
      SharedUtils.showToast('Link copied!', 'success');
    }
  }

  /**
   * Copy URL directly.
   */
  async function copyUrl(url) {
    try {
      await navigator.clipboard.writeText(url);
      if (window.SharedUtils) {
        SharedUtils.showToast('Link copied!', 'success');
      }
    } catch (e) {
      // Fallback for older browsers
      const ta = document.createElement('textarea');
      ta.value = url;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      if (window.SharedUtils) {
        SharedUtils.showToast('Link copied!', 'success');
      }
    }
  }

  /**
   * Clear form and reset for new event creation.
   */
  function clearForm() {
    const createForm = document.getElementById('createForm');
    if (createForm) createForm.reset();

    // Hide cards
    ['dashboardCard', 'eventCard', 'signupCard', 'displayCard', 'formsCard'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });

    // Clear STATE for new event creation
    window.STATE.id = null;
    window.STATE.slug = null;
    window.STATE.createdAtISO = null;
    window.currentEventId = null;

    // Reset to default template
    if (typeof window.selectTemplate === 'function' && window.defaultTemplateId) {
      window.selectTemplate(window.defaultTemplateId);
    }

    // Show the create card
    const createCard = document.getElementById('createCard');
    if (createCard) createCard.style.display = '';
  }

  // ==========================================================================
  // HAPPY PATH CHECKLIST
  // ==========================================================================

  /**
   * Scroll to a specific card section.
   */
  function scrollToCard(cardId) {
    const card = document.getElementById(cardId);
    if (!card) return;

    // If it's a collapsed mobile card, expand it first
    if (card.classList.contains('mobile-collapsed') && typeof window.toggleMobileCard === 'function') {
      window.toggleMobileCard(card);
    }

    // Smooth scroll to the card with offset for fixed header
    const headerOffset = 20;
    const elementPosition = card.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth'
    });

    // Brief highlight effect
    card.style.transition = 'box-shadow 0.3s ease';
    card.style.boxShadow = '0 0 0 3px rgba(37, 99, 235, 0.3)';
    setTimeout(() => {
      card.style.boxShadow = '';
    }, 1500);
  }

  /**
   * Update a single checklist item's visual state.
   */
  function setChecklistItemStatus(itemId, status, isOptional = false) {
    const item = document.getElementById(itemId);
    if (!item) return;

    const indicator = item.querySelector('.check-indicator');
    if (!indicator) return;

    // Remove all state classes
    item.classList.remove('done', 'optional-pending');
    indicator.classList.remove('done', 'pending', 'optional');

    if (status === 'done') {
      item.classList.add('done');
      indicator.classList.add('done');
      indicator.textContent = '✓';
    } else if (isOptional) {
      item.classList.add('optional-pending');
      indicator.classList.add('optional');
      indicator.textContent = '~';
    } else {
      indicator.classList.add('pending');
      indicator.textContent = '';
    }
  }

  /**
   * Update all checklist items based on event data.
   * Time estimates: event=2min, signup=2min, poster=1min, display=1min, public=2min
   */
  function updateChecklistStatus(event) {
    window.currentEventData = event;
    const links = event.links || {};
    const ctas = event.ctas || {};
    const sponsors = event.sponsors || [];

    // Track completed count and remaining time
    let completed = 0;
    let remainingMinutes = 0;
    const total = 6;

    // Time estimates per task (minutes)
    const timeEstimates = {
      event: 2,
      signup: 2,
      poster: 1,
      display: 1,
      public: 2
    };

    // 1. Event name & date - always done if we're showing the event card
    setChecklistItemStatus('checklist-event', 'done');
    completed++;

    // 2. Signup form - done if signupUrl is configured
    const hasFormUrl = links.signupUrl || ctas.primary?.url;
    if (hasFormUrl) {
      setChecklistItemStatus('checklist-signup', 'done');
      completed++;
    } else {
      setChecklistItemStatus('checklist-signup', 'pending');
      remainingMinutes += timeEstimates.signup;
    }

    // 3. Poster - done if posterUrl exists
    if (links.posterUrl) {
      setChecklistItemStatus('checklist-poster', 'done');
      completed++;
    } else {
      setChecklistItemStatus('checklist-poster', 'pending');
      remainingMinutes += timeEstimates.poster;
    }

    // 4. TV Display - done if displayUrl exists
    if (links.displayUrl) {
      setChecklistItemStatus('checklist-display', 'done');
      completed++;
    } else {
      setChecklistItemStatus('checklist-display', 'pending');
      remainingMinutes += timeEstimates.display;
    }

    // 5. Public link - done if publicUrl exists
    if (links.publicUrl) {
      setChecklistItemStatus('checklist-public', 'done');
      completed++;
    } else {
      setChecklistItemStatus('checklist-public', 'pending');
      remainingMinutes += timeEstimates.public;
    }

    // 6. Sponsors - optional, done if sponsors array has items
    if (sponsors.length > 0) {
      setChecklistItemStatus('checklist-sponsors', 'done');
      completed++;
    } else {
      setChecklistItemStatus('checklist-sponsors', 'pending', true);
    }

    // Update progress text
    const progressEl = document.getElementById('checklistProgress');
    if (progressEl) {
      progressEl.textContent = `${completed} of ${total} done`;
    }

    // Update header with remaining time
    const headerH3 = document.querySelector('#happyPathChecklist .happy-path-header h3');
    if (headerH3) {
      if (completed >= 5) {
        headerH3.textContent = 'All Set!';
      } else if (remainingMinutes > 0) {
        headerH3.textContent = `Finish Setup (~${remainingMinutes} min left)`;
      } else {
        headerH3.textContent = 'Get Your Event Ready';
      }
    }
  }

  // ==========================================================================
  // EXPOSE FUNCTIONS TO GLOBAL SCOPE
  // ==========================================================================

  // Helpers
  window.generateId = generateId;
  window.slugify = slugify;
  window.computeLifecyclePhase = computeLifecyclePhase;
  window.overlay = overlay;

  // Event selector
  window.loadExistingEvents = loadExistingEvents;
  window.onEventDropdownChange = onEventDropdownChange;
  window.loadSelectedEvent = loadSelectedEvent;
  window.refreshEventList = refreshEventList;
  window.selectEventInDropdown = selectEventInDropdown;

  // Event card
  window.showEventCard = showEventCard;
  window.showWizard = showWizard;
  window.hideWizard = hideWizard;
  window.clearForm = clearForm;
  window.setLink = setLink;
  window.copy = copy;
  window.copyUrl = copyUrl;
  window.updateQuickLinks = updateQuickLinks;

  // Checklist
  window.scrollToCard = scrollToCard;
  window.setChecklistItemStatus = setChecklistItemStatus;
  window.updateChecklistStatus = updateChecklistStatus;

})();
</script>
