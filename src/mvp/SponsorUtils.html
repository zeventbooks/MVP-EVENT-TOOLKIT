<script>
/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SponsorUtils - Shared utilities for sponsor rendering across surfaces
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * RESPONSIBILITY: This file handles sponsor rendering and analytics ONLY.
 * It does NOT create/modify sponsors - that's Code.gs territory.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * [MVP] SPONSOR CONTRACT - /schemas/sponsor.schema.json
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * CANONICAL SPONSOR SHAPE (all fields per schema):
 * {
 *   id: string,              // MVP REQUIRED - Unique sponsor identifier
 *   name: string,            // MVP REQUIRED - Display name (1-200 chars)
 *   logoUrl: string,         // MVP REQUIRED - URL to logo image (https://...)
 *   linkUrl?: string|null,   // MVP OPTIONAL - Click-through URL
 *   placement: string        // MVP REQUIRED - "poster"|"display"|"public"|"tv-banner"
 * }
 *
 * This utility normalizes legacy formats (img, url, placements) to the canonical shape.
 * All surfaces MUST use normalizeSponsor() before rendering.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * WINDOW ADDITION: window.SponsorUtils
 *
 * Used by: Display.html, Public.html, Poster.html
 * ═══════════════════════════════════════════════════════════════════════════════
 */
window.SponsorUtils = (function() {
  'use strict';

  // === XSS Prevention ===
  function esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[m]));
  }

  // === Session ID for analytics attribution ===
  // Ties all events from same page visit together
  let sessionId = null;

  // Generate UUID using crypto API (secure)
  function generateSecureUUID() {
    // Prefer native crypto.randomUUID if available (modern browsers)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback: use crypto.getRandomValues (secure, wider support)
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      const bytes = new Uint8Array(16);
      crypto.getRandomValues(bytes);
      // Set version (4) and variant (RFC4122)
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
      const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
      return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
    }
    // Last resort fallback (very old browsers) - use timestamp + counter for uniqueness
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c, i) => {
      const r = (Date.now() + i) % 16;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }

  function getSessionId() {
    if (sessionId) return sessionId;
    // Check sessionStorage first (persists across page reloads in same tab)
    try {
      sessionId = sessionStorage.getItem('zeb_session_id');
      if (!sessionId) {
        sessionId = generateSecureUUID();
        sessionStorage.setItem('zeb_session_id', sessionId);
      }
    } catch (_) {
      // sessionStorage not available, use in-memory only
      sessionId = generateSecureUUID();
    }
    return sessionId;
  }

  // === Analytics Logging ===
  const BATCH_SIZE = 5;
  const FLUSH_INTERVAL = 5000;
  let logBatch = [];
  let flushTimer = null;

  function logEvent(evt) {
    try {
      evt.ua = navigator.userAgent;
      evt.ts = Date.now();
      evt.sessionId = getSessionId();  // Always include sessionId
      logBatch.push(evt);
      if (logBatch.length >= BATCH_SIZE) flush();
    } catch (_) {}
  }

  function flush() {
    if (!logBatch.length) return;
    const copy = logBatch.splice(0, logBatch.length);
    // Use NU.safeLogEvents for fetch-based RPC (works through Cloudflare proxy)
    // Falls back to google.script.run internally if fetch fails
    if (window.NU?.safeLogEvents) {
      NU.safeLogEvents(copy);
    } else if (window.google?.script?.run) {
      // Legacy fallback for pages without NUSDK
      google.script.run.withFailureHandler(() => {}).api_logEvents({ items: copy });
    }
  }

  function initLogging() {
    if (flushTimer) clearInterval(flushTimer);
    flushTimer = setInterval(flush, FLUSH_INTERVAL);
    window.addEventListener('beforeunload', flush);
    getSessionId(); // Initialize sessionId early
  }

  // === Sponsor Filtering ===
  function filterByPlacement(sponsors, placement) {
    return (sponsors || []).filter(s => s?.placements?.[placement]);
  }

  // === Generic Sponsor Renderer ===
  /**
   * Renders sponsors to a container element
   * @param {Object} options
   * @param {Array} options.sponsors - Array of sponsor objects
   * @param {string} options.placement - Placement key (tvTop, tvSide, mobileBanner, posterTop)
   * @param {HTMLElement} options.container - Target container element
   * @param {string} options.surface - Surface name for logging (display, public, poster)
   * @param {string} options.eventId - Event ID for logging
   * @param {string} options.layout - 'inline' (top bar), 'cards' (side panel), 'banner' (single)
   * @param {boolean} options.trackClicks - Whether to track click events
   * @param {boolean} options.trackImpressions - Whether to log impressions
   * @param {boolean} options.wrapLinks - Whether to wrap sponsors with URLs in anchor tags
   * @param {number} options.maxSponsors - Max sponsors to show (0 = all)
   * @returns {Array} - Filtered sponsors that were rendered
   */
  function renderSponsors(options) {
    const {
      sponsors = [],
      placement,
      container,
      surface = 'unknown',
      eventId = '',
      layout = 'inline',
      trackClicks = true,
      trackImpressions = true,
      wrapLinks = true,
      maxSponsors = 0
    } = options;

    if (!container || !placement) return [];

    let picks = filterByPlacement(sponsors, placement);
    if (!picks.length) return [];

    // Limit sponsors if maxSponsors is set
    if (maxSponsors > 0) {
      picks = picks.slice(0, maxSponsors);
    }

    // Render based on layout type
    let html = '';
    switch (layout) {
      case 'cards':
        html = picks.map(s => renderCard(s, wrapLinks)).join('');
        break;
      case 'banner':
        html = picks.map(s => renderBanner(s, wrapLinks)).join('');
        break;
      case 'inline':
      default:
        html = picks.map(s => renderInline(s, wrapLinks)).join('');
    }

    container.innerHTML = html;
    container.hidden = false;

    // Log impressions
    if (trackImpressions) {
      picks.forEach(s => {
        logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id || '' });
      });
    }

    // Attach click handlers
    if (trackClicks && wrapLinks) {
      container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
        a.addEventListener('click', () => {
          logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
        });
      });
    }

    return picks;
  }

  // === Layout Renderers ===
  function renderInline(s, wrapLinks) {
    const content = s.img
      ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">`
      : `<strong>${esc(s.name || '')}</strong>`;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}">${content}</a>`;
    }
    return content;
  }

  function renderCard(s, wrapLinks) {
    const card = `
      <div class="sp-card" data-id="${esc(s.id || '')}">
        ${s.img ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">` : ''}
        <div class="sp-name">${esc(s.name || '')}</div>
      </div>
    `;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}" style="text-decoration:none;color:inherit;">${card}</a>`;
    }
    return card;
  }

  function renderBanner(s, wrapLinks) {
    const content = `
      ${s.img ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">` : ''}
      <strong>${esc(s.name || '')}</strong>
    `;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}">${content}</a>`;
    }
    return `<span>${content}</span>`;
  }

  // === Sponsor Normalization ===
  /**
   * Normalize sponsor object to schema-compliant format
   * Schema: /schemas/sponsor.schema.json
   *
   * CANONICAL FIELDS (per schema):
   * - id: string (required)
   * - name: string (required)
   * - logoUrl: string (required)
   * - linkUrl: string (optional)
   * - placement: "poster"|"display"|"public"|"tv-banner" (required)
   * - isPrimary: boolean (optional) - Primary sponsor gets bigger rendering
   *
   * LEGACY FIELD MAPPING (deprecated - will be removed in V3):
   * - s.img → logoUrl
   * - s.url → linkUrl
   * - s.website → linkUrl
   * - s.placements → placement (first key with true value)
   *
   * @param {Object} s - Sponsor object (schema or legacy format)
   * @returns {Object} - Schema-compliant sponsor: { id, name, logoUrl, linkUrl, placement, isPrimary }
   */
  function normalizeSponsor(s) {
    if (!s) return null;

    // Determine placement from schema field or legacy placements object
    let placement = s.placement || '';
    if (!placement && s.placements && typeof s.placements === 'object') {
      // Legacy: find first true placement key
      placement = Object.keys(s.placements).find(k => s.placements[k]) || '';
    }

    return {
      // Schema fields
      id: s.id || '',
      name: s.name || '',
      logoUrl: s.logoUrl || s.img || '',      // Legacy fallback: img
      linkUrl: s.linkUrl || s.website || s.url || '',  // Legacy fallback: website, url
      placement: placement,
      isPrimary: !!s.isPrimary  // Feature 3: Primary sponsor flag
    };
  }

  // === Unified SponsorRenderer ===
  /**
   * Unified sponsor rendering component
   * Replaces duplicate renderSponsor* functions across surfaces
   *
   * All methods expect sponsors in schema format (/schemas/sponsor.schema.json):
   * { id, name, logoUrl, linkUrl?, placement }
   *
   * Legacy formats (img, url, placements) are auto-converted via normalizeSponsor().
   *
   * CENTRALIZED PLACEMENT FILTERING:
   * All methods accept optional `placement` parameter to filter sponsors.
   * Supported placements: 'poster' | 'public' | 'display' | 'tv-banner'
   * For Display surface, use placement: ['display', 'tv-banner'] to match either.
   */
  const SponsorRenderer = {
    /**
     * Filter sponsors by placement(s)
     * @param {Array} sponsors - Normalized sponsor array
     * @param {string|string[]} placement - Single placement or array of placements to match
     * @returns {Array} - Filtered sponsors
     */
    _filterByPlacement(sponsors, placement) {
      if (!placement) return sponsors;
      const placements = Array.isArray(placement) ? placement : [placement];
      return sponsors.filter(s => placements.includes(s.placement));
    },

    /**
     * Render sponsors as horizontal strip (top bar, banner)
     * @param {Object} options
     * @param {HTMLElement} options.container - Target element
     * @param {Array} options.sponsors - Sponsor array (schema or legacy format)
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {string} options.eventId - For analytics
     * @param {string} options.surface - Surface name (display, public, poster)
     * @param {boolean} options.showLinks - Wrap in anchor tags (default: true)
     * @param {boolean} options.showTier - Show PRIMARY badge for primary sponsors (default: false)
     * @param {Function} options.onRender - Callback with rendered sponsor IDs
     * @returns {Array} - Normalized sponsors that were rendered
     */
    renderStrip(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        showTier = false,
        onRender = null
      } = options;

      if (!container) return [];
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const filtered = this._filterByPlacement(normalized, placement);
      // Sort primary sponsors first
      const picks = filtered.sort((a, b) => (b.isPrimary ? 1 : 0) - (a.isPrimary ? 1 : 0));
      if (!picks.length) return [];

      container.innerHTML = picks.map(s => {
        const primaryClass = s.isPrimary ? ' sponsor-primary' : '';
        const tierBadge = showTier && s.isPrimary ? '<span class="sponsor-tier-badge">PRIMARY</span>' : '';
        const content = s.logoUrl
          ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}" class="sponsor-logo${primaryClass}">${tierBadge}`
          : `<strong class="${primaryClass}">${esc(s.name)}</strong>${tierBadge}`;

        if (showLinks && s.linkUrl) {
          return `<a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id)}" class="sponsor-item${primaryClass}">${content}</a>`;
        }
        return `<span class="sponsor-item${primaryClass}">${content}</span>`;
      }).join('');

      container.hidden = false;

      // Log impressions
      picks.forEach(s => logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id }));

      // Attach click handlers
      if (showLinks) {
        container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
          a.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
          });
        });
      }

      // Callback with rendered IDs (for BBN attribution)
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return picks;
    },

    /**
     * Render sponsors as card grid (side panel, TV mode)
     * @param {Object} options - Same as renderStrip plus:
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {HTMLElement} options.mainEl - Optional main element to add 'has-side' class
     * @returns {Array} - Normalized sponsors that were rendered
     */
    renderGrid(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        mainEl = null,
        onRender = null
      } = options;

      if (!container) return [];
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const picks = this._filterByPlacement(normalized, placement);
      if (!picks.length) return [];

      container.innerHTML = picks.map(s => {
        const card = `
          <div class="sp-card" data-id="${esc(s.id)}">
            ${s.logoUrl ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}">` : ''}
            <div class="sp-name">${esc(s.name)}</div>
          </div>
        `;

        if (showLinks && s.linkUrl) {
          return `<a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id)}" style="text-decoration:none;color:inherit;">${card}</a>`;
        }
        return card;
      }).join('');

      container.hidden = false;
      if (mainEl) mainEl.classList.add('has-side');

      // Log impressions
      picks.forEach(s => logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id }));

      // Attach click handlers
      if (showLinks) {
        container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
          a.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
          });
        });
      }

      // Callback with rendered IDs
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return picks;
    },

    /**
     * Render sponsors as rotating carousel (one at a time)
     * @param {Object} options - Same as renderStrip plus:
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {number} options.rotationMs - Rotation interval (default: 5000)
     * @returns {Object} - { sponsors: Array, stop: Function }
     */
    renderCarousel(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        showTier = false,
        rotationMs = 5000,
        onRender = null
      } = options;

      if (!container) return { sponsors: [], stop: () => {} };
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const picks = this._filterByPlacement(normalized, placement);
      if (!picks.length) return { sponsors: [], stop: () => {} };

      let currentIndex = 0;
      let timer = null;

      function showSponsor(index) {
        const s = picks[index];
        const indicator = picks.length > 1 ? `<span class="sponsor-indicator">${index + 1}/${picks.length}</span>` : '';

        const content = `
          ${s.logoUrl ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}">` : ''}
          <strong>${esc(s.name)}</strong>
        `;

        if (showLinks && s.linkUrl) {
          container.innerHTML = `
            <a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" class="sponsor-link" data-sponsor-id="${esc(s.id)}">
              ${content}
            </a>
            ${indicator}
          `;
        } else {
          container.innerHTML = `<span>${content}</span>${indicator}`;
        }

        // Log impression
        logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id });

        // Attach click handler
        const linkEl = container.querySelector('.sponsor-link');
        if (linkEl) {
          linkEl.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: s.id });
          });
        }
      }

      // Show first sponsor
      showSponsor(0);
      container.hidden = false;

      // Start rotation if multiple sponsors
      if (picks.length > 1) {
        timer = setInterval(() => {
          currentIndex = (currentIndex + 1) % picks.length;
          showSponsor(currentIndex);
        }, rotationMs);
      }

      // Callback with rendered IDs
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return {
        sponsors: picks,
        stop: () => { if (timer) clearInterval(timer); }
      };
    },

    // Expose normalization for external use
    normalizeSponsor
  };

  // === Public API ===
  return {
    esc,
    logEvent,
    flush,
    initLogging,
    getSessionId,  // For external click handlers that need sessionId
    filterByPlacement,
    renderSponsors,
    // Expose individual renderers for custom use
    renderInline,
    renderCard,
    renderBanner,
    // NEW: Unified renderer
    SponsorRenderer,
    normalizeSponsor,
    // Constants
    BATCH_SIZE,
    FLUSH_INTERVAL
  };
})();
</script>
