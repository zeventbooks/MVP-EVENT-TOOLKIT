<script>
/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * SharedUtils - Common utilities for all front-end pages
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 *
 * RESPONSIBILITY: This file provides UI utilities (alerts, dates, forms) ONLY.
 * It does NOT handle data entities or business logic - that belongs in Code.gs.
 *
 * WINDOW ADDITION: window.SharedUtils
 *
 * Dependencies: NUSDK.html (for NU.esc)
 * Used by: Admin.html (MVP surface)
 *
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER INDEX (keep updated when adding/removing functions):
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 *   showAlert(message, type, options)  ‚Üí Alert notifications (Admin.html)
 *   formatDate(dateInput, options)     ‚Üí Date formatting (Admin.html)
 *   formatTime(timeStr)                ‚Üí Time formatting (Admin.html)
 *   debounce(fn, delay)                ‚Üí Event debouncing (Admin.html)
 *   copyToClipboard(text)              ‚Üí Clipboard utility (Admin.html)
 *   validateUrl(url)                   ‚Üí URL validation (Admin.html)
 *   sectionEnabled(settings, key)      ‚Üí Section visibility check (Feature 4)
 *     Keys: schedule, standings, bracket, sponsors, video, map, gallery
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 *
 * @version 1.2.0
 */
window.SharedUtils = (function() {
  'use strict';

  // === Alert/Notification System ===

  /**
   * Shows a dismissible alert notification
   * @param {string} message - Alert message text
   * @param {string} type - Alert type: 'info', 'success', 'error', 'warning'
   * @param {Object} options - Optional configuration
   * @param {number} options.duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
   * @param {string} options.containerId - ID of alert container element
   */
  function showAlert(message, type = 'info', options = {}) {
    const {
      duration = 5000,
      containerId = 'alert-container'
    } = options;

    const container = document.getElementById(containerId);
    if (!container) {
      console.warn(`SharedUtils.showAlert: Container #${containerId} not found`);
      return;
    }

    const alert = document.createElement('div');
    alert.className = `alert alert-${type}`;
    alert.setAttribute('role', 'alert');

    // Create alert content with dismiss button
    const content = document.createElement('span');
    content.textContent = message;

    const dismissBtn = document.createElement('button');
    dismissBtn.type = 'button';
    dismissBtn.className = 'alert-dismiss';
    dismissBtn.innerHTML = '&times;';
    dismissBtn.setAttribute('aria-label', 'Dismiss');
    dismissBtn.onclick = () => alert.remove();

    alert.appendChild(content);
    alert.appendChild(dismissBtn);

    // Clear existing alerts and add new one
    container.innerHTML = '';
    container.appendChild(alert);

    // Auto-dismiss if duration > 0
    if (duration > 0) {
      setTimeout(() => {
        if (alert.parentNode) {
          alert.classList.add('alert-fade-out');
          setTimeout(() => alert.remove(), 300);
        }
      }, duration);
    }

    return alert;
  }

  // === Date Formatting ===

  /**
   * Formats a date string to a human-readable format
   * @param {string|Date} dateInput - Date string or Date object
   * @param {Object} options - Intl.DateTimeFormat options
   * @returns {string} Formatted date string
   */
  function formatDate(dateInput, options = {}) {
    if (!dateInput) return 'Date TBD';

    try {
      const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
      if (isNaN(date.getTime())) return 'Invalid Date';

      const defaultOptions = {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      };

      return date.toLocaleDateString('en-US', { ...defaultOptions, ...options });
    } catch (e) {
      return 'Date TBD';
    }
  }

  /**
   * Formats a date string to a relative time (e.g., "2 days ago")
   * @param {string|Date} dateInput - Date string or Date object
   * @returns {string} Relative time string
   */
  function formatRelativeTime(dateInput) {
    if (!dateInput) return '';

    try {
      const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
      if (isNaN(date.getTime())) return '';

      const now = new Date();
      const diffMs = now - date;
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

      if (diffDays === 0) return 'Today';
      if (diffDays === 1) return 'Yesterday';
      if (diffDays < 7) return `${diffDays} days ago`;
      if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
      if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
      return `${Math.floor(diffDays / 365)} years ago`;
    } catch (e) {
      return '';
    }
  }

  // === Form Utilities ===

  /**
   * Validates a form and returns validation status
   * @param {string|HTMLFormElement} formIdOrEl - Form ID or form element
   * @returns {Object} { valid: boolean, errors: Array<{field, message}> }
   */
  function validateForm(formIdOrEl) {
    const form = typeof formIdOrEl === 'string'
      ? document.getElementById(formIdOrEl)
      : formIdOrEl;

    if (!form) return { valid: false, errors: [{ field: null, message: 'Form not found' }] };

    const errors = [];
    const requiredInputs = form.querySelectorAll('[required]');

    requiredInputs.forEach(input => {
      // Clear previous error state
      input.classList.remove('form-input-error');

      if (!input.value.trim()) {
        errors.push({
          field: input.name || input.id,
          message: `${input.labels?.[0]?.textContent || input.name || 'Field'} is required`
        });
        input.classList.add('form-input-error');
      }
    });

    // Validate email fields
    form.querySelectorAll('input[type="email"]').forEach(input => {
      if (input.value && !isValidEmail(input.value)) {
        errors.push({ field: input.name || input.id, message: 'Invalid email address' });
        input.classList.add('form-input-error');
      }
    });

    // Validate URL fields
    form.querySelectorAll('input[type="url"]').forEach(input => {
      if (input.value && !isValidUrl(input.value)) {
        errors.push({ field: input.name || input.id, message: 'Invalid URL' });
        input.classList.add('form-input-error');
      }
    });

    return { valid: errors.length === 0, errors };
  }

  /**
   * Validates an email address
   * @param {string} email - Email to validate
   * @returns {boolean} True if valid
   */
  function isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  /**
   * Validates a URL
   * @param {string} url - URL to validate
   * @returns {boolean} True if valid
   */
  function isValidUrl(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  // === Loading State Management ===

  /**
   * Executes an async function with loading state management
   * @param {Function} asyncFn - Async function to execute
   * @param {Object} options - Configuration options
   * @param {string} options.loadingElId - ID of loading indicator element
   * @param {string} options.emptyElId - ID of empty state element
   * @param {string} options.contentElId - ID of content container element
   * @param {HTMLButtonElement} options.button - Submit button to disable
   * @returns {Promise<any>} Result of asyncFn
   */
  async function withLoadingState(asyncFn, options = {}) {
    const { loadingElId, emptyElId, contentElId, button } = options;

    const loadingEl = loadingElId ? document.getElementById(loadingElId) : null;
    const emptyEl = emptyElId ? document.getElementById(emptyElId) : null;
    const contentEl = contentElId ? document.getElementById(contentElId) : null;

    // Show loading state
    if (loadingEl) loadingEl.style.display = 'block';
    if (emptyEl) emptyEl.style.display = 'none';
    if (contentEl) contentEl.style.display = 'none';
    if (button) button.disabled = true;

    try {
      const result = await asyncFn();
      return result;
    } finally {
      // Hide loading state
      if (loadingEl) loadingEl.style.display = 'none';
      if (button) button.disabled = false;
    }
  }

  // === DOM Utilities ===

  /**
   * Toggles element visibility
   * @param {string} elementId - ID of element to toggle
   * @param {string} className - Class to toggle (default: 'hidden')
   */
  function toggleElement(elementId, className = 'hidden') {
    const el = document.getElementById(elementId);
    if (el) el.classList.toggle(className);
  }

  /**
   * Shows an element by removing hidden class
   * @param {string} elementId - ID of element to show
   */
  function showElement(elementId) {
    const el = document.getElementById(elementId);
    if (el) el.style.display = 'block';
  }

  /**
   * Hides an element by setting display none
   * @param {string} elementId - ID of element to hide
   */
  function hideElement(elementId) {
    const el = document.getElementById(elementId);
    if (el) el.style.display = 'none';
  }

  // === XSS Prevention (delegating to NU.esc) ===

  /**
   * Escapes HTML special characters to prevent XSS
   * Delegates to NU.esc if available, otherwise uses local implementation
   *
   * IMPORTANT: Prefer using NU.esc() directly when NUSDK is included.
   * This is provided for backwards compatibility.
   *
   * @param {string} unsafe - String to escape
   * @returns {string} HTML-safe string
   */
  function esc(unsafe) {
    // Delegate to NU.esc if available (canonical implementation)
    if (window.NU && typeof window.NU.esc === 'function') {
      return window.NU.esc(unsafe);
    }
    // Fallback implementation (should rarely be used)
    if (!unsafe) return '';
    return String(unsafe).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  }

  // === Debounce/Throttle ===

  /**
   * Creates a debounced version of a function
   * @param {Function} fn - Function to debounce
   * @param {number} delay - Delay in milliseconds
   * @returns {Function} Debounced function
   */
  function debounce(fn, delay = 300) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  /**
   * Creates a throttled version of a function
   * @param {Function} fn - Function to throttle
   * @param {number} limit - Minimum time between calls in milliseconds
   * @returns {Function} Throttled function
   */
  function throttle(fn, limit = 100) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        fn.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  // === Toast Notifications (non-blocking) ===

  /**
   * Shows a brief toast notification (non-blocking alternative to alert())
   * @param {string} message - Toast message
   * @param {string} type - 'success', 'error', 'info', 'warning'
   * @param {number} duration - Auto-dismiss duration in ms (default: 3000)
   */
  function showToast(message, type = 'info', duration = 3000) {
    // Remove existing toast
    const existing = document.querySelector('.shared-toast');
    if (existing) existing.remove();

    const toast = document.createElement('div');
    toast.className = `shared-toast shared-toast-${type}`;
    toast.setAttribute('role', 'status');
    toast.textContent = message;

    // Inject minimal styles if not present
    if (!document.getElementById('shared-toast-styles')) {
      const style = document.createElement('style');
      style.id = 'shared-toast-styles';
      style.textContent = `
        .shared-toast {
          position: fixed; bottom: 20px; right: 20px;
          padding: 12px 20px; border-radius: 8px;
          font-size: 14px; font-weight: 500; z-index: 9999;
          animation: toast-slide-in 0.3s ease;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .shared-toast-success { background: #10b981; color: white; }
        .shared-toast-error { background: #ef4444; color: white; }
        .shared-toast-info { background: #3b82f6; color: white; }
        .shared-toast-warning { background: #f59e0b; color: white; }
        @keyframes toast-slide-in { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(toast);

    // Auto-dismiss
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(20px)';
      toast.style.transition = 'all 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  // === StateRenderer (unified error/empty/loading states) ===

  const StateRenderer = {
    /**
     * Render error state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { title, message, onRetry }
     */
    showError(container, options = {}) {
      const { title = 'Something went wrong', message = 'Please try again.', onRetry = null } = options;
      container.innerHTML = `
        <div class="error-state">
          <div class="error-state-icon">‚ö†Ô∏è</div>
          <h3>${esc(title)}</h3>
          <p>${esc(message)}</p>
          ${onRetry ? '<button class="btn-retry">üîÑ Try Again</button>' : ''}
        </div>
      `;
      if (onRetry) {
        container.querySelector('.btn-retry')?.addEventListener('click', onRetry);
      }
    },

    /**
     * Render empty state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { icon, title, message, backUrl }
     */
    showEmpty(container, options = {}) {
      const { icon = 'üì≠', title = 'Nothing here', message = '', backUrl = null } = options;
      container.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">${icon}</div>
          <h3>${esc(title)}</h3>
          ${message ? `<p>${esc(message)}</p>` : ''}
          ${backUrl ? `<a href="${esc(backUrl)}" class="btn-secondary">‚Üê Go Back</a>` : ''}
        </div>
      `;
    },

    /**
     * Render loading state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { message }
     */
    showLoading(container, options = {}) {
      const { message = 'Loading...' } = options;
      container.innerHTML = `
        <div class="loading-state">
          <div class="loading-spinner"></div>
          <p>${esc(message)}</p>
        </div>
      `;
    }
  };

  // === EVENT_CONTRACT.md v2.0 Support ===

  /**
   * Checks if an event section is enabled via settings
   * Extracted from Display.html and Poster.html (D-008)
   * Trust the contract - never invent flags
   *
   * Feature 4: Template-Aware Section Toggles - added showVideo, showMap, showGallery
   *
   * @param {Object} settings - Event settings object
   * @param {string} key - Section key: 'schedule', 'standings', 'bracket', 'sponsors', 'video', 'map', 'gallery'
   * @returns {boolean} True if section is enabled
   */
  function sectionEnabled(settings, key) {
    if (!settings) return false;
    switch (key) {
      // Data sections (require explicit true)
      case 'schedule': return settings.showSchedule === true;
      case 'standings': return settings.showStandings === true;
      case 'bracket': return settings.showBracket === true;
      case 'sponsors': return settings.showSponsors === true;
      // Content sections (default true for backwards compat - Feature 4)
      case 'video': return settings.showVideo !== false;
      case 'map': return settings.showMap !== false;
      case 'gallery': return settings.showGallery !== false;
      default: return false;
    }
  }

  // === Public API ===
  return {
    // Alerts
    showAlert,

    // Toast (non-blocking)
    showToast,

    // State rendering
    StateRenderer,

    // Date formatting
    formatDate,
    formatRelativeTime,

    // Form utilities
    validateForm,
    isValidEmail,
    isValidUrl,

    // Loading state
    withLoadingState,

    // DOM utilities
    toggleElement,
    showElement,
    hideElement,

    // XSS (delegates to NU.esc)
    esc,

    // Utility functions
    debounce,
    throttle,

    // EVENT_CONTRACT helpers
    sectionEnabled
  };
})();
</script>
