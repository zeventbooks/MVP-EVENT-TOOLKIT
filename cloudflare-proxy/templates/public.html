<!--
================================================================================
MVP SURFACE - Focus Group Critical
================================================================================
Page: Public.html
Purpose: Public-facing event listing and registration page
Status: HARDENED for MVP v1.0

SCHEMA CONTRACT: /schemas/event.schema.json

═══════════════════════════════════════════════════════════════════════════════
READS FROM EVENT SCHEMA:
═══════════════════════════════════════════════════════════════════════════════
  Identity (MVP Required):
    - event.id, event.name, event.startDateISO, event.venue

  CTAs (MVP Required):
    - event.ctas.primary.label, event.ctas.primary.url
    - event.ctas.secondary.label, event.ctas.secondary.url

  Settings (MVP Required - section visibility):
    - event.settings.showSchedule, showStandings, showBracket, showSponsors
    - event.settings.showVideo, showMap, showGallery (Feature 4: Template-Aware)
    - event.settings.showSponsorBanner → Sponsor banner visibility (default: true)

  Data Sections (MVP Optional):
    - event.schedule[].time, title, description
    - event.standings[].rank, team, wins, losses, points
    - event.bracket.rounds[].name, matches[]

  Sponsors (V2 Optional):
    - event.sponsors[].id, name, logoUrl, linkUrl, placement

  Media (V2 Optional):
    - event.media.videoUrl, mapUrl, gallery[]

  External Data (V2 Optional):
    - event.externalData.scheduleUrl, standingsUrl, bracketUrl

  Payments (Reserved):
    - event.payments.enabled, checkoutUrl, price, currency

═══════════════════════════════════════════════════════════════════════════════
SECTION GATES (each optional section requires explicit schema field check):
═══════════════════════════════════════════════════════════════════════════════
  Content Sections (Feature 4: Template-Aware Toggles):
  Video:     if (settings.showVideo && media?.videoUrl) → render video embed
  Map:       if (settings.showMap && (media?.mapUrl OR venue)) → render map link
  Gallery:   if (settings.showGallery && media?.gallery?.length) → render photo gallery

  Data Sections:
  Schedule:  if (settings.showSchedule && (schedule?.length || externalData.scheduleUrl))
  Standings: if (settings.showStandings && (standings?.length || externalData.standingsUrl))
  Bracket:   if (settings.showBracket && (bracket?.rounds?.length || externalData.bracketUrl))
  Sponsors:  if (settings.showSponsors && settings.showSponsorBanner !== false
             && sponsors?.some(s => s.placement === 'public'))
  Payments:  if (payments?.enabled && payments.checkoutUrl) → show checkout CTA

  NO freelancing: sections only render when their schema field exists AND is enabled.

DO NOT add fields without updating:
  - /schemas/event.schema.json (source of truth)
  - src/mvp/Code.gs (_buildEventContract_)

Related MVP Surfaces: Admin, Poster, Display, Sponsor, SharedReport
================================================================================
-->
<!DOCTYPE html>
<!--
  Template: Public
  Bundled: 2025-12-13T21:40:31.116Z
  Hash: bbadeb47
  Source: GAS templates (src/mvp/)
  Generator: scripts/bundle-worker-templates.js

  Variables (replaced at runtime):
  - <?= appTitle ?> - Page title
  - <?= brandId ?> - Brand identifier
  - <?= scope ?> - Scope (events, leagues, etc.)
  - <?= execUrl ?> - API endpoint URL
-->

<html>
<head>
  <meta charset="utf-8"/>
  <title><?= appTitle ?> · Public</title>
  <style>
  /* ===== Zeventbook Global Styles ===== */

  /* Reset & Base */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  /* Mobile-First: Prevent horizontal scroll globally */
  html, body {
    overflow-x: hidden;
    max-width: 100vw;
  }

  body {
    font-family: var(--font-family-base, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif);
    line-height: var(--line-height-base, 1.6);
    color: var(--color-gray-800, #1e293b);
    background: var(--color-gray-50, #f8fafc);
    /* Safe area support for notched devices (iPhone X+) */
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Mobile-first: prevent text overflow */
    word-wrap: break-word;
    overflow-wrap: break-word;
    -webkit-text-size-adjust: 100%;
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    /* Additional safe area padding on mobile */
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
  }

  /* Header */
  .site-header {
    background: white;
    border-bottom: 2px solid var(--color-primary, #2563eb);
    padding: 16px 0;
    margin-bottom: 24px;
    box-shadow: var(--shadow-sm, 0 2px 4px rgba(0,0,0,0.05));
  }

  .header-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .header-logo {
    max-height: var(--sponsor-logo-height, 60px);
    width: auto;
  }

  /* TS-002: Using design token instead of hardcoded 1.8rem */
  .header-title h1 {
    color: var(--color-primary, #2563eb);
    font-size: 1.8rem;
    margin-bottom: 4px;
  }

  .build-info {
    color: var(--color-gray-500, #64748b);
    font-size: 0.85rem;
  }

  /* Cards - Standardized padding: 24px desktop / 20px tablet / 16px mobile */
  .card {
    background: white;
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding, 24px);
    margin-bottom: var(--space-6, 24px);
    box-shadow: var(--shadow-base, 0 1px 3px rgba(0,0,0,0.1));
    border-left: 4px solid var(--color-primary, #2563eb);
  }

  .card h2 {
    margin-bottom: 16px;
    color: var(--color-gray-800, #1e293b);
    font-size: 1.5rem;
    border-bottom: 2px solid var(--color-gray-200, #e2e8f0);
    padding-bottom: 8px;
  }

  /* Section separators for better information density */
  /* CR-001: Merged duplicate .card h3 rules into single coherent block */
  .card h3 {
    margin-top: 28px;
    margin-bottom: 16px;
    padding-top: 20px;
    border-top: 1px solid var(--color-gray-100, #f1f5f9);
  }

  .card h3:first-of-type {
    margin-top: var(--space-5, 20px);
    padding-top: 0;
    border-top: none;
  }

  .card h3 {
    margin-top: 20px;
    margin-bottom: 12px;
    color: var(--color-gray-600, #475569);
    font-size: 1.2rem;
  }

  .card h4 {
    margin-top: 16px;
    margin-bottom: 8px;
    color: var(--color-gray-500, #64748b);
    font-size: 1rem;
  }

  /* Forms */
  .form-group {
    margin-bottom: 20px;
  }

  /* Form rows - Mobile-first with better density */
  .form-row {
    display: grid;
    grid-template-columns: 1fr; /* Mobile: single column for clarity */
    gap: 20px; /* More breathing room */
    margin-bottom: 20px;
  }

  /* Tablet and up: side-by-side fields */
  @media (min-width: 640px) {
    .form-row {
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }
  }

  label {
    display: block;
    margin-bottom: 6px;
    color: var(--color-gray-600, #475569);
    font-weight: 500;
    font-size: 14px;
  }

  input[type="text"],
  input[type="email"],
  input[type="tel"],
  input[type="url"],
  input[type="date"],
  input[type="time"],
  input[type="number"],
  select,
  textarea {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--color-gray-200, #e2e8f0);
    border-radius: 6px;
    font-size: 14px;
    font-family: inherit;
    transition: border-color 0.2s, box-shadow 0.2s;
    min-height: 44px; /* WCAG 2.5.5 touch target minimum */
  }

  /* Disabled input states - accessibility enhancement */
  input:disabled,
  select:disabled,
  textarea:disabled {
    background-color: var(--color-gray-50, #f8fafc);
    color: var(--color-gray-400, #94a3b8);
    cursor: not-allowed;
    opacity: 0.65;
    border-color: var(--color-gray-300, #cbd5e1);
  }

  input:focus,
  select:focus,
  textarea:focus {
    outline: none;
    border-color: var(--color-primary, #2563eb);
    box-shadow: 0 0 0 3px var(--focus-ring-color-alpha, rgba(37, 99, 235, 0.1));
  }

  textarea {
    min-height: 80px;
    resize: vertical;
  }

  /* Buttons - Mobile-first, thumb-friendly 44px minimum tap target */
  .btn-primary {
    background: var(--color-primary, #2563eb);
    color: white;
    padding: 14px 28px;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 16px);
    font-weight: var(--font-weight-semibold, 600);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    display: inline-block;
    text-decoration: none;
    min-height: var(--touch-target-min, 44px);
    line-height: 1.2;
    text-align: center;
  }

  .btn-primary:hover {
    background: var(--color-primary-dark, #1d4ed8);
    transform: translateY(-1px);
    box-shadow: var(--shadow-primary, 0 4px 12px rgba(37, 99, 235, 0.3));
  }

  .btn-primary:active {
    transform: translateY(0);
  }

  .btn-secondary {
    background: white;
    color: var(--color-gray-600, #475569);
    padding: 12px 24px;
    border: 2px solid var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 15px);
    font-weight: var(--font-weight-medium, 500);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    display: inline-block;
    text-decoration: none;
    min-height: var(--touch-target-min, 44px);
    line-height: 1.2;
    text-align: center;
  }

  .btn-secondary:hover {
    background: var(--color-gray-50, #f8fafc);
    border-color: var(--color-primary, #2563eb);
    color: var(--color-primary, #2563eb);
  }

  .btn-success {
    background: var(--color-success, #10b981);
    color: white;
    padding: 14px 28px;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 16px);
    font-weight: var(--font-weight-semibold, 600);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    min-height: var(--touch-target-min, 44px);
  }

  .btn-success:hover {
    background: var(--color-success-dark, #059669);
  }

  .btn-danger {
    background: var(--color-danger, #ef4444);
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 15px);
    font-weight: var(--font-weight-medium, 500);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    min-height: var(--touch-target-min, 44px);
  }

  .btn-danger:hover {
    background: var(--color-danger-dark, #dc2626);
  }

  /* Disabled button states - accessibility enhancement */
  .btn-primary:disabled,
  .btn-secondary:disabled,
  .btn-success:disabled,
  .btn-danger:disabled,
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
    transform: none;
    box-shadow: none;
  }

  .btn-primary:disabled {
    background-color: var(--color-gray-300, #cbd5e1);
  }

  .btn-secondary:disabled {
    background-color: var(--color-gray-100, #f1f5f9);
    border-color: var(--color-gray-300, #cbd5e1);
    color: var(--color-gray-400, #94a3b8);
  }

  .button-group {
    display: flex;
    gap: 12px;
    margin-top: 24px;
    flex-wrap: wrap;
  }

  /* Mobile: Stack buttons vertically with full width */
  @media (max-width: 640px) {
    .button-group {
      flex-direction: column;
      gap: 12px;
    }

    .button-group .btn-primary,
    .button-group .btn-secondary,
    .button-group .btn-success,
    .button-group .btn-danger {
      width: 100%;
      text-align: center;
    }
  }

  /* Tabs */
  .tabs {
    display: flex;
    gap: 8px;
    margin-bottom: var(--space-6, 24px);
    border-bottom: 2px solid var(--color-gray-200, #e2e8f0);
  }

  .tab-button {
    padding: 12px 24px;
    background: transparent;
    border: none;
    border-bottom: 3px solid transparent;
    font-size: var(--font-size-base, 15px);
    font-weight: var(--font-weight-medium, 500);
    color: var(--color-gray-500, #64748b);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s);
    margin-bottom: -2px;
  }

  .tab-button:hover {
    color: var(--color-primary, #2563eb);
    background: var(--color-gray-100, #f1f5f9);
  }

  .tab-button.active {
    color: var(--color-primary, #2563eb);
    border-bottom-color: var(--color-primary, #2563eb);
    background: white;
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  /* Grids - Mobile-first responsive layout */
  .events-grid {
    display: grid;
    grid-template-columns: 1fr; /* Mobile: single column */
    gap: 16px;
    margin-top: 20px;
  }

  /* Tablet: 2 columns */
  @media (min-width: 640px) {
    .events-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
    }
  }

  /* Desktop: 3 columns */
  @media (min-width: 1024px) {
    .events-grid {
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
    }
  }

  /* Large desktop: 4 columns */
  @media (min-width: 1440px) {
    .events-grid {
      grid-template-columns: repeat(4, 1fr);
    }
  }

  .event-card {
    background: var(--color-gray-50, #f8fafc);
    border: 1px solid var(--color-gray-200, #e2e8f0);
    border-left: 3px solid var(--color-gray-500, #64748b); /* Subtle left accent for visual hierarchy */
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-tablet, 20px);
    transition: all var(--transition-base, 0.2s);
  }

  .event-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md, 0 4px 12px rgba(0,0,0,0.1));
    border-left-color: var(--color-primary, #2563eb); /* Blue accent on hover */
    background: white;
  }

  .event-card h3 {
    margin: 0 0 12px 0;
    color: var(--color-gray-800, #1e293b);
    font-size: 1.1rem;
  }

  .event-card h4 {
    margin: 0 0 8px 0;
    color: var(--color-gray-600, #475569);
    font-size: 1rem;
  }

  .event-card p {
    color: var(--color-gray-500, #64748b);
    margin-bottom: 8px;
    font-size: var(--font-size-sm, 14px);
  }

  .event-card small {
    color: var(--color-gray-400, #94a3b8);
    font-size: var(--font-size-xs, 12px);
  }

  /* QR Codes */
  .qr-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 24px;
    margin: 24px 0;
  }

  .qr-code {
    text-align: center;
    padding: var(--card-padding-tablet, 20px);
    background: var(--color-gray-50, #f8fafc);
    border-radius: var(--radius-md, 12px);
    border: 2px solid var(--color-gray-200, #e2e8f0);
  }

  .qr-code h3 {
    margin: 0 0 8px 0;
    color: var(--color-gray-800, #1e293b);
    font-size: 1rem;
  }

  .qr-code h4 {
    margin: 0 0 12px 0;
    color: var(--color-gray-600, #475569);
    font-size: 0.9rem;
  }

  .qr-code img {
    width: 100%;
    max-width: 250px;
    height: auto;
    margin: 12px auto;
    display: block;
  }

  .qr-code p {
    margin-top: 12px;
    color: var(--color-gray-500, #64748b);
    font-size: var(--font-size-sm, 13px);
    word-break: break-all;
  }

  /* Loading Overlay */
  .loading-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.95);
    z-index: 9999;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }

  .spinner {
    border: 4px solid var(--color-gray-200, #e2e8f0);
    border-top: 4px solid var(--color-primary, #2563eb);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .loading-overlay p {
    margin-top: 16px;
    color: var(--color-gray-500, #64748b);
    font-weight: var(--font-weight-medium, 500);
  }

  /* Utilities */
  .muted {
    color: var(--color-gray-400, #94a3b8);
    font-size: 0.9em;
  }

  .text-center {
    text-align: center;
  }

  .mt-1 { margin-top: 8px; }
  .mt-2 { margin-top: 16px; }
  .mt-3 { margin-top: 24px; }
  .mb-1 { margin-bottom: 8px; }
  .mb-2 { margin-bottom: 16px; }
  .mb-3 { margin-bottom: 24px; }

  /* Sponsor Badges */
  .sponsor-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
  }

  .sponsor-badge.gold {
    background: #fef3c7;
    color: #92400e;
  }

  .sponsor-badge.silver {
    background: #e5e7eb;
    color: #374151;
  }

  .sponsor-badge.bronze {
    background: #fed7aa;
    color: #9a3412;
  }

  /* Data Visualization Components */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin: 24px 0;
  }

  .stat-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: var(--space-6, 24px); /* D-AUDIT: Using design token for consistent rhythm */
    border-radius: var(--radius-md, 12px); /* D-AUDIT: Using design token for consistency */
    text-align: center;
    box-shadow: var(--shadow-md, 0 4px 12px rgba(0,0,0,0.1));
    transition: transform var(--transition-base, 0.2s ease);
  }

  .stat-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  }

  .stat-card.blue {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
  }

  .stat-card.green {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  }

  .stat-card.purple {
    background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
  }

  .stat-card.orange {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  }

  .stat-card.red {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  }

  .stat-value {
    font-size: 2.5rem;
    font-weight: 700;
    line-height: 1;
    margin-bottom: 8px;
  }

  .stat-label {
    font-size: var(--font-size-sm, 0.875rem); /* D-AUDIT: Aligned to type scale from 0.9rem */
    opacity: 0.95;
    font-weight: var(--font-weight-medium, 500);
    text-transform: uppercase;
    letter-spacing: var(--letter-spacing-wide, 0.025em);
  }

  .stat-trend {
    margin-top: var(--space-2, 8px);
    font-size: var(--font-size-sm, 0.875rem); /* D-AUDIT: Aligned to type scale from 0.85rem */
    opacity: 0.9;
  }

  .stat-trend.up::before {
    content: '↑ ';
  }

  .stat-trend.down::before {
    content: '↓ ';
  }

  /* Progress Bars */
  .progress-bar {
    width: 100%;
    height: 8px;
    background: var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-sm, 4px);
    overflow: hidden;
    margin: 12px 0;
  }

  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--color-primary, #2563eb) 0%, var(--color-primary-light, #3b82f6) 100%);
    border-radius: var(--radius-sm, 4px);
    transition: width 0.3s ease;
  }

  .progress-bar-fill.green {
    background: linear-gradient(90deg, var(--color-success, #10b981) 0%, var(--color-success-light, #34d399) 100%);
  }

  .progress-bar-fill.orange {
    background: linear-gradient(90deg, var(--color-warning, #f59e0b) 0%, var(--color-warning-light, #fbbf24) 100%);
  }

  /* Phase Indicators */
  .phase-indicator {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 16px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .phase-indicator.pre-event {
    background: #dbeafe;
    color: #1e40af;
  }

  .phase-indicator.event-day {
    background: #d1fae5;
    color: #065f46;
  }

  .phase-indicator.post-event {
    background: #fce7f3;
    color: #9f1239;
  }

  .phase-indicator::before {
    content: '';
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: currentColor;
  }

  /* Metric Cards */
  .metric-card {
    background: white;
    border: 2px solid var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-tablet, 20px);
    transition: all var(--transition-base, 0.2s ease);
  }

  .metric-card:hover {
    border-color: var(--color-primary, #2563eb);
    box-shadow: 0 4px 12px var(--shadow-primary-alpha, rgba(37, 99, 235, 0.1));
  }

  .metric-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .metric-title {
    font-size: 0.9rem;
    color: var(--color-gray-500, #64748b);
    font-weight: var(--font-weight-medium, 500);
    text-transform: uppercase;
    letter-spacing: var(--letter-spacing-wide, 0.025em);
  }

  .metric-value {
    font-size: 2rem;
    font-weight: var(--font-weight-bold, 700);
    color: var(--color-gray-800, #1e293b);
    line-height: 1;
  }

  .metric-subtitle {
    margin-top: 8px;
    font-size: 0.85rem;
    color: var(--color-gray-400, #94a3b8);
  }

  /* Status Badges */
  .status-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
  }

  .status-badge.active {
    background: #d1fae5;
    color: #065f46;
  }

  .status-badge.upcoming {
    background: #dbeafe;
    color: #1e40af;
  }

  .status-badge.ended {
    background: #f1f5f9;
    color: #475569;
  }

  .status-badge::before {
    content: '';
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: currentColor;
  }

  /* Mobile Touch Optimizations */
  @media (max-width: 768px) {
    /* Increase tap targets for mobile */
    input[type="text"],
    input[type="email"],
    input[type="tel"],
    input[type="url"],
    input[type="date"],
    input[type="time"],
    input[type="number"],
    select {
      min-height: 44px;
      font-size: 16px; /* Prevents iOS zoom on focus */
    }

    /* Bottom-aligned sticky action buttons for one-handed use */
    .sticky-bottom-actions {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 12px 16px;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
      z-index: 100;
      border-top: 1px solid var(--color-gray-200, #e2e8f0);
    }

    .sticky-bottom-actions .btn-primary,
    .sticky-bottom-actions .btn-secondary {
      width: 100%;
      margin-bottom: 8px;
    }

    .sticky-bottom-actions .btn-primary:last-child,
    .sticky-bottom-actions .btn-secondary:last-child {
      margin-bottom: 0;
    }
  }

  /* Enhanced Sponsor Banners */
  .sponsor-banner {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 12px;
    margin: 24px 0;
  }

  .sponsor-logo {
    max-height: var(--sponsor-logo-height, 60px);
    width: auto;
    object-fit: contain;
    transition: transform var(--transition-base, 0.2s ease);
    cursor: pointer;
  }

  .sponsor-logo:hover {
    transform: scale(1.1);
  }

  .sponsor-banner.compact .sponsor-logo {
    max-height: 40px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .container {
      padding: 12px;
      /* Respect safe areas on mobile */
      padding-left: max(12px, env(safe-area-inset-left));
      padding-right: max(12px, env(safe-area-inset-right));
    }

    .card {
      padding: 16px; /* Reduced padding on mobile for better information density */
      border-radius: 8px; /* Slightly smaller border radius */
      margin-bottom: 16px;
    }

    .card h2 {
      font-size: 1.25rem; /* Slightly smaller headings on mobile */
    }

    .header-title h1 {
      font-size: 1.5rem;
    }

    .header-logo {
      max-height: 48px;
    }

    .form-row {
      grid-template-columns: 1fr;
    }

    .events-grid {
      grid-template-columns: 1fr;
    }

    .qr-grid {
      grid-template-columns: 1fr;
    }

    .stats-grid {
      grid-template-columns: 1fr;
    }

    .stat-value {
      font-size: 2rem;
    }

    .metric-value {
      font-size: 1.75rem;
    }

    .tabs {
      overflow-x: auto;
    }

    .tab-button {
      white-space: nowrap;
    }

    .button-group {
      flex-direction: column;
    }

    .button-group .btn-primary,
    .button-group .btn-secondary {
      width: 100%;
      text-align: center;
    }

    .sponsor-banner {
      padding: 16px;
      gap: 12px;
    }

    .sponsor-logo {
      max-height: var(--sponsor-logo-height-sm, 50px);
    }
  }

  /* ===== Alert Components ===== */
  .alert {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 12px 16px;
    border-radius: 8px;
    margin-bottom: 16px;
    font-size: 14px;
    font-weight: 500;
    animation: alert-slide-in 0.3s ease-out;
  }

  @keyframes alert-slide-in {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .alert-fade-out {
    animation: alert-fade-out 0.3s ease-out forwards;
  }

  @keyframes alert-fade-out {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(-10px);
    }
  }

  .alert-info {
    background: #dbeafe;
    color: #1e40af;
    border: 1px solid #93c5fd;
  }

  .alert-success {
    background: #dcfce7;
    color: #166534;
    border: 1px solid #86efac;
  }

  .alert-error {
    background: #fee2e2;
    color: #991b1b;
    border: 1px solid #fca5a5;
  }

  .alert-warning {
    background: #fef3c7;
    color: #92400e;
    border: 1px solid #fde68a;
  }

  .alert-dismiss {
    background: transparent;
    border: none;
    font-size: 20px;
    line-height: 1;
    cursor: pointer;
    opacity: 0.6;
    padding: 0 4px;
    color: inherit;
  }

  .alert-dismiss:hover {
    opacity: 1;
  }

  /* ===== Tier Badges ===== */
  .tier-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 9999px;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.025em;
  }

  .tier-badge.platinum,
  .tier-platinum {
    background: #e5e7eb;
    color: #1f2937;
  }

  .tier-badge.gold,
  .tier-gold {
    background: #fef3c7;
    color: #92400e;
  }

  .tier-badge.silver,
  .tier-silver {
    background: #f3f4f6;
    color: #374151;
  }

  .tier-badge.bronze,
  .tier-bronze {
    background: #fed7aa;
    color: #7c2d12;
  }

  /* ===== Form Validation States ===== */
  /* Full class names for specificity */
  .form-input-error,
  input.form-input-error,
  select.form-input-error,
  textarea.form-input-error,
  /* Short aliases (I-004) */
  .input-error,
  input.input-error,
  select.input-error,
  textarea.input-error {
    border-color: var(--color-danger, #ef4444) !important;
    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1) !important;
  }

  .form-input-success,
  input.form-input-success,
  select.form-input-success,
  textarea.form-input-success,
  /* Short aliases (I-004) */
  .input-success,
  input.input-success,
  select.input-success,
  textarea.input-success {
    border-color: var(--color-success, #10b981) !important;
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1) !important;
  }

  /* Validation message styling */
  .input-error-message,
  .form-error-message {
    color: var(--color-danger, #ef4444);
    font-size: var(--font-size-sm, 0.875rem);
    margin-top: 4px;
  }

  .input-success-message {
    color: var(--color-success, #10b981);
    font-size: var(--font-size-sm, 0.875rem);
    margin-top: 4px;
  }

  .form-hint {
    margin-top: 4px;
    font-size: var(--font-size-sm, 13px);
    color: var(--color-gray-500, #64748b);
  }

  .form-error-message {
    margin-top: 4px;
    font-size: var(--font-size-sm, 13px);
    color: var(--color-danger, #ef4444);
  }

  /* ===== Page Layout Components ===== */
  /* Shared page section styles (MVP: Admin.html, Public.html) */
  .page-section {
    background: white;
    border-radius: 16px;
    padding: 2rem;
    margin-bottom: 2rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  }

  .page-section h2 {
    margin: 0 0 1.5rem 0;
    font-size: 1.5rem;
    color: var(--color-gray-800, #1f2937);
    border-bottom: 2px solid var(--color-gray-200, #e5e7eb);
    padding-bottom: 0.75rem;
  }

  .page-header-card {
    background: white;
    border-radius: var(--radius-lg, 16px);
    padding: 2rem;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-lg, 0 10px 30px rgba(0, 0, 0, 0.1));
  }

  .page-header-card h1 {
    margin: 0 0 0.5rem 0;
    font-size: 2rem;
    color: var(--color-gray-800, #1f2937);
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .page-header-card .subtitle {
    color: var(--color-gray-500, #6b7280);
    font-size: 1rem;
  }

  .nav-breadcrumb {
    margin-bottom: 1rem;
  }

  .nav-breadcrumb a {
    color: var(--color-primary, #2563eb);
    text-decoration: none;
    transition: color var(--transition-base, 0.2s);
  }

  .nav-breadcrumb a:hover {
    text-decoration: underline;
  }

  /* ===== Entity Card Grid ===== */
  /* Shared grid for sponsors, events, forms, etc. */
  .entity-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
  }

  .entity-card {
    background: var(--color-gray-50, #f9fafb);
    border: 2px solid var(--color-gray-200, #e5e7eb);
    border-radius: var(--radius-md, 12px);
    padding: 1.5rem;
    transition: all var(--transition-base, 0.2s);
  }

  .entity-card:hover {
    border-color: var(--color-primary, #2563eb);
    box-shadow: var(--shadow-md, 0 4px 12px rgba(0, 0, 0, 0.1));
  }

  .entity-card h3 {
    margin: 0 0 0.5rem 0;
    font-size: 1.25rem;
    color: var(--color-gray-800, #1f2937);
  }

  .entity-card-info {
    font-size: var(--font-size-sm, 0.875rem);
    color: var(--color-gray-500, #6b7280);
    margin-bottom: 0.5rem;
  }

  .entity-card-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }

  /* ===== Analytics Cards ===== */
  .analytics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
  }

  .analytics-card {
    background: var(--color-gray-50, #f9fafb);
    border: 2px solid var(--color-gray-200, #e5e7eb);
    border-radius: var(--radius-base, 8px);
    padding: 1.5rem;
    text-align: center;
    transition: all var(--transition-base, 0.2s);
  }

  .analytics-card:hover {
    border-color: var(--color-primary, #2563eb);
  }

  .analytics-card .value {
    font-size: 2rem;
    font-weight: var(--font-weight-bold, 700);
    color: var(--color-gray-800, #1f2937);
    margin-bottom: 0.5rem;
  }

  .analytics-card .label {
    font-size: var(--font-size-sm, 0.875rem);
    color: var(--color-gray-500, #6b7280);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* ===== Button Size Variants ===== */
  .btn-sm {
    padding: 8px 16px;
    font-size: 14px;
    min-height: 36px;
  }

  .btn-full {
    width: 100%;
  }

  /* ===== Retry Button (D-005: Centralized from 4 pages) ===== */
  .btn-retry {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 10px 20px;
    background: var(--color-primary, #2563eb);
    color: white;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-sm, 0.875rem);
    font-weight: var(--font-weight-medium, 500);
    cursor: pointer;
    text-decoration: none;
    transition: background var(--transition-fast, 0.15s ease);
  }

  .btn-retry:hover {
    background: var(--color-primary-dark, #1d4ed8);
  }

  .btn-retry:focus-visible {
    outline: var(--focus-ring-width, 3px) solid var(--focus-ring-color, var(--color-primary));
    outline-offset: var(--focus-ring-offset, 2px);
  }

  /* ===== Empty State ===== */
  .empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--color-gray-500, #6b7280);
  }

  .empty-state-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
  }

  .empty-state h3 {
    margin: 0 0 0.5rem 0;
    color: var(--color-gray-700, #374151);
  }

  /* ===== Loading State ===== */
  .loading-state {
    text-align: center;
    padding: 2rem;
    color: var(--color-gray-500, #6b7280);
  }

  /* Print Styles */
  @media print {
    body {
      background: white;
    }

    .site-header {
      border-bottom: 1px solid #000;
    }

    .build-info,
    .button-group,
    .tabs {
      display: none !important;
    }

    .card {
      box-shadow: none;
      page-break-inside: avoid;
      border: 1px solid var(--color-gray-200, #e2e8f0);
    }

    .qr-code {
      page-break-inside: avoid;
    }
  }

  /* ===== Mobile-First Critical Patterns ===== */

  /* Prevent any element from causing horizontal scroll */
  img, video, iframe, embed, object {
    max-width: 100%;
    height: auto;
  }

  /* Table overflow handling for mobile */
  .table-responsive {
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* Text overflow prevention */
  h1, h2, h3, h4, h5, h6, p, span, a, li {
    word-wrap: break-word;
    overflow-wrap: break-word;
  }

  /* Long URLs and codes */
  code, pre, .monospace, [style*="monospace"] {
    word-break: break-all;
    overflow-wrap: anywhere;
  }

  /* Mobile-optimized links (finger-friendly) */
  @media (max-width: 640px) {
    a {
      -webkit-tap-highlight-color: transparent;
    }

    /* Ensure all interactive elements have adequate spacing */
    .card a,
    .card button {
      min-height: 44px;
      display: inline-flex;
      align-items: center;
    }
  }

  /* Collapsible card headers - Mobile tap-friendly */
  .collapsible-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    padding: 12px 16px;
    min-height: var(--touch-target-min, 44px);
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }

  .collapsible-header:active {
    background: var(--color-gray-100, #f1f5f9);
  }

  .collapsible-icon {
    transition: transform var(--transition-base, 0.2s);
    font-size: 0.8em;
  }

  .collapsible-header.collapsed .collapsible-icon {
    transform: rotate(-90deg);
  }

  /* Mobile-friendly error card */
  .error-card {
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-left: 4px solid #ef4444;
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-mobile, 16px);
    margin: 16px 0;
    word-wrap: break-word;
  }

  .error-card h3 {
    color: #dc2626;
    font-size: 1.1rem;
    margin-bottom: 8px;
  }

  .error-card p {
    color: #7f1d1d;
    font-size: 0.9rem;
    line-height: 1.5;
  }

  .error-card .corr-id {
    font-family: var(--font-family-mono, monospace);
    font-size: 0.75rem;
    color: #9ca3af;
    margin-top: 12px;
    word-break: break-all;
  }

  /* ===== Story 4: Configuration Issue Card ===== */
  /* Shows when backend is misconfigured (4xx errors, GAS_UPSTREAM_NON_JSON) */
  .config-issue-state {
    background: #fef9e7;
    border: 1px solid #fcd34d;
    border-left: 4px solid #f59e0b;
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-tablet, 24px);
    text-align: center;
  }

  .config-issue-state h3 {
    color: #92400e;
    margin-bottom: 8px;
  }

  .config-issue-state p {
    color: #78350f;
    margin-bottom: 16px;
  }

  .config-issue-state .btn-retry {
    background: #f59e0b;
    color: white;
  }

  .config-issue-state .btn-retry:hover {
    background: #d97706;
  }

  /* ===== Story 4: Diagnostic Panel (Staging Only) ===== */
  /* Expandable panel showing technical error details */
  .diagnostic-panel {
    margin-top: 16px;
    text-align: left;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid #fcd34d;
    border-radius: var(--radius-base, 8px);
    overflow: hidden;
  }

  .diagnostic-toggle {
    display: block;
    padding: 10px 16px;
    cursor: pointer;
    font-size: var(--font-size-sm, 0.875rem);
    font-weight: var(--font-weight-medium, 500);
    color: #92400e;
    background: rgba(252, 211, 77, 0.2);
    user-select: none;
    list-style: none;
  }

  .diagnostic-toggle::-webkit-details-marker {
    display: none;
  }

  .diagnostic-toggle::before {
    content: '▶';
    display: inline-block;
    margin-right: 8px;
    font-size: 0.7em;
    transition: transform var(--transition-base, 0.2s);
  }

  .diagnostic-panel[open] .diagnostic-toggle::before {
    transform: rotate(90deg);
  }

  .diagnostic-content {
    padding: 12px 16px;
    font-size: var(--font-size-sm, 0.875rem);
    background: white;
  }

  .diagnostic-row {
    display: flex;
    gap: 8px;
    padding: 6px 0;
    border-bottom: 1px solid #f3f4f6;
  }

  .diagnostic-row:last-child {
    border-bottom: none;
  }

  .diagnostic-label {
    color: #6b7280;
    font-weight: var(--font-weight-medium, 500);
    min-width: 100px;
    flex-shrink: 0;
  }

  .diagnostic-content code {
    background: #f3f4f6;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: var(--font-family-mono, monospace);
    font-size: 0.85em;
    color: #374151;
    word-break: break-all;
  }

  /* Mobile adjustments for diagnostic panel */
  @media (max-width: 640px) {
    .diagnostic-row {
      flex-direction: column;
      gap: 4px;
    }

    .diagnostic-label {
      min-width: auto;
    }
  }

  /* Sticky bottom action bar for mobile */
  .sticky-action-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    padding: 12px 16px;
    padding-bottom: max(12px, env(safe-area-inset-bottom));
    box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
    z-index: var(--z-index-sticky, 100);
    border-top: 1px solid var(--color-gray-200, #e2e8f0);
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .sticky-action-bar .btn-primary,
  .sticky-action-bar .btn-secondary {
    width: 100%;
    justify-content: center;
  }

  /* Checkbox group for mobile - tap-friendly */
  .checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .checkbox-label {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--color-gray-50, #f8fafc);
    border: 1px solid var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-base, 8px);
    cursor: pointer;
    min-height: var(--touch-target-min, 44px);
    font-size: var(--font-size-sm, 0.875rem);
    transition: all var(--transition-fast, 0.15s);
    -webkit-tap-highlight-color: transparent;
  }

  .checkbox-label:hover {
    background: var(--color-gray-100, #f1f5f9);
  }

  .checkbox-label input[type="checkbox"] {
    width: 20px;
    height: 20px;
    accent-color: var(--color-primary, #2563eb);
  }

  .checkbox-label:has(input:checked) {
    background: var(--color-primary-bg, #eff6ff);
    border-color: var(--color-primary-light, #bfdbfe);
  }

  /* Site footer - unified across surfaces */
  .site-footer {
    text-align: center;
    padding: 24px 16px;
    color: var(--color-gray-400, #94a3b8);
    font-size: var(--font-size-sm, 0.875rem);
    border-top: 1px solid var(--color-gray-200, #e2e8f0);
    margin-top: 40px;
    background: var(--color-gray-50, #f8fafc);
  }

  .site-footer a {
    color: var(--color-primary, #2563eb);
    text-decoration: none;
  }

  .site-footer a:hover {
    text-decoration: underline;
  }

  /* TV mode footer */
  body[data-tv="1"] .site-footer {
    background: transparent;
    border-top-color: var(--color-tv-border, #333);
    color: var(--color-tv-text-muted, #888);
    padding: 12px;
    font-size: max(0.75rem, 12px);
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    margin: 0;
  }

  body[data-tv="1"] .site-footer a {
    color: var(--color-tv-accent, #60a5fa);
  }

  /* Mobile footer adjustment for sticky buttons */
  @media (max-width: 640px) {
    body.has-sticky-actions .site-footer {
      padding-bottom: 100px;
    }
  }
</style>

  <!--
═══════════════════════════════════════════════════════════════════════════════
NUSDK v2.2 - Fetch-Based NU SDK for Google Apps Script
═══════════════════════════════════════════════════════════════════════════════

RESPONSIBILITY: This file provides the RPC client for frontend→backend calls ONLY.
It does NOT implement business logic - that belongs in Code.gs.

WINDOW ADDITIONS:
- window.NU        - Main SDK object
- window.__NU_LOGS__ - Rolling log buffer for diagnostics
- window.NU_DIAG   - Diagnostic helper for Test.html

INITIALIZATION:
Call NU.init({ execUrl, brand }) early in page setup to configure transport.
Falls back to template variables when available:
  NU.init({ execUrl: '<?= execUrl ?>', brand: '<?= brandId ?>' });

TRANSPORT OPTIONS:
1. Worker Proxy (default): Fetch-based (/api/<path>) through Cloudflare Worker
   - Used when: NU.init() called with no execUrl or empty execUrl
2. Direct GAS Transport: Fetch-based ({execUrl}?action={method}&brand={brand})
   - Used when: NU.init({ execUrl: '...', brand: '...' }) called with valid URL
   - Legacy enable: NU.configureDirectTransport(execUrl, brand)
   - Includes retry logic with exponential backoff
   - Includes correlation ID for distributed tracing

LOGGING LEVELS:
- Staging: 'debug' (all logs)
- Production: 'error' (errors only)

RESPONSE ENVELOPE CONTRACT (all API endpoints follow this pattern):

SUCCESS:
{
  ok: true,
  etag?: string,           // Optional cache tag for SWR
  notModified?: boolean,   // True if content unchanged (304 equivalent)
  value: { ... }           // Endpoint-specific payload per ApiSchemas.gs
}

ERROR:
{
  ok: false,
  code: "BAD_INPUT" | "NOT_FOUND" | "RATE_LIMITED" | "INTERNAL" | "UNAUTHORIZED",
  message: "Human-readable error description"
}

USAGE:
  const res = await NU.rpc('events/list', { brandId });
  if (!res.ok) {
    console.error(res.code, res.message);
    return;
  }
  const { events } = res.value;

See ApiSchemas.gs for full endpoint inventory and schemas.
═══════════════════════════════════════════════════════════════════════════════
-->
<script>
// =============================================================================
// Rolling Log Buffer - Global diagnostic storage
// =============================================================================
window.__NU_LOGS__ = [];

// =============================================================================
// NU SDK - Main SDK Object
// =============================================================================
window.NU = {
  /**
   * SDK Version
   */
  VERSION: '2.2.0',

  /**
   * Configuration
   * @private
   */
  _config: {
    logLevel: 'debug', // 'debug' | 'error' | 'none' - auto-detected from environment
    maxLogs: 100,      // Max entries in rolling log buffer
    apiBase: '/api',   // Base path for API endpoints
    dedupeWindow: 5000 // Error deduplication window (ms)
  },

  /**
   * Direct transport configuration (for direct GAS exec URL calls)
   * @private
   */
  _directTransport: {
    enabled: false,    // Whether to use direct GAS transport instead of Worker proxy
    execUrl: null,     // GAS web app exec URL
    brand: null,       // Brand identifier for multi-tenant routing
    maxRetries: 3,     // Max retry attempts for transient failures
    retryDelayMs: 1000 // Base delay for exponential backoff (doubles each retry)
  },

  /**
   * Log level constants
   * @private
   */
  _LOG_LEVELS: Object.freeze({ none: 0, error: 1, debug: 2 }),

  /**
   * Pending requests for flush tracking
   * @private
   */
  _pending: [],

  /**
   * Error deduplication tracking
   * @private
   */
  _errorDedupeMap: new Map(),

  /**
   * Environment flags - detected once at init
   * @private
   */
  _env: {
    isStaging: false,
    isProduction: false,
    hostname: ''
  },

  /**
   * Initialize SDK - auto-detect environment and set log level
   * @private
   */
  _init() {
    // Auto-detect environment from hostname
    // SECURITY: Use exact match or suffix match to prevent subdomain spoofing
    // e.g., "fake-eventangle.com" should NOT match as production
    const hostname = window.location?.hostname || '';

    // Helper for safe domain suffix check
    const isDomain = (host, domain) =>
      host === domain || host.endsWith('.' + domain);

    const isStaging = isDomain(hostname, 'stg.eventangle.com') ||
                      hostname === 'localhost' ||
                      hostname === '127.0.0.1';
    const isProduction = isDomain(hostname, 'eventangle.com') && !isStaging;

    // Store environment flags for use by other components
    NU._env = { isStaging, isProduction, hostname };

    // Set log level based on environment
    if (isProduction) {
      NU._config.logLevel = 'error';
    } else {
      NU._config.logLevel = 'debug';
    }

    NU._log('debug', 'init', {
      version: NU.VERSION,
      logLevel: NU._config.logLevel,
      hostname,
      isStaging,
      isProduction
    });
  },

  /**
   * Initialization state tracking
   * @private
   */
  _initialized: false,

  /**
   * Initialize the SDK with configuration
   *
   * Call this method early in your page initialization to configure the SDK.
   * If execUrl is provided, the SDK will use direct GAS transport.
   * If not provided (or empty), the SDK will use the Cloudflare Worker proxy.
   *
   * Fallback behavior:
   * - In GAS-hosted pages: Pass template vars: NU.init({ execUrl: '<?= execUrl ?>', brand: '<?= brandId ?>' })
   * - In proxy contexts: Call with no args or empty config to use Worker proxy
   *
   * @param {object} config - Configuration object
   * @param {string} [config.execUrl] - GAS web app exec URL for direct transport
   * @param {string} [config.brand] - Brand identifier for multi-tenant routing
   * @param {object} [config.directTransportOptions] - Optional direct transport settings { maxRetries?, retryDelayMs? }
   * @returns {void}
   *
   * @example
   * // Initialize with direct GAS transport (from GAS-hosted template)
   * NU.init({
   *   execUrl: '<?= execUrl ?>',  // Template var from GAS
   *   brand: '<?= brandId ?>'     // Template var from GAS
   * });
   *
   * @example
   * // Initialize with proxy transport (default, no config needed)
   * NU.init(); // or NU.init({})
   *
   * @example
   * // Initialize with custom retry settings
   * NU.init({
   *   execUrl: 'https://script.google.com/macros/s/ABC123/exec',
   *   brand: 'eventangle',
   *   directTransportOptions: { maxRetries: 5, retryDelayMs: 500 }
   * });
   */
  init(config = {}) {
    const { execUrl, brand, directTransportOptions = {} } = config;

    // Determine if we have a valid execUrl for direct transport
    // Empty strings from unpopulated template vars (<?= execUrl ?>) should be treated as falsy
    const hasValidExecUrl = execUrl && typeof execUrl === 'string' && execUrl.trim() !== '';

    if (hasValidExecUrl) {
      // Validate URL format before enabling direct transport
      try {
        new URL(execUrl);

        // Configure and enable direct transport
        NU._directTransport = {
          enabled: true,
          execUrl: execUrl.trim(),
          brand: brand || null,
          maxRetries: directTransportOptions.maxRetries ?? 3,
          retryDelayMs: directTransportOptions.retryDelayMs ?? 1000
        };

        NU._log('debug', 'init_config', {
          transport: 'direct',
          execUrl: execUrl.substring(0, 50) + (execUrl.length > 50 ? '...' : ''),
          brand: brand || '(none)',
          maxRetries: NU._directTransport.maxRetries,
          retryDelayMs: NU._directTransport.retryDelayMs
        });

      } catch {
        // Invalid URL - fall back to proxy transport
        NU._log('error', 'init_config', {
          error: 'Invalid execUrl format, falling back to proxy transport',
          execUrl: execUrl.substring(0, 50)
        });
        // Keep direct transport disabled (default)
      }
    } else {
      // No execUrl provided - use Worker proxy (default)
      NU._log('debug', 'init_config', {
        transport: 'proxy',
        apiBase: NU._config.apiBase,
        reason: hasValidExecUrl === false ? 'execUrl not provided' : 'execUrl empty'
      });
    }

    NU._initialized = true;
  },

  /**
   * Check if SDK has been initialized via init()
   * @returns {boolean} True if init() has been called
   */
  isInitialized() {
    return NU._initialized;
  },

  /**
   * Get current transport mode
   * @returns {'direct' | 'proxy'} Current transport mode
   */
  getTransportMode() {
    return NU._directTransport.enabled ? 'direct' : 'proxy';
  },

  /**
   * Check if running in staging environment
   * Useful for showing diagnostic information in staging only
   * @returns {boolean} True if staging environment
   */
  isStaging() {
    return NU._env.isStaging;
  },

  /**
   * Check if running in production environment
   * @returns {boolean} True if production environment
   */
  isProduction() {
    return NU._env.isProduction;
  },

  /**
   * Internal logging with rolling buffer
   * Logs to both __NU_LOGS__ buffer and console (based on log level)
   *
   * @param {string} level - 'debug' | 'error'
   * @param {string} type - Log type: 'start' | 'ok' | 'network_fail' | 'http_fail' | 'json_fail' | 'error'
   * @param {object} data - Log data
   * @private
   */
  _log(level, type, data = {}) {
    const entry = {
      timestamp: new Date().toISOString(),
      level,
      type,
      ...data
    };

    // Add timing if startTime provided
    if (data.startTime) {
      entry.durationMs = Date.now() - data.startTime;
      delete entry.startTime;
    }

    // Add to rolling buffer
    window.__NU_LOGS__.push(entry);
    if (window.__NU_LOGS__.length > NU._config.maxLogs) {
      window.__NU_LOGS__.shift();
    }

    // Console output based on log level
    const currentLevel = NU._LOG_LEVELS[NU._config.logLevel] || 0;
    const entryLevel = NU._LOG_LEVELS[level] || 0;

    if (entryLevel <= currentLevel) {
      const prefix = '[NUSDK]';
      const logData = { ...entry };
      delete logData.timestamp;
      delete logData.level;

      if (level === 'error') {
        console.error(prefix, type, JSON.stringify(logData));
      } else {
        console.debug(prefix, type, JSON.stringify(logData));
      }
    }
  },

  /**
   * Check for duplicate error (deduplication within time window)
   * @private
   */
  _isDuplicateError(path, code) {
    const key = `${path}:${code}`;
    const now = Date.now();
    const lastTime = NU._errorDedupeMap.get(key);

    if (lastTime && (now - lastTime) < NU._config.dedupeWindow) {
      return true;
    }

    NU._errorDedupeMap.set(key, now);

    // Clean old entries periodically
    if (NU._errorDedupeMap.size > 100) {
      for (const [k, t] of NU._errorDedupeMap.entries()) {
        if (now - t > NU._config.dedupeWindow) {
          NU._errorDedupeMap.delete(k);
        }
      }
    }

    return false;
  },

  /**
   * Generate a correlation ID for distributed tracing
   * Format: timestamp-randomhex (e.g., "1702345678901-a3f2b1c9")
   * @private
   * @returns {string} Correlation ID
   */
  _generateCorrId() {
    const timestamp = Date.now();
    const randomPart = Math.random().toString(16).slice(2, 10);
    return `${timestamp}-${randomPart}`;
  },

  /**
   * Sleep helper for retry delays
   * @private
   * @param {number} ms - Milliseconds to sleep
   * @returns {Promise<void>}
   */
  _sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  /**
   * Direct GAS transport via exec URL
   * Calls {execUrl}?action={method}&brand={brand} with POST body
   *
   * Features:
   * - Retry logic with exponential backoff for transient failures
   * - Correlation ID header for distributed tracing
   * - Consistent error envelope: { ok, value?, code?, message? }
   *
   * @private
   * @param {string} method - API method name (e.g., 'events/list', 'getPublicBundle')
   * @param {object} payload - Request payload
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string, corrId?: string}>}
   */
  async _fetchTransport(method, payload = {}) {
    const { execUrl, brand, maxRetries, retryDelayMs } = NU._directTransport;
    const corrId = NU._generateCorrId();
    const startTime = Date.now();

    // Validate configuration
    if (!execUrl) {
      NU._log('error', 'transport_error', {
        method,
        corrId,
        error: 'Direct transport not configured: execUrl is required'
      });
      return {
        ok: false,
        code: 'CONFIG_ERROR',
        message: 'Direct transport not configured',
        corrId
      };
    }

    // Build URL with query parameters
    const url = new URL(execUrl);
    url.searchParams.set('action', method);
    if (brand) {
      url.searchParams.set('brand', brand);
    }

    NU._log('debug', 'transport_start', {
      method,
      corrId,
      url: url.toString(),
      payloadKeys: Object.keys(payload)
    });

    let lastError = null;
    let attempt = 0;

    while (attempt <= maxRetries) {
      try {
        const response = await fetch(url.toString(), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Correlation-Id': corrId
          },
          body: JSON.stringify(payload)
        });

        // Handle HTTP errors
        if (!response.ok) {
          const httpError = {
            ok: false,
            code: 'HTTP_ERROR',
            message: `HTTP ${response.status}`,
            status: response.status,
            corrId
          };

          // Try to parse error body for more details
          try {
            const errorBody = await response.json();
            if (errorBody.code) httpError.code = errorBody.code;
            if (errorBody.message) httpError.message = errorBody.message;
          } catch {
            // Ignore JSON parse errors for error responses
          }

          // Don't retry client errors (4xx), only server errors (5xx)
          if (response.status >= 400 && response.status < 500) {
            NU._log('error', 'http_fail', {
              method,
              corrId,
              status: response.status,
              code: httpError.code,
              attempt,
              startTime
            });
            return httpError;
          }

          // Server error - retry if we have attempts left
          lastError = httpError;
          if (attempt < maxRetries) {
            const delay = retryDelayMs * Math.pow(2, attempt);
            NU._log('debug', 'transport_retry', {
              method,
              corrId,
              attempt: attempt + 1,
              maxRetries,
              delayMs: delay,
              status: response.status
            });
            await NU._sleep(delay);
            attempt++;
            continue;
          }

          NU._log('error', 'http_fail', {
            method,
            corrId,
            status: response.status,
            code: httpError.code,
            attempt,
            startTime
          });
          return httpError;
        }

        // Parse successful response
        let data;
        try {
          data = await response.json();
        } catch (jsonError) {
          NU._log('error', 'json_fail', {
            method,
            corrId,
            error: jsonError.message,
            attempt,
            startTime
          });
          return {
            ok: false,
            code: 'PARSE_ERROR',
            message: 'Invalid JSON response from server',
            corrId
          };
        }

        // Add corrId to response for tracing
        if (typeof data === 'object' && data !== null) {
          data.corrId = corrId;
        }

        NU._log('debug', 'transport_ok', {
          method,
          corrId,
          hasValue: !!data?.value,
          attempt,
          startTime
        });

        return data;

      } catch (networkError) {
        // Network error (DNS, connection refused, timeout, etc.)
        lastError = {
          ok: false,
          code: 'NETWORK_ERROR',
          message: String(networkError.message || networkError),
          corrId
        };

        if (attempt < maxRetries) {
          const delay = retryDelayMs * Math.pow(2, attempt);
          NU._log('debug', 'transport_retry', {
            method,
            corrId,
            attempt: attempt + 1,
            maxRetries,
            delayMs: delay,
            error: networkError.message
          });
          await NU._sleep(delay);
          attempt++;
          continue;
        }

        NU._log('error', 'network_fail', {
          method,
          corrId,
          error: networkError.message,
          attempt,
          startTime
        });
        return lastError;
      }
    }

    // Should not reach here, but return last error just in case
    return lastError || {
      ok: false,
      code: 'UNKNOWN_ERROR',
      message: 'Request failed after retries',
      corrId
    };
  },

  /**
   * Make an RPC call to the backend
   *
   * Transport selection:
   * - If direct transport is enabled: uses {execUrl}?action={path}&brand={brand}
   * - Otherwise: uses Cloudflare Worker proxy at /api/{path}
   *
   * Uses fetch for all requests. NO google.script.run fallback
   * as it fails when proxied through Cloudflare.
   *
   * @param {string} path - API path (e.g., 'events/list', 'getPublicBundle')
   * @param {object} payload - Request parameters
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async rpc(path, payload = {}) {
    // Use direct GAS transport if configured and enabled
    if (NU._directTransport.enabled) {
      return NU._fetchTransport(path, payload);
    }

    const startTime = Date.now();
    const requestId = Math.random().toString(36).slice(2, 10);

    // Log request start
    NU._log('debug', 'start', { path, requestId, payloadKeys: Object.keys(payload) });

    // Track pending request
    const pendingEntry = { path, requestId, startTime };
    NU._pending.push(pendingEntry);

    try {
      // Build API URL - support both path formats:
      // - 'events/list' -> '/api/events/list'
      // - 'api_getPublicBundle' -> '/api/rpc' with method in body (legacy)
      const isLegacyMethod = path.startsWith('api_');
      const url = isLegacyMethod
        ? `${NU._config.apiBase}/rpc`
        : `${NU._config.apiBase}/${path}`;

      const body = isLegacyMethod
        ? JSON.stringify({ method: path, payload })
        : JSON.stringify(payload);

      // Make fetch request (NO google.script.run fallback - fails through Cloudflare)
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-Request-Id': requestId
        },
        body,
        credentials: 'same-origin'
      });

      // Handle HTTP errors
      // Story 4: Preserve status and errorCode from Worker for frontend error classification
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          errorData = { ok: false, code: 'INTERNAL', message: `HTTP ${response.status}` };
        }

        // Ensure status is always present for error classification
        // Story 4: Worker may return { ok, errorCode, status, message }
        if (!errorData.status) {
          errorData.status = response.status;
        }

        NU._log('error', 'http_fail', {
          path,
          requestId,
          status: errorData.status,
          code: errorData.code || errorData.errorCode,
          errorCode: errorData.errorCode,
          startTime
        });

        return errorData;
      }

      // Parse JSON response
      let data;
      try {
        data = await response.json();
      } catch (jsonError) {
        NU._log('error', 'json_fail', {
          path,
          requestId,
          error: jsonError.message,
          startTime
        });
        return { ok: false, code: 'INTERNAL', message: 'Invalid JSON response' };
      }

      // Log success with timing
      NU._log('debug', 'ok', {
        path,
        requestId,
        hasValue: !!data?.value,
        startTime
      });

      return data;

    } catch (fetchError) {
      // Network error - NO fallback to google.script.run (fails through Cloudflare)
      NU._log('error', 'network_fail', {
        path,
        requestId,
        error: fetchError.message,
        startTime
      });
      return {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Cannot connect to backend. Check your connection.'
      };

    } finally {
      // Remove from pending
      const idx = NU._pending.indexOf(pendingEntry);
      if (idx > -1) NU._pending.splice(idx, 1);
    }
  },

  /**
   * Flush all pending requests
   * Waits for all in-flight requests to complete
   *
   * @returns {Promise<void>}
   */
  async flush() {
    if (NU._pending.length === 0) {
      NU._log('debug', 'flush', { message: 'No pending requests' });
      return;
    }

    NU._log('debug', 'flush', { pendingCount: NU._pending.length });

    // Wait for all pending requests (with timeout)
    const timeout = 5000;
    const startTime = Date.now();

    while (NU._pending.length > 0 && (Date.now() - startTime) < timeout) {
      await new Promise(r => setTimeout(r, 100));
    }

    if (NU._pending.length > 0) {
      NU._log('error', 'flush', {
        message: 'Timeout waiting for pending requests',
        remaining: NU._pending.length
      });
    } else {
      NU._log('debug', 'flush', { message: 'All requests completed' });
    }
  },

  /**
   * Stale-while-revalidate pattern for cached data
   * Returns cached data immediately, then fetches fresh data
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - { staleMs, onUpdate }
   */
  swr(path, payload, { staleMs = 120000, onUpdate } = {}) {
    const key = `swr:${path}:${JSON.stringify(payload || {})}`;
    const cached = JSON.parse(localStorage.getItem(key) || '{}');

    if (cached.data) {
      setTimeout(() => onUpdate && onUpdate(cached.data), 0);
    }

    NU.rpc(path, { ...(payload || {}), ifNoneMatch: cached.etag }).then(res => {
      if (res?.notModified) return;
      if (res?.ok && res.value) {
        localStorage.setItem(key, JSON.stringify({
          etag: res.etag,
          data: res.value,
          t: Date.now()
        }));
        onUpdate && onUpdate(res.value);
      }
    });
  },

  /**
   * Escapes HTML special characters to prevent XSS
   *
   * @param {string} s - String to escape
   * @returns {string} HTML-safe string
   */
  esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  },

  /**
   * Safe RPC wrapper with graceful error handling for UI display
   * Normalizes all error types to a consistent format for StateRenderer
   *
   * Story 4: Preserves status and errorCode from Worker for error classification:
   * - status: HTTP status code (400-599)
   * - errorCode: Specific error code like 'GAS_UPSTREAM_NON_JSON'
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - { onError, silent }
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string, status?: number, errorCode?: string}>}
   */
  async safeRpc(path, payload, options = {}) {
    const { onError, silent = false } = options;

    try {
      const res = await NU.rpc(path, payload);

      // Handle backend error responses (ok: false)
      if (!res.ok) {
        // Story 4: Preserve status and errorCode for frontend error classification
        const errorInfo = {
          ok: false,
          code: res.code || res.errorCode || 'UNKNOWN',
          errorCode: res.errorCode,  // Specific error code from Worker (e.g., GAS_UPSTREAM_NON_JSON)
          status: res.status,         // HTTP status code for classification
          message: res.message || 'An unexpected error occurred',
          corrId: res.corrId
        };

        // Log error (with deduplication)
        if (!silent && !NU._isDuplicateError(path, errorInfo.code)) {
          NU._log('error', 'error', {
            path,
            code: errorInfo.code,
            errorCode: errorInfo.errorCode,
            status: errorInfo.status,
            message: errorInfo.message,
            corrId: errorInfo.corrId
          });
        }

        if (onError) onError(errorInfo);
        return errorInfo;
      }

      return res;

    } catch (e) {
      // Handle network/runtime errors
      const errorInfo = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'We\'re having trouble connecting. Please check your connection and try again.'
      };

      if (!silent && !NU._isDuplicateError(path, 'NETWORK_ERROR')) {
        NU._log('error', 'network_fail', {
          path,
          error: e?.message || errorInfo.message
        });
      }

      if (onError) onError(errorInfo);
      return errorInfo;
    }
  },

  /**
   * Fire-and-forget analytics logging that NEVER throws or blocks UI
   *
   * @param {string} path - Analytics API path
   * @param {object} payload - Analytics data
   * @returns {void}
   */
  safeAnalytics(path, payload) {
    // Fire and forget - don't await, don't block
    (async () => {
      try {
        const url = path.startsWith('api_')
          ? `${NU._config.apiBase}/rpc`
          : `${NU._config.apiBase}/${path}`;

        const body = path.startsWith('api_')
          ? JSON.stringify({ method: path, payload })
          : JSON.stringify(payload);

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body,
          credentials: 'same-origin'
        });

        if (!response.ok) {
          NU._log('debug', 'analytics_fail', { path, status: response.status });
        }

      } catch (fetchError) {
        // Story 4.1: No google.script.run fallback - fetch is the only transport
        // Analytics failures are silently ignored (fire-and-forget pattern)
        NU._log('debug', 'analytics_skip', { path, reason: 'fetch_failed', error: fetchError?.message });
      }
    })();
  },

  /**
   * Safe analytics batch logger
   *
   * @param {Array} items - Array of analytics items
   */
  safeLogEvents(items) {
    if (!items?.length) return;
    NU.safeAnalytics('api_logEvents', { items });
  },

  /**
   * Safe external click logger
   *
   * @param {object} params - { eventId, sponsorId, surface, linkType?, ua? }
   */
  safeLogClick(params) {
    NU.safeAnalytics('api_logExternalClick', {
      ...params,
      ua: params.ua || navigator.userAgent
    });
  },

  /**
   * Set log level manually
   *
   * @param {'debug' | 'error' | 'none'} level - Log level
   */
  setLogLevel(level) {
    if (NU._LOG_LEVELS.hasOwnProperty(level)) {
      NU._config.logLevel = level;
      NU._log('debug', 'config', { logLevel: level });
    }
  },

  /**
   * Get current configuration (for diagnostics)
   *
   * @returns {object} Current SDK configuration including transport state
   */
  getConfig() {
    return {
      ...NU._config,
      version: NU.VERSION,
      initialized: NU._initialized,
      transportMode: NU.getTransportMode(),
      directTransport: {
        enabled: NU._directTransport.enabled,
        hasExecUrl: !!NU._directTransport.execUrl,
        hasBrand: !!NU._directTransport.brand
      }
    };
  },

  /**
   * Configure and enable direct GAS transport
   * When enabled, rpc() calls will use the direct exec URL instead of Worker proxy
   *
   * @param {string} execUrl - GAS web app exec URL (required)
   * @param {string} brand - Brand identifier for multi-tenant routing (optional)
   * @param {object} options - Additional options { maxRetries?, retryDelayMs? }
   * @returns {void}
   *
   * @example
   * // Enable direct transport
   * NU.configureDirectTransport(
   *   'https://script.google.com/macros/s/ABC123/exec',
   *   'eventangle'
   * );
   *
   * // With custom retry settings
   * NU.configureDirectTransport(
   *   'https://script.google.com/macros/s/ABC123/exec',
   *   'eventangle',
   *   { maxRetries: 5, retryDelayMs: 500 }
   * );
   */
  configureDirectTransport(execUrl, brand = null, options = {}) {
    if (!execUrl) {
      NU._log('error', 'config', { error: 'execUrl is required for direct transport' });
      throw new Error('execUrl is required for configureDirectTransport');
    }

    // Validate URL format
    try {
      new URL(execUrl);
    } catch {
      NU._log('error', 'config', { error: 'Invalid execUrl format', execUrl });
      throw new Error('Invalid execUrl format');
    }

    const { maxRetries = 3, retryDelayMs = 1000 } = options;

    NU._directTransport = {
      enabled: true,
      execUrl,
      brand,
      maxRetries,
      retryDelayMs
    };

    NU._log('debug', 'config', {
      type: 'direct_transport_configured',
      execUrl: execUrl.substring(0, 50) + '...', // Truncate for logging
      brand,
      maxRetries,
      retryDelayMs
    });
  },

  /**
   * Disable direct transport and revert to Worker proxy
   * @returns {void}
   */
  disableDirectTransport() {
    NU._directTransport.enabled = false;
    NU._log('debug', 'config', { type: 'direct_transport_disabled' });
  },

  /**
   * Check if direct transport is enabled
   * @returns {boolean}
   */
  isDirectTransportEnabled() {
    return NU._directTransport.enabled;
  },

  // =============================================================================
  // Story 4.3: Enhanced API Wrappers with Global Error Handling
  // =============================================================================

  /**
   * Enhanced RPC with automatic retry and user feedback
   * Integrates with GlobalErrorHandler for comprehensive error handling
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Enhanced options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async resilientRpc(path, payload = {}, options = {}) {
    const {
      retry = true,
      maxAttempts = 3,
      showToast = true,
      showDialog = false,
      onError = null,
      onRetryAttempt = null,
      context = path
    } = options;

    // Use GlobalErrorHandler if available
    const handler = window.GlobalErrorHandler;

    const makeRequest = async () => {
      const res = await NU.rpc(path, payload);
      if (!res.ok) {
        // Convert to throwable error for retry logic
        const err = new Error(res.message || 'Request failed');
        err.code = res.code;
        err.corrId = res.corrId;
        err.response = res;
        throw err;
      }
      return res;
    };

    try {
      if (retry && handler) {
        // Use GlobalErrorHandler's retry with exponential backoff
        return await handler.withRetry(makeRequest, {
          attempts: maxAttempts,
          shouldRetry: (err) => {
            // Only retry network and transient errors
            const code = err?.code || err?.response?.code;
            return ['NETWORK_ERROR', 'TIMEOUT', 'SERVICE_UNAVAILABLE'].includes(code);
          },
          onRetryAttempt: (attempt, total, delay, err) => {
            NU._log('debug', 'retry', { path, attempt, total, delay, code: err?.code });
            if (onRetryAttempt) onRetryAttempt(attempt, total, delay, err);
          }
        });
      } else {
        return await makeRequest();
      }
    } catch (err) {
      // Return the original error response if available
      if (err.response) {
        if (onError) onError(err.response);

        if (handler) {
          if (showDialog) {
            handler.showErrorDialog({
              title: 'Unable to Complete Request',
              message: `We couldn't ${context}. Please try again.`,
              corrId: err.corrId,
              onRetry: () => NU.resilientRpc(path, payload, options)
            });
          } else if (showToast) {
            handler.showErrorToast(`Unable to ${context}. Please try again.`);
          }
        }

        return err.response;
      }

      // Network error without response
      const errorResponse = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Cannot connect to server. Please check your connection.'
      };

      if (onError) onError(errorResponse);

      if (handler && showToast) {
        handler.showErrorToast('Connection error. Please check your network.');
      }

      return errorResponse;
    }
  },

  /**
   * Load data with comprehensive error handling and UI state management
   * Perfect for initial page loads and data refresh
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Load options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async loadData(path, payload = {}, options = {}) {
    const {
      container = null,
      onSuccess = null,
      onError = null,
      showLoading = true,
      retry = true,
      context = 'load data'
    } = options;

    const StateRenderer = window.SharedUtils?.StateRenderer;

    // Show loading state
    if (showLoading && container && StateRenderer) {
      StateRenderer.showLoading(container, { message: 'Loading...' });
    }

    const res = await NU.resilientRpc(path, payload, {
      retry,
      showToast: false,
      context
    });

    if (res.ok) {
      if (onSuccess) onSuccess(res.value);
    } else {
      // Show error state in container
      if (container && StateRenderer) {
        StateRenderer.showFromError(container, res, {
          onRetry: () => NU.loadData(path, payload, options)
        });
      }
      if (onError) onError(res);
    }

    return res;
  },

  /**
   * Submit data with user feedback (for forms, saves, etc.)
   * Shows appropriate toast/dialog feedback
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Submit options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async submitData(path, payload = {}, options = {}) {
    const {
      successMessage = 'Saved successfully!',
      errorMessage = 'Unable to save. Please try again.',
      onSuccess = null,
      onError = null,
      button = null,
      context = 'save'
    } = options;

    const showToast = window.SharedUtils?.showToast;

    // Disable button during submit
    if (button) {
      button.disabled = true;
      button.dataset.originalText = button.textContent;
      button.textContent = 'Saving...';
    }

    try {
      const res = await NU.resilientRpc(path, payload, {
        retry: true,
        showToast: false,
        context
      });

      if (res.ok) {
        if (showToast) showToast(successMessage, 'success');
        if (onSuccess) onSuccess(res.value);
      } else {
        if (showToast) showToast(errorMessage, 'error');
        if (onError) onError(res);
      }

      return res;

    } finally {
      // Re-enable button
      if (button) {
        button.disabled = false;
        button.textContent = button.dataset.originalText || 'Save';
      }
    }
  }
};

// =============================================================================
// NU_DIAG - Diagnostic Helper for Test.html
// =============================================================================
window.NU_DIAG = {
  /**
   * Get all logs from the rolling buffer
   *
   * @param {object} options - { type?, level?, limit? }
   * @returns {Array} Filtered log entries
   */
  getLogs(options = {}) {
    const { type, level, limit = 100 } = options;
    let logs = [...window.__NU_LOGS__];

    if (type) {
      logs = logs.filter(l => l.type === type);
    }
    if (level) {
      logs = logs.filter(l => l.level === level);
    }

    return logs.slice(-limit);
  },

  /**
   * Clear all logs from the buffer
   */
  clearLogs() {
    window.__NU_LOGS__.length = 0;
    console.debug('[NU_DIAG] Logs cleared');
  },

  /**
   * Get statistics about logged requests
   *
   * @returns {object} Statistics object
   */
  getStats() {
    const logs = window.__NU_LOGS__;
    const stats = {
      totalLogs: logs.length,
      byType: {},
      byLevel: {},
      errors: [],
      avgDurationMs: 0
    };

    let totalDuration = 0;
    let durationCount = 0;

    logs.forEach(log => {
      // Count by type
      stats.byType[log.type] = (stats.byType[log.type] || 0) + 1;

      // Count by level
      stats.byLevel[log.level] = (stats.byLevel[log.level] || 0) + 1;

      // Track errors
      if (log.level === 'error') {
        stats.errors.push({
          timestamp: log.timestamp,
          type: log.type,
          path: log.path,
          code: log.code,
          error: log.error
        });
      }

      // Track durations
      if (log.durationMs) {
        totalDuration += log.durationMs;
        durationCount++;
      }
    });

    stats.avgDurationMs = durationCount > 0
      ? Math.round(totalDuration / durationCount)
      : 0;

    return stats;
  },

  /**
   * Test an RPC call and return detailed diagnostics
   *
   * @param {string} path - API path to test
   * @param {object} payload - Request payload
   * @returns {Promise<object>} Test result with timing and diagnostics
   */
  async testRpc(path, payload = {}) {
    const startTime = Date.now();
    const logsBefore = window.__NU_LOGS__.length;

    console.group(`[NU_DIAG] Testing RPC: ${path}`);
    console.debug('Payload:', payload);

    try {
      const result = await NU.rpc(path, payload);
      const endTime = Date.now();
      const newLogs = window.__NU_LOGS__.slice(logsBefore);

      const diagnostic = {
        success: result.ok,
        path,
        payload,
        result,
        durationMs: endTime - startTime,
        logs: newLogs,
        timestamp: new Date().toISOString()
      };

      console.debug('Result:', result);
      console.debug('Duration:', diagnostic.durationMs, 'ms');
      console.debug('Logs generated:', newLogs.length);
      console.groupEnd();

      return diagnostic;

    } catch (error) {
      const endTime = Date.now();
      const newLogs = window.__NU_LOGS__.slice(logsBefore);

      const diagnostic = {
        success: false,
        path,
        payload,
        error: error.message,
        durationMs: endTime - startTime,
        logs: newLogs,
        timestamp: new Date().toISOString()
      };

      console.error('Error:', error);
      console.groupEnd();

      return diagnostic;
    }
  },

  /**
   * Run a quick health check
   *
   * @returns {Promise<object>} Health check results
   */
  async healthCheck() {
    console.group('[NU_DIAG] Health Check');

    const health = {
      sdk: {
        version: NU.VERSION,
        config: NU.getConfig(),
        pendingRequests: NU._pending.length
      },
      logs: {
        count: window.__NU_LOGS__.length,
        maxSize: NU._config.maxLogs
      },
      environment: {
        hostname: window.location?.hostname,
        protocol: window.location?.protocol,
        hasGoogleScript: !!window.google?.script?.run
      },
      timestamp: new Date().toISOString()
    };

    // Test connectivity with a simple ping
    try {
      const pingStart = Date.now();
      const pingResult = await NU.rpc('status', {});
      health.connectivity = {
        ok: pingResult.ok,
        durationMs: Date.now() - pingStart,
        response: pingResult.ok ? 'connected' : pingResult.code
      };
    } catch (e) {
      health.connectivity = {
        ok: false,
        error: e.message
      };
    }

    console.debug('Health:', health);
    console.groupEnd();

    return health;
  },

  /**
   * Export logs as JSON for debugging
   *
   * @returns {string} JSON string of all logs
   */
  exportLogs() {
    const exportData = {
      sdk: {
        version: NU.VERSION,
        config: NU.getConfig()
      },
      stats: NU_DIAG.getStats(),
      logs: window.__NU_LOGS__,
      exportedAt: new Date().toISOString()
    };

    return JSON.stringify(exportData, null, 2);
  },

  /**
   * Print a summary to console
   */
  printSummary() {
    const stats = NU_DIAG.getStats();
    console.group('[NU_DIAG] Summary');
    console.log('SDK Version:', NU.VERSION);
    console.log('Log Level:', NU._config.logLevel);
    console.log('Total Logs:', stats.totalLogs);
    console.log('By Type:', stats.byType);
    console.log('By Level:', stats.byLevel);
    console.log('Avg Duration:', stats.avgDurationMs, 'ms');
    if (stats.errors.length > 0) {
      console.warn('Recent Errors:', stats.errors.slice(-5));
    }
    console.groupEnd();
  }
};

// =============================================================================
// Auto-initialize SDK
// =============================================================================
NU._init();
</script>

  <script>
/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SharedUtils - Common utilities for all front-end pages
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * RESPONSIBILITY: This file provides UI utilities (alerts, dates, forms) ONLY.
 * It does NOT handle data entities or business logic - that belongs in Code.gs.
 *
 * WINDOW ADDITION: window.SharedUtils
 *
 * Dependencies: NUSDK.html (for NU.esc)
 * Used by: Public.html, Display.html, Poster.html, SharedReport.html, Admin.html
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * HELPER INDEX (keep updated when adding/removing functions):
 * ═══════════════════════════════════════════════════════════════════════════════
 *   showAlert(message, type, options)  → Alert notifications (Admin.html)
 *   showToast(message, type, duration) → Toast notifications (all surfaces)
 *   formatDate(dateInput, options)     → Date formatting (Admin.html)
 *   formatTime(timeStr)                → Time formatting (Admin.html)
 *   debounce(fn, delay)                → Event debouncing (Admin.html)
 *   copyToClipboard(text)              → Clipboard utility (Admin.html)
 *   validateUrl(url)                   → URL validation (Admin.html)
 *   sectionEnabled(settings, key)      → Section visibility check (Feature 4)
 *     Keys: schedule, standings, bracket, sponsors, video, map, gallery
 *
 * S12: StateRenderer - Unified error/empty/loading states (all surfaces)
 *   StateRenderer.showError(container, options)      → Error state
 *   StateRenderer.showEmpty(container, options)      → Empty state
 *   StateRenderer.showLoading(container, options)    → Loading state
 *   StateRenderer.showEventNotFound(container, opts) → Event not found
 *   StateRenderer.showNoData(container, opts)        → No data yet
 *   StateRenderer.showNetworkError(container, opts)  → Connection error
 *   StateRenderer.showUnauthorized(container, opts)  → Access denied
 *   StateRenderer.showFromError(container, err, opts)→ Auto-detect type
 *   ERROR_TYPES                                      → Standard error types
 *   classifyError(error)                             → Map error to type
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * @version 1.3.0
 */
window.SharedUtils = (function() {
  'use strict';

  // === Alert/Notification System ===

  /**
   * Shows a dismissible alert notification
   * @param {string} message - Alert message text
   * @param {string} type - Alert type: 'info', 'success', 'error', 'warning'
   * @param {Object} options - Optional configuration
   * @param {number} options.duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
   * @param {string} options.containerId - ID of alert container element
   */
  function showAlert(message, type = 'info', options = {}) {
    const {
      duration = 5000,
      containerId = 'alert-container'
    } = options;

    const container = document.getElementById(containerId);
    if (!container) {
      console.warn(`SharedUtils.showAlert: Container #${containerId} not found`);
      return;
    }

    const alert = document.createElement('div');
    alert.className = `alert alert-${type}`;
    alert.setAttribute('role', 'alert');

    // Create alert content with dismiss button
    const content = document.createElement('span');
    content.textContent = message;

    const dismissBtn = document.createElement('button');
    dismissBtn.type = 'button';
    dismissBtn.className = 'alert-dismiss';
    dismissBtn.innerHTML = '&times;';
    dismissBtn.setAttribute('aria-label', 'Dismiss');
    dismissBtn.onclick = () => alert.remove();

    alert.appendChild(content);
    alert.appendChild(dismissBtn);

    // Clear existing alerts and add new one
    container.innerHTML = '';
    container.appendChild(alert);

    // Auto-dismiss if duration > 0
    if (duration > 0) {
      setTimeout(() => {
        if (alert.parentNode) {
          alert.classList.add('alert-fade-out');
          setTimeout(() => alert.remove(), 300);
        }
      }, duration);
    }

    return alert;
  }

  // === Date Formatting ===

  /**
   * Formats a date string to a human-readable format
   * @param {string|Date} dateInput - Date string or Date object
   * @param {Object} options - Intl.DateTimeFormat options
   * @returns {string} Formatted date string
   */
  function formatDate(dateInput, options = {}) {
    if (!dateInput) return 'Date TBD';

    try {
      const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
      if (isNaN(date.getTime())) return 'Invalid Date';

      const defaultOptions = {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      };

      return date.toLocaleDateString('en-US', { ...defaultOptions, ...options });
    } catch (e) {
      return 'Date TBD';
    }
  }

  /**
   * Formats a date string to a relative time (e.g., "2 days ago")
   * @param {string|Date} dateInput - Date string or Date object
   * @returns {string} Relative time string
   */
  function formatRelativeTime(dateInput) {
    if (!dateInput) return '';

    try {
      const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
      if (isNaN(date.getTime())) return '';

      const now = new Date();
      const diffMs = now - date;
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

      if (diffDays === 0) return 'Today';
      if (diffDays === 1) return 'Yesterday';
      if (diffDays < 7) return `${diffDays} days ago`;
      if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
      if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
      return `${Math.floor(diffDays / 365)} years ago`;
    } catch (e) {
      return '';
    }
  }

  // === Form Utilities ===

  /**
   * Validates a form and returns validation status
   * @param {string|HTMLFormElement} formIdOrEl - Form ID or form element
   * @returns {Object} { valid: boolean, errors: Array<{field, message}> }
   */
  function validateForm(formIdOrEl) {
    const form = typeof formIdOrEl === 'string'
      ? document.getElementById(formIdOrEl)
      : formIdOrEl;

    if (!form) return { valid: false, errors: [{ field: null, message: 'Form not found' }] };

    const errors = [];
    const requiredInputs = form.querySelectorAll('[required]');

    requiredInputs.forEach(input => {
      // Clear previous error state
      input.classList.remove('form-input-error');

      if (!input.value.trim()) {
        errors.push({
          field: input.name || input.id,
          message: `${input.labels?.[0]?.textContent || input.name || 'Field'} is required`
        });
        input.classList.add('form-input-error');
      }
    });

    // Validate email fields
    form.querySelectorAll('input[type="email"]').forEach(input => {
      if (input.value && !isValidEmail(input.value)) {
        errors.push({ field: input.name || input.id, message: 'Invalid email address' });
        input.classList.add('form-input-error');
      }
    });

    // Validate URL fields
    form.querySelectorAll('input[type="url"]').forEach(input => {
      if (input.value && !isValidUrl(input.value)) {
        errors.push({ field: input.name || input.id, message: 'Invalid URL' });
        input.classList.add('form-input-error');
      }
    });

    return { valid: errors.length === 0, errors };
  }

  /**
   * Validates an email address
   * @param {string} email - Email to validate
   * @returns {boolean} True if valid
   */
  function isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  /**
   * Validates a URL
   * @param {string} url - URL to validate
   * @returns {boolean} True if valid
   */
  function isValidUrl(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  // === Loading State Management ===

  /**
   * Executes an async function with loading state management
   * @param {Function} asyncFn - Async function to execute
   * @param {Object} options - Configuration options
   * @param {string} options.loadingElId - ID of loading indicator element
   * @param {string} options.emptyElId - ID of empty state element
   * @param {string} options.contentElId - ID of content container element
   * @param {HTMLButtonElement} options.button - Submit button to disable
   * @returns {Promise<any>} Result of asyncFn
   */
  async function withLoadingState(asyncFn, options = {}) {
    const { loadingElId, emptyElId, contentElId, button } = options;

    const loadingEl = loadingElId ? document.getElementById(loadingElId) : null;
    const emptyEl = emptyElId ? document.getElementById(emptyElId) : null;
    const contentEl = contentElId ? document.getElementById(contentElId) : null;

    // Show loading state
    if (loadingEl) loadingEl.style.display = 'block';
    if (emptyEl) emptyEl.style.display = 'none';
    if (contentEl) contentEl.style.display = 'none';
    if (button) button.disabled = true;

    try {
      const result = await asyncFn();
      return result;
    } finally {
      // Hide loading state
      if (loadingEl) loadingEl.style.display = 'none';
      if (button) button.disabled = false;
    }
  }

  // === DOM Utilities ===

  /**
   * Toggles element visibility
   * @param {string} elementId - ID of element to toggle
   * @param {string} className - Class to toggle (default: 'hidden')
   */
  function toggleElement(elementId, className = 'hidden') {
    const el = document.getElementById(elementId);
    if (el) el.classList.toggle(className);
  }

  /**
   * Shows an element by removing hidden class
   * @param {string} elementId - ID of element to show
   */
  function showElement(elementId) {
    const el = document.getElementById(elementId);
    if (el) el.style.display = 'block';
  }

  /**
   * Hides an element by setting display none
   * @param {string} elementId - ID of element to hide
   */
  function hideElement(elementId) {
    const el = document.getElementById(elementId);
    if (el) el.style.display = 'none';
  }

  // === XSS Prevention (delegating to NU.esc) ===

  /**
   * Escapes HTML special characters to prevent XSS
   * Delegates to NU.esc if available, otherwise uses local implementation
   *
   * IMPORTANT: Prefer using NU.esc() directly when NUSDK is included.
   * This is provided for backwards compatibility.
   *
   * @param {string} unsafe - String to escape
   * @returns {string} HTML-safe string
   */
  function esc(unsafe) {
    // Delegate to NU.esc if available (canonical implementation)
    if (window.NU && typeof window.NU.esc === 'function') {
      return window.NU.esc(unsafe);
    }
    // Fallback implementation (should rarely be used)
    if (!unsafe) return '';
    return String(unsafe).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  }

  // === Debounce/Throttle ===

  /**
   * Creates a debounced version of a function
   * @param {Function} fn - Function to debounce
   * @param {number} delay - Delay in milliseconds
   * @returns {Function} Debounced function
   */
  function debounce(fn, delay = 300) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  /**
   * Creates a throttled version of a function
   * @param {Function} fn - Function to throttle
   * @param {number} limit - Minimum time between calls in milliseconds
   * @returns {Function} Throttled function
   */
  function throttle(fn, limit = 100) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        fn.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  // === Toast Notifications (non-blocking) ===

  /**
   * Shows a brief toast notification (non-blocking alternative to alert())
   * @param {string} message - Toast message
   * @param {string} type - 'success', 'error', 'info', 'warning'
   * @param {number} duration - Auto-dismiss duration in ms (default: 3000)
   */
  function showToast(message, type = 'info', duration = 3000) {
    // Remove existing toast
    const existing = document.querySelector('.shared-toast');
    if (existing) existing.remove();

    const toast = document.createElement('div');
    toast.className = `shared-toast shared-toast-${type}`;
    toast.setAttribute('role', 'status');
    toast.textContent = message;

    // Inject minimal styles if not present
    if (!document.getElementById('shared-toast-styles')) {
      const style = document.createElement('style');
      style.id = 'shared-toast-styles';
      style.textContent = `
        .shared-toast {
          position: fixed; bottom: 20px; right: 20px;
          padding: 12px 20px; border-radius: 8px;
          font-size: 14px; font-weight: 500; z-index: 9999;
          animation: toast-slide-in 0.3s ease;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .shared-toast-success { background: #10b981; color: white; }
        .shared-toast-error { background: #ef4444; color: white; }
        .shared-toast-info { background: #3b82f6; color: white; }
        .shared-toast-warning { background: #f59e0b; color: white; }
        @keyframes toast-slide-in { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(toast);

    // Auto-dismiss
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(20px)';
      toast.style.transition = 'all 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  // === StateRenderer (unified error/empty/loading states) ===

  /**
   * Standard error types for consistent UX across all surfaces
   * S12: Error & Empty State Polish
   * S13: Graceful Degradation - added SERVICE_UNAVAILABLE, TIMEOUT
   * Story 4: Added CONFIGURATION_ISSUE for 4xx errors and GAS_UPSTREAM_NON_JSON
   */
  const ERROR_TYPES = {
    EVENT_NOT_FOUND: 'event_not_found',
    NO_DATA: 'no_data',
    NETWORK_ERROR: 'network_error',
    UNAUTHORIZED: 'unauthorized',
    SERVICE_UNAVAILABLE: 'service_unavailable',
    TIMEOUT: 'timeout',
    CONFIGURATION_ISSUE: 'configuration_issue',  // Story 4: Backend misconfiguration
    GENERIC: 'generic'
  };

  /**
   * Maps raw error messages/codes to user-friendly error types
   * Prevents leaking internal details (JSON, stack traces, etc.)
   * S13: Added SERVICE_UNAVAILABLE, TIMEOUT detection
   * Story 4: Added CONFIGURATION_ISSUE detection for 4xx and GAS errors
   *
   * @param {string|Error|Object} error - Raw error message, Error object, or {code, message, status, errorCode}
   * @returns {string} User-friendly error type from ERROR_TYPES
   */
  function classifyError(error) {
    // Handle error objects with code property (from NU.safeRpc)
    const code = String(error?.code || '').toUpperCase();
    const errorCode = String(error?.errorCode || '').toUpperCase();
    const status = error?.status;
    const msg = String(error?.message || error || '').toLowerCase();

    // Story 4: Check for configuration issues first (GAS upstream errors or 4xx status)
    // GAS_UPSTREAM_NON_JSON indicates backend returned non-JSON (likely misconfigured)
    if (errorCode === 'GAS_UPSTREAM_NON_JSON' || code === 'GAS_UPSTREAM_NON_JSON') {
      return ERROR_TYPES.CONFIGURATION_ISSUE;
    }

    // Story 4: 4xx status codes indicate client/configuration errors
    if (status && status >= 400 && status < 500) {
      // 404 is special - treat as not found
      if (status === 404) {
        return ERROR_TYPES.EVENT_NOT_FOUND;
      }
      // 401/403 are auth errors
      if (status === 401 || status === 403) {
        return ERROR_TYPES.UNAUTHORIZED;
      }
      // Other 4xx are configuration issues
      return ERROR_TYPES.CONFIGURATION_ISSUE;
    }

    // Story 4: 5xx status codes are temporary server issues
    if (status && status >= 500 && status < 600) {
      return ERROR_TYPES.SERVICE_UNAVAILABLE;
    }

    // Check error codes (most reliable)
    if (code === 'SERVICE_UNAVAILABLE' || code === 'INTERNAL') {
      return ERROR_TYPES.SERVICE_UNAVAILABLE;
    }
    if (code === 'TIMEOUT') {
      return ERROR_TYPES.TIMEOUT;
    }
    if (code === 'NOT_FOUND') {
      return ERROR_TYPES.EVENT_NOT_FOUND;
    }
    if (code === 'UNAUTHORIZED') {
      return ERROR_TYPES.UNAUTHORIZED;
    }
    if (code === 'NETWORK_ERROR') {
      return ERROR_TYPES.NETWORK_ERROR;
    }

    // Fallback to message-based detection
    if (msg.includes('not found') || msg.includes('404') || msg.includes('invalid') || msg.includes('no event')) {
      return ERROR_TYPES.EVENT_NOT_FOUND;
    }
    if (msg.includes('unauthorized') || msg.includes('403') || msg.includes('permission')) {
      return ERROR_TYPES.UNAUTHORIZED;
    }
    if (msg.includes('service unavailable') || msg.includes('503') || msg.includes('temporary issue') || msg.includes('temporary problem')) {
      return ERROR_TYPES.SERVICE_UNAVAILABLE;
    }
    if (msg.includes('timeout') || msg.includes('504') || msg.includes('took too long') || msg.includes('timed out')) {
      return ERROR_TYPES.TIMEOUT;
    }
    if (msg.includes('network') || msg.includes('failed to fetch') || msg.includes('connection') || msg.includes('offline')) {
      return ERROR_TYPES.NETWORK_ERROR;
    }
    if (msg.includes('no data') || msg.includes('empty') || msg.includes('nothing')) {
      return ERROR_TYPES.NO_DATA;
    }
    // Story 4: Check for configuration-related keywords
    if (msg.includes('configuration') || msg.includes('config') || msg.includes('misconfigured')) {
      return ERROR_TYPES.CONFIGURATION_ISSUE;
    }
    return ERROR_TYPES.GENERIC;
  }

  /**
   * StateRenderer - Unified error/empty/loading state rendering
   * S12: Consistent UX across Public, Display, Poster, SharedReport, Admin
   */
  const StateRenderer = {
    // Expose error types for external use
    ERROR_TYPES,
    classifyError,

    /**
     * Render error state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { title, message, onRetry, hint, tvMode }
     */
    showError(container, options = {}) {
      const {
        title = 'Something Went Wrong',
        message = 'Please try again.',
        onRetry = null,
        hint = null,
        tvMode = false
      } = options;

      const stateClass = tvMode ? 'error-state-tv' : 'error-state';
      const iconClass = tvMode ? 'error-icon' : 'error-state-icon';

      container.innerHTML = `
        <div class="${stateClass}">
          <div class="${iconClass}">⚠️</div>
          <h3>${esc(title)}</h3>
          <p>${esc(message)}</p>
          ${hint ? `<p style="font-size: 0.85rem; color: ${tvMode ? '#9ca3af' : '#991b1b'}; margin-top: 8px;">${esc(hint)}</p>` : ''}
          ${onRetry ? '<button class="btn-retry">🔄 Try Again</button>' : ''}
        </div>
      `;
      if (onRetry) {
        container.querySelector('.btn-retry')?.addEventListener('click', onRetry);
      }
    },

    /**
     * Render empty state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { icon, title, message, hint, backUrl, backLabel, tvMode }
     */
    showEmpty(container, options = {}) {
      const {
        icon = '📭',
        title = 'Nothing Here',
        message = '',
        hint = null,
        backUrl = null,
        backLabel = '← Go Back',
        tvMode = false
      } = options;

      const stateClass = tvMode ? 'error-state-tv' : 'empty-state';
      const iconClass = tvMode ? 'error-icon' : 'empty-state-icon';

      container.innerHTML = `
        <div class="${stateClass}">
          <div class="${iconClass}">${icon}</div>
          <h3>${esc(title)}</h3>
          ${message ? `<p>${esc(message)}</p>` : ''}
          ${hint ? `<p style="font-size: 0.85rem; color: #94a3b8; margin-top: 12px;">${esc(hint)}</p>` : ''}
          ${backUrl ? `<a href="${esc(backUrl)}" class="btn-secondary">${esc(backLabel)}</a>` : ''}
        </div>
      `;
    },

    /**
     * Render loading state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { message }
     */
    showLoading(container, options = {}) {
      const { message = 'Loading...' } = options;
      container.innerHTML = `
        <div class="loading-state">
          <div class="loading-spinner"></div>
          <p>${esc(message)}</p>
        </div>
      `;
    },

    // === Convenience Methods for Common Scenarios (S12) ===

    /**
     * Show "Event Not Found" state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { backUrl, tvMode }
     */
    showEventNotFound(container, options = {}) {
      const { backUrl = null, tvMode = false } = options;
      this.showEmpty(container, {
        icon: '🔍',
        title: 'Event Not Found',
        message: 'We couldn\'t find this event. The link may be outdated, the event ID might be incorrect, or the event may have been removed.',
        hint: 'Double-check the URL or return to the events list to find what you\'re looking for.',
        backUrl,
        backLabel: '← View All Events',
        tvMode
      });
    },

    /**
     * Show "No Data Yet" state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { context, backUrl, tvMode }
     */
    showNoData(container, options = {}) {
      const { context = 'content', backUrl = null, tvMode = false } = options;
      const contextMessages = {
        events: 'Check back soon for new events, or contact the organizer for more information.',
        sponsors: 'No sponsors to display yet. Sponsor information will appear here once configured.',
        schedule: 'The event schedule will appear here once it\'s available.',
        standings: 'Standings will appear here once the competition begins.',
        analytics: 'Once attendees start interacting with your content, you\'ll see engagement data here.',
        content: 'This event exists but doesn\'t have any content to display yet. Check back soon!'
      };
      this.showEmpty(container, {
        icon: '📭',
        title: 'No Data Yet',
        message: contextMessages[context] || contextMessages.content,
        backUrl,
        tvMode
      });
    },

    /**
     * Show network/connection error state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode }
     */
    showNetworkError(container, options = {}) {
      const { onRetry = null, tvMode = false } = options;
      this.showError(container, {
        title: 'Connection Problem',
        message: 'We\'re having trouble connecting right now. This might be a temporary issue.',
        hint: 'Please check your internet connection and try again.',
        onRetry,
        tvMode
      });
    },

    /**
     * Show unauthorized/permission error state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { backUrl, tvMode }
     */
    showUnauthorized(container, options = {}) {
      const { backUrl = null, tvMode = false } = options;
      this.showError(container, {
        title: 'Access Denied',
        message: 'You don\'t have permission to view this content.',
        hint: 'Please check that you have the correct access link.',
        onRetry: null,
        tvMode
      });
    },

    /**
     * Show temporary service issue state (S13: Graceful Degradation)
     * For 5xx errors from upstream, temporary outages, etc.
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode, corrId }
     */
    showTemporaryIssue(container, options = {}) {
      const { onRetry = null, tvMode = false, corrId = null } = options;
      this.showError(container, {
        title: 'Temporary Issue',
        message: 'We\'re having a temporary issue loading this event.',
        hint: corrId
          ? `Please refresh or try again in a minute. (Ref: ${esc(corrId)})`
          : 'Please refresh or try again in a minute.',
        onRetry,
        tvMode
      });
    },

    /**
     * Show timeout error state (S13: Graceful Degradation)
     * For requests that took too long
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode }
     */
    showTimeout(container, options = {}) {
      const { onRetry = null, tvMode = false } = options;
      this.showError(container, {
        title: 'Taking Too Long',
        message: 'The page is taking longer than expected to load.',
        hint: 'This might be a temporary issue. Please try again.',
        onRetry,
        tvMode
      });
    },

    /**
     * Show configuration issue state (Story 4: Frontend Error Handling)
     * For 4xx errors and GAS_UPSTREAM_NON_JSON - indicates backend misconfiguration
     *
     * Behavior:
     * - Production: Shows user-friendly message without technical details
     * - Staging: Shows expandable diagnostic panel with status, errorCode
     *
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode, error }
     */
    showConfigurationIssue(container, options = {}) {
      const { onRetry = null, tvMode = false, error = {} } = options;
      const isStaging = window.NU?.isStaging?.() || false;

      const stateClass = tvMode ? 'error-state-tv' : 'error-state config-issue-state';
      const iconClass = tvMode ? 'error-icon' : 'error-state-icon';

      // User-friendly message for all environments
      const title = 'Configuration Issue';
      const message = 'We\'re setting this event up. Try again later.';

      // Build diagnostic info for staging only
      let diagnosticHtml = '';
      if (isStaging && (error.status || error.errorCode || error.code)) {
        const status = error.status || 'N/A';
        const errorCode = error.errorCode || error.code || 'N/A';
        const corrId = error.corrId || 'N/A';

        diagnosticHtml = `
          <details class="diagnostic-panel" data-testid="diagnostic-panel">
            <summary class="diagnostic-toggle">Show Diagnostics</summary>
            <div class="diagnostic-content">
              <div class="diagnostic-row"><span class="diagnostic-label">Status:</span> <code>${esc(String(status))}</code></div>
              <div class="diagnostic-row"><span class="diagnostic-label">Error Code:</span> <code>${esc(String(errorCode))}</code></div>
              ${corrId !== 'N/A' ? `<div class="diagnostic-row"><span class="diagnostic-label">Correlation ID:</span> <code>${esc(String(corrId))}</code></div>` : ''}
              ${error.message ? `<div class="diagnostic-row"><span class="diagnostic-label">Message:</span> <code>${esc(String(error.message))}</code></div>` : ''}
            </div>
          </details>
        `;
      }

      container.innerHTML = `
        <div class="${stateClass}" data-testid="config-issue-card">
          <div class="${iconClass}">⚙️</div>
          <h3>${esc(title)}</h3>
          <p>${esc(message)}</p>
          ${diagnosticHtml}
          ${onRetry ? '<button class="btn-retry">🔄 Try Again</button>' : ''}
        </div>
      `;

      if (onRetry) {
        container.querySelector('.btn-retry')?.addEventListener('click', onRetry);
      }
    },

    /**
     * Auto-detect error type and show appropriate state
     * S13: Updated to handle SERVICE_UNAVAILABLE, TIMEOUT
     * Story 4: Added CONFIGURATION_ISSUE handling with staging diagnostics
     *
     * @param {HTMLElement} container - Target container
     * @param {string|Error|Object} error - Raw error, Error object, or {code, message, corrId, status, errorCode}
     * @param {Object} options - { onRetry, backUrl, tvMode }
     */
    showFromError(container, error, options = {}) {
      const { onRetry = null, backUrl = null, tvMode = false } = options;
      const errorType = classifyError(error);
      const corrId = error?.corrId || null;

      switch (errorType) {
        case ERROR_TYPES.EVENT_NOT_FOUND:
          this.showEventNotFound(container, { backUrl, tvMode });
          break;
        case ERROR_TYPES.NO_DATA:
          this.showNoData(container, { backUrl, tvMode });
          break;
        case ERROR_TYPES.NETWORK_ERROR:
          this.showNetworkError(container, { onRetry, tvMode });
          break;
        case ERROR_TYPES.UNAUTHORIZED:
          this.showUnauthorized(container, { backUrl, tvMode });
          break;
        case ERROR_TYPES.SERVICE_UNAVAILABLE:
          this.showTemporaryIssue(container, { onRetry, tvMode, corrId });
          break;
        case ERROR_TYPES.TIMEOUT:
          this.showTimeout(container, { onRetry, tvMode });
          break;
        case ERROR_TYPES.CONFIGURATION_ISSUE:
          // Story 4: Show configuration issue with staging diagnostics
          this.showConfigurationIssue(container, { onRetry, tvMode, error });
          break;
        default:
          this.showError(container, {
            title: 'Something Went Wrong',
            message: 'We couldn\'t load this content right now. This might be a temporary issue.',
            hint: corrId
              ? `Please try again in a moment. (Ref: ${esc(corrId)})`
              : 'Please try again in a moment.',
            onRetry,
            tvMode
          });
      }
    }
  };

  // === EVENT_CONTRACT.md v2.0 Support ===

  /**
   * Checks if an event section is enabled via settings
   * Extracted from Display.html and Poster.html (D-008)
   * Trust the contract - never invent flags
   *
   * Feature 4: Template-Aware Section Toggles - added showVideo, showMap, showGallery
   *
   * @param {Object} settings - Event settings object
   * @param {string} key - Section key: 'schedule', 'standings', 'bracket', 'sponsors', 'video', 'map', 'gallery'
   * @returns {boolean} True if section is enabled
   */
  function sectionEnabled(settings, key) {
    if (!settings) return false;
    switch (key) {
      // Data sections (require explicit true)
      case 'schedule': return settings.showSchedule === true;
      case 'standings': return settings.showStandings === true;
      case 'bracket': return settings.showBracket === true;
      case 'sponsors': return settings.showSponsors === true;
      // Content sections (default true for backwards compat - Feature 4)
      case 'video': return settings.showVideo !== false;
      case 'map': return settings.showMap !== false;
      case 'gallery': return settings.showGallery !== false;
      default: return false;
    }
  }

  // === Public API ===
  return {
    // Alerts
    showAlert,

    // Toast (non-blocking)
    showToast,

    // State rendering (S12: Enhanced with convenience methods)
    StateRenderer,
    ERROR_TYPES,
    classifyError,

    // Date formatting
    formatDate,
    formatRelativeTime,

    // Form utilities
    validateForm,
    isValidEmail,
    isValidUrl,

    // Loading state
    withLoadingState,

    // DOM utilities
    toggleElement,
    showElement,
    hideElement,

    // XSS (delegates to NU.esc)
    esc,

    // Utility functions
    debounce,
    throttle,

    // EVENT_CONTRACT helpers
    sectionEnabled
  };
})();
</script>

  <!--
================================================================================
GlobalErrorHandler.html - Global Error Handling for MVP Surfaces
================================================================================
Story 4.3: Graceful Error Handling in UI

RESPONSIBILITY: This file provides global error handling for client-side JavaScript.
- Catches uncaught exceptions (window.onerror)
- Catches unhandled promise rejections (unhandledrejection)
- Provides error boundary wrapper for async operations
- Shows user-friendly error dialogs
- Implements retry logic with exponential backoff
- Logs errors for developer diagnostics

WINDOW ADDITIONS:
- window.GlobalErrorHandler - Main error handler object

Dependencies: NUSDK.html (for NU._log), SharedUtils.html (for showToast)
Used by: Admin.html, Public.html, Display.html, Poster.html, SharedReport.html

USAGE:
  // Wrap async operations with error boundary
  await GlobalErrorHandler.withErrorBoundary(async () => {
    const res = await NU.rpc('api_getData', payload);
    if (!res.ok) throw res;
    return res.value;
  }, {
    context: 'loading events',
    onError: (err) => SharedUtils.StateRenderer.showFromError(container, err),
    retry: true
  });

  // Manual error reporting
  GlobalErrorHandler.reportError(error, { context: 'user action', userId: '123' });

  // Show error dialog
  GlobalErrorHandler.showErrorDialog({
    title: 'Unable to Save',
    message: 'Your changes could not be saved. Please try again.',
    onRetry: () => saveData()
  });

================================================================================
-->
<script>
(function() {
  'use strict';

  // =============================================================================
  // Configuration
  // =============================================================================
  const CONFIG = {
    // Maximum errors to log before throttling (prevent log spam)
    maxErrorsPerMinute: 10,
    // Error throttle window in ms
    throttleWindow: 60000,
    // Default retry attempts
    defaultRetryAttempts: 3,
    // Base delay for exponential backoff (ms)
    baseRetryDelay: 1000,
    // Maximum retry delay (ms)
    maxRetryDelay: 16000,
    // Errors to ignore (browser extensions, etc.)
    ignoredErrorPatterns: [
      /script error/i,
      /extension/i,
      /chrome-extension/i,
      /moz-extension/i,
      /ResizeObserver loop/i,
      /Loading chunk/i
    ],
    // Auto-dismiss toast errors after this many ms (0 = don't auto-dismiss)
    toastDuration: 5000
  };

  // =============================================================================
  // Error Tracking State
  // =============================================================================
  const errorState = {
    errorCount: 0,
    lastErrorReset: Date.now(),
    recentErrors: [], // Rolling buffer of recent errors for diagnostics
    maxRecentErrors: 50,
    isDialogOpen: false
  };

  // =============================================================================
  // Helper Functions
  // =============================================================================

  /**
   * Check if error should be ignored (browser extensions, etc.)
   * @param {string} message - Error message
   * @param {string} source - Error source URL
   * @returns {boolean} True if error should be ignored
   */
  function shouldIgnoreError(message, source) {
    const combined = `${message || ''} ${source || ''}`;
    return CONFIG.ignoredErrorPatterns.some(pattern => pattern.test(combined));
  }

  /**
   * Check if we're being throttled due to too many errors
   * @returns {boolean} True if throttled
   */
  function isThrottled() {
    const now = Date.now();
    if (now - errorState.lastErrorReset > CONFIG.throttleWindow) {
      errorState.errorCount = 0;
      errorState.lastErrorReset = now;
    }
    return errorState.errorCount >= CONFIG.maxErrorsPerMinute;
  }

  /**
   * Sanitize error message for user display (remove internal details)
   * @param {string} message - Raw error message
   * @returns {string} Sanitized message
   */
  function sanitizeMessage(message) {
    if (!message) return 'An unexpected error occurred';

    // Remove file paths, line numbers, stack traces
    let sanitized = String(message)
      .replace(/at\s+[\w.]+\s+\([^)]+\)/g, '') // Remove stack trace lines
      .replace(/https?:\/\/[^\s]+/g, '[url]')   // Remove URLs
      .replace(/:\d+:\d+/g, '')                  // Remove line:col numbers
      .replace(/\s+/g, ' ')                      // Normalize whitespace
      .trim();

    // If message is too technical, use generic message
    if (sanitized.length > 200 || /\{.*\}/.test(sanitized) || /\[.*\]/.test(sanitized)) {
      return 'An unexpected error occurred';
    }

    return sanitized || 'An unexpected error occurred';
  }

  /**
   * Extract error details for logging (internal use only)
   * @param {Error|string|Object} error - Error to extract details from
   * @returns {Object} Error details
   */
  function extractErrorDetails(error) {
    if (!error) {
      return { message: 'Unknown error', code: 'UNKNOWN', stack: null };
    }

    if (typeof error === 'string') {
      return { message: error, code: 'STRING_ERROR', stack: null };
    }

    return {
      message: error.message || error.msg || String(error),
      code: error.code || 'UNKNOWN',
      corrId: error.corrId || null,
      stack: error.stack || null,
      name: error.name || 'Error'
    };
  }

  /**
   * Log error to NUSDK rolling buffer
   * @param {Object} errorDetails - Error details
   * @param {Object} context - Additional context
   */
  function logError(errorDetails, context = {}) {
    // Check throttling
    if (isThrottled()) {
      console.warn('[GlobalErrorHandler] Error logging throttled due to high error rate');
      return;
    }

    errorState.errorCount++;

    const entry = {
      timestamp: new Date().toISOString(),
      type: 'global_error',
      ...errorDetails,
      context,
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    // Add to recent errors buffer
    errorState.recentErrors.push(entry);
    if (errorState.recentErrors.length > errorState.maxRecentErrors) {
      errorState.recentErrors.shift();
    }

    // Log via NUSDK if available
    if (window.NU && typeof window.NU._log === 'function') {
      window.NU._log('error', 'global_error', entry);
    } else {
      console.error('[GlobalErrorHandler]', entry);
    }
  }

  // =============================================================================
  // Error Dialog UI
  // =============================================================================

  /**
   * Inject error dialog styles (once)
   */
  function injectDialogStyles() {
    if (document.getElementById('global-error-dialog-styles')) return;

    const style = document.createElement('style');
    style.id = 'global-error-dialog-styles';
    style.textContent = `
      .global-error-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fade-in 0.2s ease;
      }

      .global-error-dialog {
        background: #fff;
        border-radius: 16px;
        padding: 32px;
        max-width: 420px;
        width: 90%;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        animation: slide-up 0.3s ease;
      }

      .global-error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .global-error-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: #1e293b;
        margin: 0 0 12px;
      }

      .global-error-message {
        font-size: 1rem;
        color: #64748b;
        margin: 0 0 24px;
        line-height: 1.5;
      }

      .global-error-details {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 12px;
        font-family: monospace;
        font-size: 0.8rem;
        color: #64748b;
        margin-bottom: 24px;
        text-align: left;
        word-break: break-word;
      }

      .global-error-actions {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .global-error-btn {
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
      }

      .global-error-btn-primary {
        background: #2563eb;
        color: #fff;
      }

      .global-error-btn-primary:hover {
        background: #1d4ed8;
      }

      .global-error-btn-secondary {
        background: #f1f5f9;
        color: #475569;
      }

      .global-error-btn-secondary:hover {
        background: #e2e8f0;
      }

      .global-error-support {
        margin-top: 16px;
        font-size: 0.85rem;
        color: #94a3b8;
      }

      .global-error-support a {
        color: #2563eb;
        text-decoration: none;
      }

      .global-error-support a:hover {
        text-decoration: underline;
      }

      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes slide-up {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
    `;
    document.head.appendChild(style);
  }

  /**
   * Show error dialog to user
   * @param {Object} options - Dialog options
   */
  function showErrorDialog(options = {}) {
    const {
      title = 'Oops, Something Went Wrong',
      message = 'We encountered an unexpected error. Please try again.',
      icon = '😕',
      showRetry = true,
      showDismiss = true,
      showDetails = false,
      details = null,
      corrId = null,
      onRetry = null,
      onDismiss = null,
      supportEmail = null
    } = options;

    // Don't show multiple dialogs
    if (errorState.isDialogOpen) return;
    errorState.isDialogOpen = true;

    injectDialogStyles();

    const overlay = document.createElement('div');
    overlay.className = 'global-error-overlay';
    overlay.setAttribute('role', 'dialog');
    overlay.setAttribute('aria-modal', 'true');
    overlay.setAttribute('aria-labelledby', 'error-dialog-title');

    let detailsHtml = '';
    if (showDetails && (details || corrId)) {
      const detailText = corrId ? `Reference: ${corrId}` : details;
      detailsHtml = `<div class="global-error-details">${escapeHtml(detailText)}</div>`;
    }

    let actionsHtml = '';
    if (showRetry) {
      actionsHtml += '<button class="global-error-btn global-error-btn-primary" data-action="retry">Try Again</button>';
    }
    if (showDismiss) {
      actionsHtml += '<button class="global-error-btn global-error-btn-secondary" data-action="dismiss">Dismiss</button>';
    }

    let supportHtml = '';
    if (supportEmail || corrId) {
      supportHtml = '<div class="global-error-support">';
      if (corrId) {
        supportHtml += `Reference: <code>${escapeHtml(corrId)}</code>`;
      }
      if (supportEmail) {
        supportHtml += corrId ? '<br>' : '';
        supportHtml += `Need help? <a href="mailto:${escapeHtml(supportEmail)}">Contact support</a>`;
      }
      supportHtml += '</div>';
    }

    overlay.innerHTML = `
      <div class="global-error-dialog">
        <div class="global-error-icon">${icon}</div>
        <h2 class="global-error-title" id="error-dialog-title">${escapeHtml(title)}</h2>
        <p class="global-error-message">${escapeHtml(message)}</p>
        ${detailsHtml}
        <div class="global-error-actions">${actionsHtml}</div>
        ${supportHtml}
      </div>
    `;

    // Handle button clicks
    overlay.addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      if (action === 'retry') {
        closeDialog();
        if (onRetry) onRetry();
      } else if (action === 'dismiss' || e.target === overlay) {
        closeDialog();
        if (onDismiss) onDismiss();
      }
    });

    // Handle escape key
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        closeDialog();
        if (onDismiss) onDismiss();
      }
    };
    document.addEventListener('keydown', handleEscape);

    function closeDialog() {
      errorState.isDialogOpen = false;
      document.removeEventListener('keydown', handleEscape);
      overlay.remove();
    }

    document.body.appendChild(overlay);

    // Focus the first button for accessibility
    const firstBtn = overlay.querySelector('button');
    if (firstBtn) firstBtn.focus();
  }

  /**
   * Show error toast (non-modal notification)
   * @param {string} message - Error message
   * @param {Object} options - Toast options
   */
  function showErrorToast(message, options = {}) {
    const { duration = CONFIG.toastDuration } = options;

    // Use SharedUtils.showToast if available
    if (window.SharedUtils && typeof window.SharedUtils.showToast === 'function') {
      window.SharedUtils.showToast(sanitizeMessage(message), 'error', duration);
    } else {
      // Fallback to console
      console.error('[GlobalErrorHandler Toast]', message);
    }
  }

  /**
   * Escape HTML for safe display
   * @param {string} str - String to escape
   * @returns {string} Escaped string
   */
  function escapeHtml(str) {
    if (window.NU && typeof window.NU.esc === 'function') {
      return window.NU.esc(str);
    }
    if (!str) return '';
    return String(str).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  }

  // =============================================================================
  // Retry Logic
  // =============================================================================

  /**
   * Execute with retry and exponential backoff
   * @param {Function} fn - Async function to execute
   * @param {Object} options - Retry options
   * @returns {Promise<any>} Result of fn
   */
  async function withRetry(fn, options = {}) {
    const {
      attempts = CONFIG.defaultRetryAttempts,
      baseDelay = CONFIG.baseRetryDelay,
      maxDelay = CONFIG.maxRetryDelay,
      shouldRetry = (err) => err?.code === 'NETWORK_ERROR' || err?.code === 'TIMEOUT',
      onRetryAttempt = null
    } = options;

    let lastError;

    for (let attempt = 1; attempt <= attempts; attempt++) {
      try {
        return await fn();
      } catch (err) {
        lastError = err;

        // Check if we should retry
        if (attempt === attempts || !shouldRetry(err)) {
          throw err;
        }

        // Calculate delay with exponential backoff + jitter
        const delay = Math.min(
          baseDelay * Math.pow(2, attempt - 1) + Math.random() * 1000,
          maxDelay
        );

        if (onRetryAttempt) {
          onRetryAttempt(attempt, attempts, delay, err);
        }

        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }

  // =============================================================================
  // Error Boundary Wrapper
  // =============================================================================

  /**
   * Wrap async operations with error boundary
   * @param {Function} fn - Async function to execute
   * @param {Object} options - Error boundary options
   * @returns {Promise<any>} Result of fn or null on error
   */
  async function withErrorBoundary(fn, options = {}) {
    const {
      context = 'operation',
      onError = null,
      showToast = true,
      showDialog = false,
      retry = false,
      retryOptions = {},
      fallbackValue = null,
      rethrow = false
    } = options;

    try {
      if (retry) {
        return await withRetry(fn, retryOptions);
      }
      return await fn();

    } catch (err) {
      const errorDetails = extractErrorDetails(err);

      // Log the error
      logError(errorDetails, { context, retry });

      // Notify via callback
      if (onError) {
        onError(err);
      }

      // Show UI notification
      if (showDialog) {
        showErrorDialog({
          title: 'Unable to Complete Action',
          message: `We couldn't complete ${context}. Please try again.`,
          corrId: errorDetails.corrId,
          onRetry: retry ? () => withErrorBoundary(fn, options) : null
        });
      } else if (showToast) {
        showErrorToast(`Unable to ${context}. Please try again.`);
      }

      if (rethrow) {
        throw err;
      }

      return fallbackValue;
    }
  }

  // =============================================================================
  // Global Error Handlers
  // =============================================================================

  /**
   * Global error handler for uncaught exceptions
   */
  function handleGlobalError(message, source, lineno, colno, error) {
    // Check if we should ignore this error
    if (shouldIgnoreError(message, source)) {
      return false; // Let browser handle it
    }

    const errorDetails = {
      message: String(message),
      source,
      lineno,
      colno,
      stack: error?.stack || null
    };

    logError(errorDetails, { handler: 'window.onerror' });

    // Don't show UI for minor errors that don't affect functionality
    // Only show for critical errors that break the page
    if (error && error.name !== 'SyntaxError') {
      showErrorToast('Something went wrong. Please refresh if the page isn\'t working correctly.');
    }

    return false; // Let error propagate to console for debugging
  }

  /**
   * Global handler for unhandled promise rejections
   */
  function handleUnhandledRejection(event) {
    const error = event.reason;

    // Check if we should ignore this error
    const message = error?.message || String(error);
    if (shouldIgnoreError(message, '')) {
      return;
    }

    const errorDetails = extractErrorDetails(error);
    logError(errorDetails, { handler: 'unhandledrejection' });

    // Show toast for unhandled rejections
    showErrorToast('An unexpected error occurred. Please try again.');
  }

  // =============================================================================
  // Install Global Handlers
  // =============================================================================

  // Only install if not already installed
  if (!window.__GLOBAL_ERROR_HANDLER_INSTALLED__) {
    window.__GLOBAL_ERROR_HANDLER_INSTALLED__ = true;

    // Install window.onerror
    const originalOnError = window.onerror;
    window.onerror = function(message, source, lineno, colno, error) {
      handleGlobalError(message, source, lineno, colno, error);
      if (originalOnError) {
        return originalOnError.call(this, message, source, lineno, colno, error);
      }
      return false;
    };

    // Install unhandledrejection handler
    window.addEventListener('unhandledrejection', handleUnhandledRejection);

    // Log initialization
    if (window.NU && typeof window.NU._log === 'function') {
      window.NU._log('debug', 'init', { module: 'GlobalErrorHandler', version: '1.0.0' });
    }
  }

  // =============================================================================
  // Public API
  // =============================================================================

  window.GlobalErrorHandler = {
    /**
     * Version
     */
    VERSION: '1.0.0',

    /**
     * Wrap async operations with error boundary
     * @param {Function} fn - Async function to execute
     * @param {Object} options - Error boundary options
     * @returns {Promise<any>} Result of fn or fallbackValue on error
     */
    withErrorBoundary,

    /**
     * Execute with retry and exponential backoff
     * @param {Function} fn - Async function to execute
     * @param {Object} options - Retry options
     * @returns {Promise<any>} Result of fn
     */
    withRetry,

    /**
     * Show error dialog to user
     * @param {Object} options - Dialog options
     */
    showErrorDialog,

    /**
     * Show error toast notification
     * @param {string} message - Error message
     * @param {Object} options - Toast options
     */
    showErrorToast,

    /**
     * Report an error manually
     * @param {Error|string|Object} error - Error to report
     * @param {Object} context - Additional context
     */
    reportError(error, context = {}) {
      const errorDetails = extractErrorDetails(error);
      logError(errorDetails, context);
    },

    /**
     * Get recent errors for diagnostics
     * @returns {Array} Recent error entries
     */
    getRecentErrors() {
      return [...errorState.recentErrors];
    },

    /**
     * Clear recent errors
     */
    clearRecentErrors() {
      errorState.recentErrors.length = 0;
    },

    /**
     * Get error statistics
     * @returns {Object} Error statistics
     */
    getStats() {
      return {
        totalRecentErrors: errorState.recentErrors.length,
        errorsThisMinute: errorState.errorCount,
        isThrottled: isThrottled(),
        lastErrorReset: new Date(errorState.lastErrorReset).toISOString()
      };
    },

    /**
     * Configure error handler
     * @param {Object} options - Configuration options
     */
    configure(options = {}) {
      Object.assign(CONFIG, options);
    }
  };

})();
</script>

  <script>
/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SponsorUtils - Shared utilities for sponsor rendering across surfaces
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * RESPONSIBILITY: This file handles sponsor rendering and analytics ONLY.
 * It does NOT create/modify sponsors - that's Code.gs territory.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * [MVP] SPONSOR CONTRACT - /schemas/sponsor.schema.json
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * CANONICAL SPONSOR SHAPE (all fields per schema):
 * {
 *   id: string,              // MVP REQUIRED - Unique sponsor identifier
 *   name: string,            // MVP REQUIRED - Display name (1-200 chars)
 *   logoUrl: string,         // MVP REQUIRED - URL to logo image (https://...)
 *   linkUrl?: string|null,   // MVP OPTIONAL - Click-through URL
 *   placement: string        // MVP REQUIRED - "poster"|"display"|"public"|"tv-banner"
 * }
 *
 * This utility normalizes legacy formats (img, url, placements) to the canonical shape.
 * All surfaces MUST use normalizeSponsor() before rendering.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * WINDOW ADDITION: window.SponsorUtils
 *
 * Used by: Display.html, Public.html, Poster.html
 * ═══════════════════════════════════════════════════════════════════════════════
 */
window.SponsorUtils = (function() {
  'use strict';

  // === XSS Prevention ===
  function esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[m]));
  }

  // === Session ID for analytics attribution ===
  // Ties all events from same page visit together
  let sessionId = null;

  // Generate UUID using crypto API (secure)
  function generateSecureUUID() {
    // Prefer native crypto.randomUUID if available (modern browsers)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback: use crypto.getRandomValues (secure, wider support)
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      const bytes = new Uint8Array(16);
      crypto.getRandomValues(bytes);
      // Set version (4) and variant (RFC4122)
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
      const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
      return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
    }
    // Last resort fallback (very old browsers) - use timestamp + counter for uniqueness
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c, i) => {
      const r = (Date.now() + i) % 16;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }

  function getSessionId() {
    if (sessionId) return sessionId;
    // Check sessionStorage first (persists across page reloads in same tab)
    try {
      sessionId = sessionStorage.getItem('zeb_session_id');
      if (!sessionId) {
        sessionId = generateSecureUUID();
        sessionStorage.setItem('zeb_session_id', sessionId);
      }
    } catch (_) {
      // sessionStorage not available, use in-memory only
      sessionId = generateSecureUUID();
    }
    return sessionId;
  }

  // === Analytics Logging ===
  const BATCH_SIZE = 5;
  const FLUSH_INTERVAL = 5000;
  let logBatch = [];
  let flushTimer = null;

  function logEvent(evt) {
    try {
      evt.ua = navigator.userAgent;
      evt.ts = Date.now();
      evt.sessionId = getSessionId();  // Always include sessionId
      logBatch.push(evt);
      if (logBatch.length >= BATCH_SIZE) flush();
    } catch (_) {}
  }

  function flush() {
    if (!logBatch.length) return;
    const copy = logBatch.splice(0, logBatch.length);
    NU.safeAnalytics('api_logEvents', { items: copy });
  }

  function initLogging() {
    if (flushTimer) clearInterval(flushTimer);
    flushTimer = setInterval(flush, FLUSH_INTERVAL);
    window.addEventListener('beforeunload', flush);
    getSessionId(); // Initialize sessionId early
  }

  // === Sponsor Filtering ===
  function filterByPlacement(sponsors, placement) {
    return (sponsors || []).filter(s => s?.placements?.[placement]);
  }

  // === Generic Sponsor Renderer ===
  /**
   * Renders sponsors to a container element
   * @param {Object} options
   * @param {Array} options.sponsors - Array of sponsor objects
   * @param {string} options.placement - Placement key (tvTop, tvSide, mobileBanner, posterTop)
   * @param {HTMLElement} options.container - Target container element
   * @param {string} options.surface - Surface name for logging (display, public, poster)
   * @param {string} options.eventId - Event ID for logging
   * @param {string} options.layout - 'inline' (top bar), 'cards' (side panel), 'banner' (single)
   * @param {boolean} options.trackClicks - Whether to track click events
   * @param {boolean} options.trackImpressions - Whether to log impressions
   * @param {boolean} options.wrapLinks - Whether to wrap sponsors with URLs in anchor tags
   * @param {number} options.maxSponsors - Max sponsors to show (0 = all)
   * @returns {Array} - Filtered sponsors that were rendered
   */
  function renderSponsors(options) {
    const {
      sponsors = [],
      placement,
      container,
      surface = 'unknown',
      eventId = '',
      layout = 'inline',
      trackClicks = true,
      trackImpressions = true,
      wrapLinks = true,
      maxSponsors = 0
    } = options;

    if (!container || !placement) return [];

    let picks = filterByPlacement(sponsors, placement);
    if (!picks.length) return [];

    // Limit sponsors if maxSponsors is set
    if (maxSponsors > 0) {
      picks = picks.slice(0, maxSponsors);
    }

    // Render based on layout type
    let html = '';
    switch (layout) {
      case 'cards':
        html = picks.map(s => renderCard(s, wrapLinks)).join('');
        break;
      case 'banner':
        html = picks.map(s => renderBanner(s, wrapLinks)).join('');
        break;
      case 'inline':
      default:
        html = picks.map(s => renderInline(s, wrapLinks)).join('');
    }

    container.innerHTML = html;
    container.hidden = false;

    // Log impressions
    if (trackImpressions) {
      picks.forEach(s => {
        logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id || '' });
      });
    }

    // Attach click handlers
    if (trackClicks && wrapLinks) {
      container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
        a.addEventListener('click', () => {
          logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
        });
      });
    }

    return picks;
  }

  // === Layout Renderers ===
  function renderInline(s, wrapLinks) {
    const content = s.img
      ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">`
      : `<strong>${esc(s.name || '')}</strong>`;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}">${content}</a>`;
    }
    return content;
  }

  function renderCard(s, wrapLinks) {
    const card = `
      <div class="sp-card" data-id="${esc(s.id || '')}">
        ${s.img ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">` : ''}
        <div class="sp-name">${esc(s.name || '')}</div>
      </div>
    `;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}" style="text-decoration:none;color:inherit;">${card}</a>`;
    }
    return card;
  }

  function renderBanner(s, wrapLinks) {
    const content = `
      ${s.img ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">` : ''}
      <strong>${esc(s.name || '')}</strong>
    `;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}">${content}</a>`;
    }
    return `<span>${content}</span>`;
  }

  // === Sponsor Normalization ===
  /**
   * Normalize sponsor object to schema-compliant format
   * Schema: /schemas/sponsor.schema.json
   *
   * CANONICAL FIELDS (per schema):
   * - id: string (required)
   * - name: string (required)
   * - logoUrl: string (required)
   * - linkUrl: string (optional)
   * - placement: "poster"|"display"|"public"|"tv-banner" (required)
   * - isPrimary: boolean (optional) - Primary sponsor gets bigger rendering
   *
   * LEGACY FIELD MAPPING (deprecated - will be removed in V3):
   * - s.img → logoUrl
   * - s.url → linkUrl
   * - s.website → linkUrl
   * - s.placements → placement (first key with true value)
   *
   * @param {Object} s - Sponsor object (schema or legacy format)
   * @returns {Object} - Schema-compliant sponsor: { id, name, logoUrl, linkUrl, placement, isPrimary }
   */
  function normalizeSponsor(s) {
    if (!s) return null;

    // Determine placement from schema field or legacy placements object
    let placement = s.placement || '';
    if (!placement && s.placements && typeof s.placements === 'object') {
      // Legacy: find first true placement key
      placement = Object.keys(s.placements).find(k => s.placements[k]) || '';
    }

    return {
      // Schema fields
      id: s.id || '',
      name: s.name || '',
      logoUrl: s.logoUrl || s.img || '',      // Legacy fallback: img
      linkUrl: s.linkUrl || s.website || s.url || '',  // Legacy fallback: website, url
      placement: placement,
      isPrimary: !!s.isPrimary  // Feature 3: Primary sponsor flag
    };
  }

  // === Unified SponsorRenderer ===
  /**
   * Unified sponsor rendering component
   * Replaces duplicate renderSponsor* functions across surfaces
   *
   * All methods expect sponsors in schema format (/schemas/sponsor.schema.json):
   * { id, name, logoUrl, linkUrl?, placement }
   *
   * Legacy formats (img, url, placements) are auto-converted via normalizeSponsor().
   *
   * CENTRALIZED PLACEMENT FILTERING:
   * All methods accept optional `placement` parameter to filter sponsors.
   * Supported placements: 'poster' | 'public' | 'display' | 'tv-banner'
   * For Display surface, use placement: ['display', 'tv-banner'] to match either.
   */
  const SponsorRenderer = {
    /**
     * Filter sponsors by placement(s)
     * @param {Array} sponsors - Normalized sponsor array
     * @param {string|string[]} placement - Single placement or array of placements to match
     * @returns {Array} - Filtered sponsors
     */
    _filterByPlacement(sponsors, placement) {
      if (!placement) return sponsors;
      const placements = Array.isArray(placement) ? placement : [placement];
      return sponsors.filter(s => placements.includes(s.placement));
    },

    /**
     * Render sponsors as horizontal strip (top bar, banner)
     * @param {Object} options
     * @param {HTMLElement} options.container - Target element
     * @param {Array} options.sponsors - Sponsor array (schema or legacy format)
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {string} options.eventId - For analytics
     * @param {string} options.surface - Surface name (display, public, poster)
     * @param {boolean} options.showLinks - Wrap in anchor tags (default: true)
     * @param {boolean} options.showTier - Show PRIMARY badge for primary sponsors (default: false)
     * @param {Function} options.onRender - Callback with rendered sponsor IDs
     * @returns {Array} - Normalized sponsors that were rendered
     */
    renderStrip(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        showTier = false,
        onRender = null
      } = options;

      if (!container) return [];
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const filtered = this._filterByPlacement(normalized, placement);
      // Sort primary sponsors first
      const picks = filtered.sort((a, b) => (b.isPrimary ? 1 : 0) - (a.isPrimary ? 1 : 0));
      if (!picks.length) return [];

      container.innerHTML = picks.map(s => {
        const primaryClass = s.isPrimary ? ' sponsor-primary' : '';
        const tierBadge = showTier && s.isPrimary ? '<span class="sponsor-tier-badge">PRIMARY</span>' : '';
        const content = s.logoUrl
          ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}" class="sponsor-logo${primaryClass}">${tierBadge}`
          : `<strong class="${primaryClass}">${esc(s.name)}</strong>${tierBadge}`;

        if (showLinks && s.linkUrl) {
          return `<a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id)}" class="sponsor-item${primaryClass}">${content}</a>`;
        }
        return `<span class="sponsor-item${primaryClass}">${content}</span>`;
      }).join('');

      container.hidden = false;

      // Log impressions
      picks.forEach(s => logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id }));

      // Attach click handlers
      if (showLinks) {
        container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
          a.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
          });
        });
      }

      // Callback with rendered IDs (for BBN attribution)
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return picks;
    },

    /**
     * Render sponsors as card grid (side panel, TV mode)
     * @param {Object} options - Same as renderStrip plus:
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {HTMLElement} options.mainEl - Optional main element to add 'has-side' class
     * @returns {Array} - Normalized sponsors that were rendered
     */
    renderGrid(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        mainEl = null,
        onRender = null
      } = options;

      if (!container) return [];
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const picks = this._filterByPlacement(normalized, placement);
      if (!picks.length) return [];

      container.innerHTML = picks.map(s => {
        const card = `
          <div class="sp-card" data-id="${esc(s.id)}">
            ${s.logoUrl ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}">` : ''}
            <div class="sp-name">${esc(s.name)}</div>
          </div>
        `;

        if (showLinks && s.linkUrl) {
          return `<a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id)}" style="text-decoration:none;color:inherit;">${card}</a>`;
        }
        return card;
      }).join('');

      container.hidden = false;
      if (mainEl) mainEl.classList.add('has-side');

      // Log impressions
      picks.forEach(s => logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id }));

      // Attach click handlers
      if (showLinks) {
        container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
          a.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
          });
        });
      }

      // Callback with rendered IDs
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return picks;
    },

    /**
     * Render sponsors as rotating carousel (one at a time)
     * @param {Object} options - Same as renderStrip plus:
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {number} options.rotationMs - Rotation interval (default: 5000)
     * @returns {Object} - { sponsors: Array, stop: Function }
     */
    renderCarousel(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        showTier = false,
        rotationMs = 5000,
        onRender = null
      } = options;

      if (!container) return { sponsors: [], stop: () => {} };
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const picks = this._filterByPlacement(normalized, placement);
      if (!picks.length) return { sponsors: [], stop: () => {} };

      let currentIndex = 0;
      let timer = null;

      function showSponsor(index) {
        const s = picks[index];
        const indicator = picks.length > 1 ? `<span class="sponsor-indicator">${index + 1}/${picks.length}</span>` : '';

        const content = `
          ${s.logoUrl ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}">` : ''}
          <strong>${esc(s.name)}</strong>
        `;

        if (showLinks && s.linkUrl) {
          container.innerHTML = `
            <a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" class="sponsor-link" data-sponsor-id="${esc(s.id)}">
              ${content}
            </a>
            ${indicator}
          `;
        } else {
          container.innerHTML = `<span>${content}</span>${indicator}`;
        }

        // Log impression
        logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id });

        // Attach click handler
        const linkEl = container.querySelector('.sponsor-link');
        if (linkEl) {
          linkEl.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: s.id });
          });
        }
      }

      // Show first sponsor
      showSponsor(0);
      container.hidden = false;

      // Start rotation if multiple sponsors
      if (picks.length > 1) {
        timer = setInterval(() => {
          currentIndex = (currentIndex + 1) % picks.length;
          showSponsor(currentIndex);
        }, rotationMs);
      }

      // Callback with rendered IDs
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return {
        sponsors: picks,
        stop: () => { if (timer) clearInterval(timer); }
      };
    },

    // Expose normalization for external use
    normalizeSponsor
  };

  // === Public API ===
  return {
    esc,
    logEvent,
    flush,
    initLogging,
    getSessionId,  // For external click handlers that need sessionId
    filterByPlacement,
    renderSponsors,
    // Expose individual renderers for custom use
    renderInline,
    renderCard,
    renderBanner,
    // NEW: Unified renderer
    SponsorRenderer,
    normalizeSponsor,
    // Constants
    BATCH_SIZE,
    FLUSH_INTERVAL
  };
})();
</script>

  <!--
================================================================================
FooterComponent - Centralized Trust Footer
================================================================================
Extracted from: Display.html, Poster.html, Public.html, SharedReport.html
Purpose: Consistent "Powered by" footer across all MVP surfaces

Usage:
  include('FooterComponent')

Variants:
  - Default: Standard footer for light backgrounds
  - TV: Subtle footer for dark TV/display mode (use .site-footer-tv)
  - Print: Optimized for print media

DO NOT modify this component's structure without updating:
  - All MVP surfaces that include it
  - Design system documentation
================================================================================
-->
<style>
  /* ===== Trust Footer Component ===== */
  .site-footer {
    text-align: center;
    padding: 24px 16px;
    margin-top: 40px;
    border-top: 1px solid var(--color-gray-200, #e2e8f0);
    color: var(--color-gray-400, #94a3b8);
    font-size: 0.7rem;
  }

  .site-footer a {
    color: var(--color-gray-500, #64748b);
    text-decoration: none;
    transition: color var(--transition-fast, 0.15s ease);
  }

  .site-footer a:hover {
    color: var(--color-primary, #2563eb);
    text-decoration: underline;
  }

  /* TV Mode Variant (dark background) */
  .site-footer-tv,
  body[data-tv="1"] .site-footer {
    position: fixed;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255, 255, 255, 0.3);
    font-size: 0.6rem;
    z-index: 100;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
  }

  .site-footer-tv a,
  body[data-tv="1"] .site-footer a {
    color: rgba(255, 255, 255, 0.4);
  }

  .site-footer-tv a:hover,
  body[data-tv="1"] .site-footer a:hover {
    color: rgba(255, 255, 255, 0.6);
    text-decoration: none;
  }

  /* Print Styles */
  @media print {
    .site-footer {
      border-top: none;
      padding: 12px;
      font-size: 8pt;
      margin-top: 20px;
      page-break-inside: avoid;
    }

    .site-footer-tv {
      position: static;
      transform: none;
    }
  }
</style>

<!-- Default Footer Template (can be included or used as reference) -->
<template id="footer-template">
  <footer class="site-footer">
    <p>Powered by <a href="https://eventangle.com" target="_blank" rel="noopener">EventAngle</a></p>
  </footer>
</template>

  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <meta name="referrer" content="no-referrer"/>
  <style>
    .card{ background:#fff; border-radius:var(--radius-md, 12px); padding:var(--card-padding-tablet, 20px); margin-bottom:var(--card-padding-tablet, 20px); box-shadow:var(--shadow-base, 0 1px 3px rgba(0,0,0,0.1)); }
    .card h2{ margin:0 0 16px; color:var(--color-gray-800, #1e293b); }
    .events-grid{ display:grid; grid-template-columns:repeat(auto-fill, minmax(280px, 1fr)); gap:16px; }
    .event-card{ background:var(--color-gray-50, #f8fafc); border:1px solid var(--color-gray-200, #e2e8f0); border-radius:var(--radius-md, 12px); padding:var(--card-padding-mobile, 16px); transition:all var(--transition-base, 0.2s); }
    .event-card:hover{ transform:translateY(-2px); box-shadow:var(--shadow-md, 0 4px 12px rgba(0,0,0,0.1)); border-color:var(--color-primary, #2563eb); }
    .event-card h3{ margin:0 0 8px; color:var(--color-gray-800, #1e293b); }
    .event-card p{ margin:4px 0; color:var(--color-gray-500, #64748b); font-size:var(--font-size-sm, 14px); }

    /* Enhanced Sponsor Banner */
    .sponsor-banner{
      background:linear-gradient(135deg, var(--color-gray-50, #f8fafc) 0%, var(--color-gray-200, #e2e8f0) 100%);
      border:2px solid var(--color-gray-200, #e2e8f0); border-radius:var(--radius-md, 12px); padding:var(--card-padding-tablet, 20px);
      margin-bottom:var(--space-6, 24px); text-align:center; display:flex; align-items:center;
      justify-content:center; gap:16px; flex-wrap:wrap;
      box-shadow: var(--shadow-sm, 0 2px 8px rgba(0,0,0,0.05));
    }
    .sponsor-banner img{
      max-height:var(--sponsor-logo-height, 60px); max-width:var(--sponsor-logo-max-width, 220px); object-fit:contain;
      transition: transform var(--transition-base, 0.2s ease);
    }
    .sponsor-banner img:hover {
      transform: scale(1.05);
    }
    .sponsor-banner strong{
      color:var(--color-gray-800, #1e293b); font-size:1.1em; font-weight:var(--font-weight-semibold, 600);
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .sponsor-banner a {
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .sponsor-indicator {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 12px;
      font-weight: 500;
    }
    .sponsor-banner {
      position: relative;
      transition: opacity 0.3s ease;
    }

    /* Event Detail View */
    .event-detail {
      max-width: 800px;
      margin: 0 auto;
    }
    .event-header {
      text-align: center;
      margin-bottom: var(--space-6, 24px);
    }
    .event-header h1 {
      color: var(--color-primary, #2563eb);
      font-size: 2.2rem;
      margin-bottom: 12px;
      line-height: 1.2;
    }
    .event-meta {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 16px;
      margin: 12px 0;
      color: var(--color-gray-600, #475569);
      font-size: 1rem;
    }
    .event-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .event-meta-item strong {
      color: var(--color-gray-800, #1e293b);
    }
    .event-image {
      width: 100%;
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .event-video {
      width: 100%;
      max-width: 100%;
      aspect-ratio: 16/9;
      border-radius: 12px;
      margin: 24px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .event-section {
      margin: 32px 0;
    }
    .event-section h2 {
      color: var(--color-gray-800, #1e293b);
      font-size: 1.5rem;
      margin-bottom: 12px;
      border-bottom: 2px solid var(--color-gray-200, #e2e8f0);
      padding-bottom: 8px;
    }
    .event-section p {
      color: var(--color-gray-600, #475569);
      line-height: 1.7;
      margin: 12px 0;
    }
    .event-section a {
      color: var(--color-primary, #2563eb);
      text-decoration: none;
      font-weight: var(--font-weight-medium, 500);
    }
    .event-section a:hover {
      text-decoration: underline;
    }
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
      margin: 16px 0;
    }
    .gallery img {
      width: 100%;
      height: 200px;
      object-fit: cover;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transition: transform 0.2s;
    }
    .gallery img:hover {
      transform: scale(1.05);
    }
    /* Schedule section */
    .schedule-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .schedule-item {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px 16px;
      padding: 12px;
      background: var(--color-gray-50, #f8fafc);
      border-radius: var(--radius-base, 8px);
      border-left: 3px solid var(--color-primary, #2563eb);
    }
    .schedule-time {
      font-weight: var(--font-weight-semibold, 600);
      color: var(--color-primary, #2563eb);
      white-space: nowrap;
    }
    .schedule-title {
      font-weight: var(--font-weight-semibold, 600);
      color: var(--color-gray-800, #1e293b);
    }
    .schedule-desc {
      grid-column: 2;
      color: var(--color-gray-500, #64748b);
      font-size: 0.9rem;
    }
    /* Fundraising progress */
    .fundraising-progress {
      margin: 16px 0;
    }
    .fundraising-progress .progress-bar {
      height: 24px;
      background: var(--color-gray-200, #e2e8f0);
      border-radius: var(--radius-md, 12px);
      overflow: hidden;
    }
    .fundraising-progress .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--color-success, #10b981), var(--color-success-dark, #059669));
      border-radius: var(--radius-md, 12px);
      transition: width 0.5s ease;
    }
    .fundraising-progress .progress-text {
      text-align: center;
      margin-top: 8px;
      font-weight: var(--font-weight-semibold, 600);
      color: var(--color-success-dark, #059669);
    }
    /* Data tables (standings, etc.) */
    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    .data-table th, .data-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--color-gray-200, #e2e8f0);
    }
    .data-table th {
      background: var(--color-gray-50, #f8fafc);
      font-weight: var(--font-weight-semibold, 600);
      color: var(--color-gray-600, #475569);
      font-size: 0.8rem;
      text-transform: uppercase;
    }
    .data-table tbody tr:hover {
      background: var(--color-gray-50, #f8fafc);
    }
    .standings-table .rank {
      display: inline-block;
      width: 24px;
      height: 24px;
      line-height: 24px;
      text-align: center;
      background: var(--color-gray-200, #e2e8f0);
      border-radius: 50%;
      font-weight: var(--font-weight-semibold, 600);
      font-size: 0.75rem;
      margin-right: 8px;
    }
    .standings-table .top-rank .rank {
      background: var(--color-warning-bg, #fef3c7);
      color: var(--color-warning-dark, #92400e);
    }
    .standings-table .top-rank:first-child .rank {
      background: var(--color-warning-light, #fcd34d);
      color: var(--color-warning-darker, #78350f);
    }
    /* Vendor grid */
    .vendor-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
    }
    .vendor-card {
      padding: var(--card-padding-mobile, 16px);
      background: var(--color-gray-50, #f8fafc);
      border: 1px solid var(--color-gray-200, #e2e8f0);
      border-radius: var(--radius-md, 12px);
    }
    .vendor-card h4 {
      margin: 0 0 8px 0;
      color: var(--color-gray-800, #1e293b);
    }
    .vendor-card p {
      margin: 0 0 12px 0;
      color: var(--color-gray-500, #64748b);
      font-size: 0.9rem;
    }
    .vendor-card a {
      color: var(--color-primary, #2563eb);
      text-decoration: none;
      font-weight: var(--font-weight-medium, 500);
    }
    /* Bracket/Tournament styling */
    .bracket-container {
      overflow-x: auto;
    }
    .bracket-rounds {
      display: flex;
      gap: 24px;
      min-width: max-content;
      padding: 12px 0;
    }
    .bracket-round {
      min-width: 200px;
    }
    .round-title {
      font-size: 0.85rem;
      color: var(--color-gray-500, #64748b);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin: 0 0 12px 0;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--color-gray-200, #e2e8f0);
    }
    .bracket-matches {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .bracket-match-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .match-num {
      font-size: 0.75rem;
      color: var(--color-gray-400, #94a3b8);
      font-weight: var(--font-weight-semibold, 600);
      min-width: 28px;
    }
    .bracket-match {
      background: var(--color-gray-50, #f8fafc);
      border: 1px solid var(--color-gray-200, #e2e8f0);
      border-radius: var(--radius-base, 8px);
      padding: 12px;
      margin-bottom: 12px;
      flex: 1;
    }
    .match-team {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: white;
      border-radius: var(--radius-sm, 6px);
      margin: 4px 0;
    }
    .match-team.winner {
      background: var(--color-success-bg, #dcfce7);
      border-left: 3px solid var(--color-success, #22c55e);
    }
    .team-name {
      font-weight: var(--font-weight-medium, 500);
      color: var(--color-gray-800, #1e293b);
    }
    .team-score {
      font-weight: var(--font-weight-bold, 700);
      color: var(--color-primary, #2563eb);
      font-size: 1.1rem;
    }
    .match-vs {
      text-align: center;
      font-size: 0.7rem;
      color: var(--color-gray-400, #94a3b8);
      text-transform: uppercase;
      margin: 2px 0;
    }
    /* Loading placeholder */
    .loading-placeholder {
      padding: var(--space-6, 24px);
      text-align: center;
      color: var(--color-gray-500, #64748b);
      background: var(--color-gray-50, #f8fafc);
      border-radius: var(--radius-base, 8px);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .action-buttons {
      display: flex;
      gap: 12px;
      margin: 24px 0;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* Mobile: Sticky bottom buttons for one-handed use */
    @media (max-width: 640px) {
      body {
        padding-bottom: 80px; /* Space for sticky buttons */
      }

      /* Container padding for mobile */
      .container {
        padding: 12px;
      }

      /* Card mobile adjustments */
      .card {
        padding: 16px;
        margin-bottom: 16px;
        border-radius: 8px;
      }

      .events-grid{ grid-template-columns:1fr; gap:12px; }
      .event-card {
        padding: 14px;
      }

      /* Sponsor banner mobile */
      .sponsor-banner{
        flex-direction:column;
        padding:14px;
        gap:12px;
        margin-bottom: 16px;
        border-radius: 8px;
      }
      .sponsor-banner img{
        max-height:var(--sponsor-logo-height-sm, 50px);
        max-width: 160px;
      }
      .sponsor-banner strong {
        font-size: 1rem;
      }

      /* Event header mobile */
      .event-header h1 {
        font-size: 1.6rem;
        line-height: 1.3;
        word-wrap: break-word;
      }
      .event-meta {
        font-size: 0.9rem;
        gap: 10px;
        flex-direction: column;
        align-items: center;
      }
      .event-meta-item {
        text-align: center;
      }

      /* Gallery mobile */
      .gallery { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; }
      .gallery img { height: 140px; }

      /* Sticky action buttons at bottom for thumb reach */
      .action-buttons {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: white;
        padding: 12px 16px;
        padding-bottom: max(12px, env(safe-area-inset-bottom));
        margin: 0;
        box-shadow: 0 -4px 12px rgba(0,0,0,0.15);
        z-index: 100;
        border-top: 1px solid var(--color-gray-200, #e2e8f0);
        flex-direction: column;
        gap: 8px;
      }

      .action-buttons .btn-primary,
      .action-buttons .btn-secondary {
        width: 100%;
        margin: 0;
        padding: 14px 16px;
        font-size: 1rem;
        min-height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .event-image,
      .event-video {
        margin: 16px 0;
        border-radius: 8px;
      }

      .event-section {
        margin: 20px 0;
      }

      .event-section h2 {
        font-size: 1.2rem;
        margin-bottom: 10px;
      }

      /* Schedule mobile */
      .schedule-item {
        grid-template-columns: 1fr;
        gap: 4px;
        padding: 10px 12px;
      }
      .schedule-time {
        font-size: 0.85rem;
      }
      .schedule-desc {
        grid-column: 1;
      }

      /* Data tables mobile */
      .data-table th, .data-table td {
        padding: 10px 8px;
        font-size: 0.85rem;
      }

      /* Bracket mobile - allow horizontal scroll */
      .bracket-container {
        -webkit-overflow-scrolling: touch;
        padding-bottom: 8px;
      }
      .bracket-round {
        min-width: 180px;
      }

      /* Toast mobile positioning */
      .toast {
        bottom: 120px;
        left: 16px;
        right: 16px;
        transform: translateY(100px);
      }
      .toast.show {
        transform: translateY(0);
      }
    }

    /* Very small screens (iPhone SE, etc.) */
    @media (max-width: 375px) {
      .container {
        padding: 8px;
      }

      .event-header h1 {
        font-size: 1.4rem;
      }

      .action-buttons .btn-primary,
      .action-buttons .btn-secondary {
        font-size: 0.9rem;
        padding: 12px 14px;
      }
    }

    /* === MVP Essential Additions === */

    /* Loading Skeletons */
    .skeleton {
      background: linear-gradient(90deg, #f1f5f9 25%, #e2e8f0 50%, #f1f5f9 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
      border-radius: 8px;
    }
    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    .skeleton-title { height: 2.5rem; width: 70%; margin: 0 auto 16px; }
    .skeleton-meta { height: 1.2rem; width: 50%; margin: 8px auto; }
    .skeleton-image { height: 300px; width: 100%; margin: 24px 0; }
    .skeleton-button { height: 44px; width: 140px; display: inline-block; margin: 8px; }
    .skeleton-text { height: 1rem; width: 100%; margin: 8px 0; }
    .skeleton-text.short { width: 60%; }

    /* Utility Action Bar (Maps, Calendar, Share) */
    .utility-buttons {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 16px 0;
    }
    .btn-utility {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      background: #f1f5f9;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      color: #475569;
      font-size: 0.875rem;
      font-weight: 500;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-utility:hover {
      background: #e2e8f0;
      color: #1e293b;
      border-color: #cbd5e1;
    }
    .btn-utility:active {
      transform: scale(0.98);
    }

    /* Calendar Dropdown */
    .calendar-dropdown {
      position: relative;
      display: inline-block;
    }
    .calendar-menu {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 8px 0;
      min-width: 180px;
      z-index: 200;
      display: none;
    }
    .calendar-dropdown.open .calendar-menu {
      display: block;
    }
    .calendar-menu a {
      display: block;
      padding: 10px 16px;
      color: #475569;
      text-decoration: none;
      font-size: 0.875rem;
    }
    .calendar-menu a:hover {
      background: #f1f5f9;
      color: #1e293b;
    }

    /* Toast Notification */
    .toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1e293b;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 300;
    }
    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* .site-footer - Now centralized in FooterComponent.html (D-005) */

    /* Better Empty States */
    .empty-state {
      text-align: center;
      padding: 48px 24px;
      color: #64748b;
    }
    .empty-state-icon {
      font-size: 3rem;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    .empty-state h3 {
      color: #475569;
      margin-bottom: 8px;
      font-size: 1.25rem;
    }
    .empty-state p {
      margin-bottom: 16px;
      line-height: 1.6;
    }

    /* Error State */
    .error-state {
      text-align: center;
      padding: 48px 24px;
      background: #fef2f2;
      border-radius: 12px;
      border: 1px solid #fecaca;
    }
    .error-state-icon {
      font-size: 2.5rem;
      margin-bottom: 12px;
    }
    .error-state h3 {
      color: #dc2626;
      margin-bottom: 8px;
    }
    .error-state p {
      color: #b91c1c;
      margin-bottom: 16px;
    }
    /* .btn-retry - Base in Styles.html, danger override for error context */
    .error-state .btn-retry {
      background: var(--color-danger, #dc2626);
    }
    .error-state .btn-retry:hover {
      background: var(--color-danger-dark, #b91c1c);
    }

    /* Mobile adjustments for utility buttons */
    @media (max-width: 640px) {
      .utility-buttons {
        flex-direction: column;
        align-items: stretch;
        padding: 0 16px;
      }
      .btn-utility {
        justify-content: center;
      }
      .calendar-menu {
        left: 0;
        right: 0;
        transform: none;
        width: auto;
      }
      .site-footer {
        padding-bottom: 100px; /* Space for sticky buttons */
      }
    }

    /* Status Badges */
    .status-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 16px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .status-badge.active {
      background: #dcfce7;
      color: #166534;
    }
    .status-badge.upcoming {
      background: #dbeafe;
      color: #1e40af;
    }
    .status-badge.ended {
      background: #f1f5f9;
      color: #64748b;
    }
    .status-badge.cancelled {
      background: #fef2f2;
      color: #dc2626;
    }

    /* League Info Card */
    .league-info-card {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-radius: 12px;
      padding: 24px;
    }
    .league-links {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .league-link-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px 24px;
      background: white;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      text-decoration: none;
      color: #1e293b;
      transition: all 0.2s;
      min-width: 120px;
    }
    .league-link-btn:hover {
      border-color: #2563eb;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.15);
      transform: translateY(-2px);
    }
    .league-link-icon {
      font-size: 1.5rem;
    }
    .league-link-label {
      font-size: 0.875rem;
      font-weight: 600;
    }
    .league-data-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
    }

    /* Sponsor tier badge */
    .sponsor-tier {
      display: inline-block;
      padding: 2px 8px;
      background: #fef3c7;
      color: #92400e;
      font-size: 0.7rem;
      font-weight: 600;
      border-radius: 10px;
      text-transform: uppercase;
      margin-left: 8px;
    }

    /* Feature 3: Primary Sponsor - Bigger Rendering */
    .sponsor-primary img,
    .sponsor-logo.sponsor-primary {
      max-height: calc(var(--sponsor-logo-height, 60px) * 1.5) !important;
      max-width: calc(var(--sponsor-logo-max-width, 220px) * 1.3) !important;
    }
    .sponsor-primary strong {
      font-size: 1.4em;
    }
    .sponsor-item.sponsor-primary {
      order: -1; /* Primary sponsors appear first */
      padding: 8px 16px;
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border-radius: var(--radius-base, 8px);
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.2);
    }
    .sponsor-tier-badge {
      display: inline-block;
      padding: 2px 6px;
      background: #f59e0b;
      color: white;
      font-size: 0.6rem;
      font-weight: 700;
      border-radius: 8px;
      text-transform: uppercase;
      margin-left: 6px;
      vertical-align: middle;
    }

    @media (max-width: 640px) {
      .league-links {
        flex-direction: column;
      }
      .league-link-btn {
        flex-direction: row;
        justify-content: flex-start;
        gap: 12px;
        padding: 12px 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Story 1.2: data-testid="events-root" marker for CI smoke tests -->
  <div class="container" data-testid="events-root">
    <h1><?= appTitle ?></h1>
    <div id="sponsorBanner" hidden></div>
    <section class="card">
      <h2>Events</h2>
      <div id="list" class="events-grid">
        <!-- Skeleton loader shown during fetch -->
        <div class="skeleton-loader">
          <div class="skeleton skeleton-title"></div>
          <div class="skeleton skeleton-meta"></div>
          <div class="skeleton skeleton-meta" style="width: 40%;"></div>
          <div style="text-align: center; margin: 16px 0;">
            <div class="skeleton skeleton-button"></div>
            <div class="skeleton skeleton-button"></div>
          </div>
          <div class="skeleton skeleton-image"></div>
        </div>
      </div>
    </section>
  </div>

  <!-- Toast notification -->
  <div id="toast" class="toast"></div>

  <!-- Trust Footer -->
  <footer class="site-footer">
    <p>Powered by <a href="https://eventangle.com" target="_blank" rel="noopener">EventAngle</a></p>
  </footer>

  <script>
    const BRAND = '<?= brandId ?>';
    const SCOPE = '<?= scope ?>';
    const EXEC_URL = '<?= execUrl ?>';
    const url = new URL(location.href);
    const ID = url.searchParams.get('id');

    // Use shared utilities from SponsorUtils
    const { esc, logEvent, initLogging } = window.SponsorUtils;
    initLogging();

    // =============================================================================
    // Story 2.2: Worker Endpoint Configuration
    // Public bundle now fetched from Worker instead of GAS
    // =============================================================================

    /**
     * Get Worker base URL for API calls
     * Uses current origin for same-domain Worker deployment
     */
    function getWorkerBaseUrl() {
      return window.location.origin;
    }

    /**
     * Fetch public bundle from Worker endpoint
     * GET /api/v2/events/:id/bundle/public?brand=:brand
     *
     * @param {string} eventId - Event ID or slug
     * @param {string} brandId - Brand identifier
     * @param {object} options - { ifNoneMatch?: string } for conditional requests
     * @returns {Promise<{ok: boolean, value?: object, code?: string, message?: string}>}
     */
    async function fetchPublicBundleFromWorker(eventId, brandId, options = {}) {
      const baseUrl = getWorkerBaseUrl();
      const endpoint = `${baseUrl}/api/v2/events/${encodeURIComponent(eventId)}/bundle/public`;
      const url = new URL(endpoint);
      url.searchParams.set('brand', brandId);

      const headers = {
        'Accept': 'application/json'
      };

      // Support conditional requests (ETag)
      if (options.ifNoneMatch) {
        headers['If-None-Match'] = options.ifNoneMatch;
      }

      try {
        const response = await fetch(url.toString(), {
          method: 'GET',
          headers,
          credentials: 'same-origin'
        });

        // Handle 304 Not Modified
        if (response.status === 304) {
          return {
            ok: true,
            notModified: true,
            etag: response.headers.get('ETag')
          };
        }

        // Parse JSON response
        const data = await response.json();

        // Pass through response (Worker returns standard envelope)
        return data;

      } catch (error) {
        console.error('Worker fetch failed:', error);
        return {
          ok: false,
          code: 'NETWORK_ERROR',
          message: 'Unable to connect to server. Please check your connection.'
        };
      }
    }

    /**
     * Fetch events list from Worker endpoint
     * GET /api/v2/events?brand=:brand
     *
     * @param {string} brandId - Brand identifier
     * @returns {Promise<{ok: boolean, value?: object, code?: string, message?: string}>}
     */
    async function fetchEventsListFromWorker(brandId) {
      const baseUrl = getWorkerBaseUrl();
      const endpoint = `${baseUrl}/api/v2/events`;
      const url = new URL(endpoint);
      url.searchParams.set('brand', brandId);

      try {
        const response = await fetch(url.toString(), {
          method: 'GET',
          headers: { 'Accept': 'application/json' },
          credentials: 'same-origin'
        });

        const data = await response.json();
        return data;

      } catch (error) {
        console.error('Worker fetch failed:', error);
        return {
          ok: false,
          code: 'NETWORK_ERROR',
          message: 'Unable to connect to server. Please check your connection.'
        };
      }
    }

    // === MVP Essential Utilities ===

    // Toast notification
    function showToast(message, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), duration);
    }

    // === League & Broadcast Link Analytics ===
    // Logs external link clicks with sponsor attribution context
    let currentEventId = null; // Set when event is loaded
    let currentRenderedSponsorIds = []; // Track sponsors visible on page for attribution

    function onLeagueLinkClick(e) {
      const linkType = e.currentTarget.dataset.linkType;
      if (!linkType || !currentEventId) return;

      // S13: Use safeLogClick - fire and forget, never throws
      // Include sessionId and visibleSponsorIds for sponsor/BBN attribution
      NU.safeLogClick({
        eventId: currentEventId,
        linkType: linkType,
        surface: 'public',
        sessionId: window.SponsorUtils?.getSessionId?.() || '',
        visibleSponsorIds: currentRenderedSponsorIds
      });
    }

    // === Google Sheets "Bring Your Own Data" ===

    // Detect if URL is a Google Sheets URL and extract sheet ID
    function parseGoogleSheetUrl(url) {
      if (!url) return null;
      const match = url.match(/docs\.google\.com\/spreadsheets\/d\/([a-zA-Z0-9_-]+)/);
      if (match) {
        return { sheetId: match[1], originalUrl: url };
      }
      return null;
    }

    // Convert Google Sheets URL to CSV export URL
    function getSheetCsvUrl(sheetId, sheetName = '') {
      let csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv`;
      if (sheetName) csvUrl += `&sheet=${encodeURIComponent(sheetName)}`;
      return csvUrl;
    }

    // Fetch and parse CSV data from Google Sheets
    async function fetchSheetData(url) {
      const sheetInfo = parseGoogleSheetUrl(url);
      if (!sheetInfo) return null; // Not a Google Sheet, fallback to link

      try {
        const csvUrl = getSheetCsvUrl(sheetInfo.sheetId);
        const response = await fetch(csvUrl);
        if (!response.ok) return null;

        const csvText = await response.text();
        return parseCSV(csvText);
      } catch (e) {
        console.warn('Failed to fetch sheet data:', e);
        return null; // Fallback to link on error
      }
    }

    // Simple CSV parser (handles quoted fields)
    function parseCSV(csv) {
      const lines = csv.split('\n').filter(line => line.trim());
      if (lines.length === 0) return { headers: [], rows: [] };

      const parseRow = (line) => {
        const result = [];
        let current = '';
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      };

      const headers = parseRow(lines[0]);
      const rows = lines.slice(1).map(parseRow);
      return { headers, rows };
    }

    // Render standings table from sheet data
    function renderStandingsTable(data) {
      if (!data || !data.rows || !data.rows.length) return '<p class="muted">No standings data available.</p>';

      let html = '<table class="data-table standings-table">';
      html += '<thead><tr>';
      data.headers.forEach((h, i) => {
        html += `<th>${esc(h)}</th>`;
      });
      html += '</tr></thead><tbody>';

      data.rows.forEach((row, idx) => {
        html += `<tr class="${idx < 3 ? 'top-rank' : ''}">`;
        row.forEach((cell, i) => {
          if (i === 0) {
            html += `<td><span class="rank">${idx + 1}</span> ${esc(cell)}</td>`;
          } else {
            html += `<td>${esc(cell)}</td>`;
          }
        });
        html += '</tr>';
      });

      html += '</tbody></table>';
      return html;
    }

    // Render schedule/agenda from sheet data
    function renderScheduleTable(data) {
      if (!data || !data.rows || !data.rows.length) return '<p class="muted">No schedule data available.</p>';

      let html = '<div class="schedule-list">';
      data.rows.forEach(row => {
        const [time, title, description] = row;
        html += '<div class="schedule-item">';
        if (time) html += `<span class="schedule-time">${esc(time)}</span>`;
        if (title) html += `<span class="schedule-title">${esc(title)}</span>`;
        if (description) html += `<span class="schedule-desc">${esc(description)}</span>`;
        html += '</div>';
      });
      html += '</div>';
      return html;
    }

    // Render vendor list from sheet data
    function renderVendorList(data) {
      if (!data || !data.rows || !data.rows.length) return '<p class="muted">No vendor data available.</p>';

      let html = '<div class="vendor-grid">';
      data.rows.forEach(row => {
        const [name, description, url] = row;
        html += '<div class="vendor-card">';
        html += `<h4>${esc(name || 'Vendor')}</h4>`;
        if (description) html += `<p>${esc(description)}</p>`;
        if (url) html += `<a href="${esc(url)}" target="_blank" rel="noopener">Visit →</a>`;
        html += '</div>';
      });
      html += '</div>';
      return html;
    }

    // Render bracket/tournament from sheet data
    // Supports formats: Round, Match, Team1, Score1, Team2, Score2 -OR- Team1, Team2, Winner, Score
    function renderBracketTable(data) {
      if (!data || !data.rows || !data.rows.length) return '<p class="muted">No bracket data available.</p>';

      // Detect format based on headers
      const headers = data.headers.map(h => h.toLowerCase());
      const hasRound = headers.some(h => h.includes('round'));

      let html = '<div class="bracket-container">';

      if (hasRound) {
        // Group by round for tournament bracket view
        const rounds = {};
        data.rows.forEach(row => {
          const round = row[0] || 'Round 1';
          if (!rounds[round]) rounds[round] = [];
          rounds[round].push(row.slice(1)); // Rest of columns are match data
        });

        html += '<div class="bracket-rounds">';
        Object.keys(rounds).forEach(round => {
          html += `<div class="bracket-round">`;
          html += `<h4 class="round-title">${esc(round)}</h4>`;
          rounds[round].forEach(match => {
            html += renderBracketMatch(match, headers.slice(1));
          });
          html += '</div>';
        });
        html += '</div>';
      } else {
        // Simple match list format
        html += '<div class="bracket-matches">';
        data.rows.forEach((row, idx) => {
          html += `<div class="bracket-match-row">`;
          html += `<span class="match-num">#${idx + 1}</span>`;
          html += renderBracketMatch(row, headers);
          html += '</div>';
        });
        html += '</div>';
      }

      html += '</div>';
      return html;
    }

    // Render a single bracket match
    function renderBracketMatch(row, headers) {
      // Try to identify team columns and scores
      const team1 = row[0] || '—';
      const team2 = row[headers.indexOf('team2') > -1 ? headers.indexOf('team2') : 2] || row[2] || '—';
      const score1 = row[1] || '';
      const score2 = row[3] || '';
      const winner = row[headers.indexOf('winner') > -1 ? headers.indexOf('winner') : row.length - 1] || '';

      let html = '<div class="bracket-match">';
      html += `<div class="match-team ${winner && winner.toLowerCase() === team1.toLowerCase() ? 'winner' : ''}">`;
      html += `<span class="team-name">${esc(team1)}</span>`;
      if (score1) html += `<span class="team-score">${esc(score1)}</span>`;
      html += '</div>';
      html += '<div class="match-vs">vs</div>';
      html += `<div class="match-team ${winner && winner.toLowerCase() === team2.toLowerCase() ? 'winner' : ''}">`;
      html += `<span class="team-name">${esc(team2)}</span>`;
      if (score2) html += `<span class="team-score">${esc(score2)}</span>`;
      html += '</div>';
      html += '</div>';
      return html;
    }

    // ═══════════════════════════════════════════════════════════════
    // V2 COMMENTED OUT - getCTAUrl references many non-schema fields
    // MVP relies on event.ctas.primary.url / event.ctas.secondary.url
    // V2 FEATURE – NOT MVP: Remove this legacy function after Admin CTA refactor
    // ═══════════════════════════════════════════════════════════════
    // function getCTAUrl(data, label) {
    //   const labelLower = label.toLowerCase();
    //   // Map common CTA labels to data fields
    //   if (labelLower.includes('register') || labelLower.includes('rsvp')) return data.registerUrl || data.signupUrl;
    //   if (labelLower.includes('sign up')) return data.signupUrl || data.registerUrl;
    //   if (labelLower.includes('donate')) return data.donationUrl;
    //   if (labelLower.includes('ticket')) return data.ticketUrl || data.registerUrl;
    //   if (labelLower.includes('registry')) return data.registryUrl;
    //   if (labelLower.includes('schedule') || labelLower.includes('itinerary')) return data.scheduleUrl;
    //   if (labelLower.includes('standing')) return data.standingsUrl;
    //   if (labelLower.includes('bracket')) return data.bracketUrl;
    //   if (labelLower.includes('photo') || labelLower.includes('album')) return data.albumUrl;
    //   if (labelLower.includes('download')) return data.downloadUrl;
    //   if (labelLower.includes('vendor')) return data.vendorListUrl;
    //   if (labelLower.includes('calendar')) return buildGoogleCalendarUrl(data);
    //   if (labelLower.includes('direction') || labelLower.includes('map')) return buildMapsUrl(data.location);
    //   if (labelLower.includes('rule')) return data.rulesUrl;
    //   if (labelLower.includes('roster') || labelLower.includes('team')) return data.rosterUrl;
    //   // Fallback to generic URLs
    //   return data.registerUrl || data.signupUrl || data.summaryLink;
    // }

    // Build Google Maps URL from location string
    function buildMapsUrl(location) {
      if (!location) return null;
      const encoded = encodeURIComponent(location);
      return `https://www.google.com/maps/search/?api=1&query=${encoded}`;
    }

    /**
     * Format price from cents to display string
     * PAYMENTS SEAM: Stripe uses smallest currency unit (cents)
     * @param {number} price - Price in smallest currency unit (e.g., 1500 = $15.00)
     * @param {string} currency - Currency code (e.g., 'USD')
     * @returns {string} Formatted price string (e.g., '$15.00')
     */
    function formatPrice(price, currency) {
      if (!price || !currency) return '';
      try {
        // Convert from cents to dollars
        const amount = price / 100;
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: currency.toUpperCase()
        }).format(amount);
      } catch (e) {
        // Fallback for unsupported currencies
        return `${currency} ${(price / 100).toFixed(2)}`;
      }
    }

    /**
     * Build Google Calendar URL
     * EVENT_CONTRACT.md v2.0: Uses canonical fields
     * - data.name (from event.name)
     * - data.dateISO (from event.startDateISO)
     * - data.venue (from event.venue)
     */
    function buildGoogleCalendarUrl(data) {
      if (!data.name || !data.dateISO) return null;
      const params = new URLSearchParams();
      params.set('action', 'TEMPLATE');
      params.set('text', data.name);

      // Format date: YYYYMMDD (MVP v2.0 has date only, no time)
      const startDate = data.dateISO.replace(/-/g, '');
      params.set('dates', `${startDate}/${startDate}`);

      // MVP-frozen: Use only canonical venue field (no legacy fallback)
      if (data.venue) {
        params.set('location', data.venue);
      }

      return `https://calendar.google.com/calendar/render?${params.toString()}`;
    }

    /**
     * Generate ICS file content for Apple/Outlook
     * EVENT_CONTRACT.md v2.0: Uses canonical fields
     * - data.name (from event.name)
     * - data.dateISO (from event.startDateISO)
     * - data.venue (from event.venue)
     */
    function generateICS(data) {
      if (!data.name || !data.dateISO) return null;

      // Format date: YYYYMMDD (MVP v2.0 has date only, no time)
      const start = data.dateISO.replace(/-/g, '');
      const end = start;

      // MVP-frozen: Use only canonical venue field (no legacy fallback)
      const venueStr = data.venue || '';

      const ics = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//EventAngle//Event//EN',
        'BEGIN:VEVENT',
        `DTSTART;VALUE=DATE:${start}`,
        `DTEND;VALUE=DATE:${end}`,
        `SUMMARY:${data.name.replace(/[,;\\]/g, ' ')}`,
        venueStr ? `LOCATION:${venueStr.replace(/[,;\\]/g, ' ')}` : '',
        `UID:${Date.now()}@eventangle.com`,
        'END:VEVENT',
        'END:VCALENDAR'
      ].filter(Boolean).join('\r\n');

      return ics;
    }

    // Download ICS file
    function downloadICS(data) {
      const ics = generateICS(data);
      if (!ics) return;

      const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${(data.name || 'event').replace(/[^a-z0-9]/gi, '-')}.ics`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('Calendar file downloaded');
    }

    // Share event (Web Share API with clipboard fallback)
    async function shareEvent(data) {
      const shareData = {
        title: data.name || 'Event',
        text: `Check out this event: ${data.name}`,
        url: window.location.href
      };

      if (navigator.share && navigator.canShare && navigator.canShare(shareData)) {
        try {
          await navigator.share(shareData);
        } catch (err) {
          if (err.name !== 'AbortError') {
            copyToClipboard();
          }
        }
      } else {
        copyToClipboard();
      }
    }

    // Copy link to clipboard
    function copyToClipboard() {
      navigator.clipboard.writeText(window.location.href).then(() => {
        showToast('Link copied to clipboard');
      }).catch(() => {
        // Fallback for older browsers
        const input = document.createElement('input');
        input.value = window.location.href;
        document.body.appendChild(input);
        input.select();
        document.execCommand('copy');
        document.body.removeChild(input);
        showToast('Link copied to clipboard');
      });
    }

    // Toggle calendar dropdown
    function toggleCalendarDropdown(e) {
      e.stopPropagation();
      const dropdown = e.target.closest('.calendar-dropdown');
      dropdown.classList.toggle('open');

      // Close when clicking outside
      const closeDropdown = () => {
        dropdown.classList.remove('open');
        document.removeEventListener('click', closeDropdown);
      };
      if (dropdown.classList.contains('open')) {
        setTimeout(() => document.addEventListener('click', closeDropdown), 0);
      }
    }

    // Store current event data for utility functions
    let currentEventData = null;

    // NOTE: Legacy renderSponsorBanner* functions removed in E-003
    // All sponsor rendering now uses SponsorUtils.SponsorRenderer

    /**
     * Render event list view
     * SCHEMA: /schemas/event.schema.json
     * Uses: event.name, event.startDateISO, event.venue
     */
    async function renderList(items) {
      const root = document.getElementById('list');
      root.innerHTML = '';
      if (!items || !items.length) {
        // S12: Use shared StateRenderer for consistent empty state
        SharedUtils.StateRenderer.showNoData(root, { context: 'events' });
        return;
      }
      for (const event of items) {
        // Schema fields: name, startDateISO, venue
        const name = event.name || '(untitled)';
        const startDateISO = event.startDateISO || '';
        const venue = event.venue || '';

        // Format date for display
        let dateDisplay = '';
        if (startDateISO) {
          const date = new Date(startDateISO + 'T00:00:00');
          dateDisplay = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        }

        // Status badge based on date
        let statusBadge = '';
        if (startDateISO) {
          const eventDate = new Date(startDateISO + 'T00:00:00');
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          if (eventDate.getTime() === today.getTime()) {
            statusBadge = '<span class="status-badge active" style="font-size:0.65rem;padding:2px 6px;">Today</span>';
          }
        }

        const d = document.createElement('div');
        d.className = 'event-card';
        d.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:flex-start;">
            <h3 style="flex:1;">${esc(name)}</h3>
            ${statusBadge}
          </div>
          ${dateDisplay ? `<p>📅 ${esc(dateDisplay)}</p>` : ''}
          ${venue ? `<p>📍 ${esc(venue)}</p>` : ''}
          <div style="margin-top:12px;">
            <a class="btn secondary" href="${EXEC_URL}?p=events&brand=${BRAND}&id=${event.id}">View Details →</a>
          </div>
        `;
        root.appendChild(d);
      }
    }

    /**
     * Render event detail view
     * API: api_getPublicBundle → { event, config, lifecyclePhase }
     * SCHEMA: /schemas/event.schema.json
     *
     * See file header for complete field mapping.
     * @param {Object} lifecyclePhase - { phase: string, label: string, isLive: boolean } from bundle
     */
    async function renderDetail(event, config = {}, lifecyclePhase = null) {
      const root = document.getElementById('list');

      // === SCHEMA FIELDS (MVP REQUIRED) ===
      const eventId = event.id;
      const eventName = event.name;
      const startDateISO = event.startDateISO;
      const venue = event.venue;
      const ctas = event.ctas || { primary: { label: 'Sign Up', url: '' }, secondary: null };
      const settings = event.settings || { showSchedule: false, showStandings: false, showBracket: false, showSponsors: false };
      const links = event.links || {};

      // === SCHEMA FIELDS (MVP OPTIONAL) ===
      const schedule = event.schedule || [];
      const standings = event.standings || [];
      const bracket = event.bracket || null;

      // === SCHEMA FIELDS (V2 OPTIONAL) ===
      const sponsors = event.sponsors || [];
      const media = event.media || {};
      const externalData = event.externalData || {};

      // === PAYMENTS SEAM (Reserved - Stripe integration) ===
      const payments = event.payments || { enabled: false, provider: 'stripe', checkoutUrl: null };

      // Set currentEventId for analytics tracking
      currentEventId = eventId;

      // Build data object for utility functions (calendar, maps, share)
      const data = {
        name: eventName,
        dateISO: startDateISO,
        venue: venue,
        ctas: ctas,
        links: links,
        settings: settings
      };
      currentEventData = data;

      // === SETTINGS-BASED VISIBILITY ===
      // /schemas/event.schema.json Settings: showSchedule, showStandings, showBracket, showSponsors
      // Feature 4: Template-Aware Section Toggles - added showVideo, showMap, showGallery
      const sectionEnabled = (key) => {
        switch (key) {
          case 'schedule': return settings.showSchedule === true;
          case 'standings': return settings.showStandings === true;
          case 'bracket': return settings.showBracket === true;
          case 'sponsors': return settings.showSponsors === true;
          // Feature 4: Template-Aware Content Sections
          case 'video': return settings.showVideo !== false; // Default true for backwards compat
          case 'map': return settings.showMap !== false;     // Default true for backwards compat
          case 'gallery': return settings.showGallery !== false; // Default true for backwards compat
          default: return false; // Unknown keys are not schema-valid
        }
      };

      // === SPONSOR BANNER (V2 Optional) ===
      // Schema: event.sponsors[].placement MUST be 'public' - no fallback
      // Feature: Gated by settings.showSponsors (master) AND settings.showSponsorBanner (default: true)
      const sponsorBanner = document.getElementById('sponsorBanner');
      if (sectionEnabled('sponsors') && (settings.showSponsorBanner !== false) && sponsors.length > 0) {
        // Use centralized SponsorRenderer with placement filter (E-003 centralization)
        const { SponsorRenderer } = window.SponsorUtils;
        const carousel = SponsorRenderer.renderCarousel({
          container: sponsorBanner,
          sponsors: sponsors,
          placement: 'public',  // Filter to public placement only
          eventId: eventId,
          surface: 'public',
          showTier: true,
          rotationMs: 5000,
          onRender: ids => { currentRenderedSponsorIds = ids; }
        });
        // Store stop function for cleanup if needed
        window._sponsorCarouselStop = carousel.stop;
        // Hide if no sponsors matched placement filter
        if (!carousel.sponsors.length) {
          sponsorBanner.innerHTML = '';
          sponsorBanner.hidden = true;
        }
      } else {
        // Reserved: Sponsor bar exists but hidden when no sponsors
        sponsorBanner.innerHTML = '';
        sponsorBanner.hidden = true;
      }

      // Build event detail HTML
      let html = '<div class="event-detail">';

      // Header with name and meta
      html += '<div class="event-header">';

      // Use lifecycle phase from bundle (single source of truth) for consistent display
      // Falls back to local computation if bundle doesn't include lifecyclePhase
      let phase = lifecyclePhase;
      if (!phase && startDateISO) {
        // Fallback: compute locally (same algorithm as backend)
        const eventDate = new Date(startDateISO + 'T00:00:00');
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const eventDay = new Date(eventDate);
        eventDay.setHours(0, 0, 0, 0);

        if (eventDay.getTime() === today.getTime()) {
          phase = { phase: 'event-day', label: 'Event Day - Live', isLive: true };
        } else if (eventDay > today) {
          phase = { phase: 'pre-event', label: 'Pre-Event Preparation', isLive: false };
        } else {
          phase = { phase: 'post-event', label: 'Post-Event Analytics', isLive: false };
        }
      }

      // Display lifecycle phase indicator (same style as Admin and Display)
      let lifecycleIndicator = '';
      if (phase) {
        lifecycleIndicator = `<span class="phase-indicator ${esc(phase.phase)}" data-testid="lifecycle-indicator" data-phase="${esc(phase.phase)}">${esc(phase.label)}</span>`;
      }

      html += `<div style="margin-bottom: 12px;">${lifecycleIndicator}</div>`;

      // EVENT_CONTRACT.md v2.0: event.name (MVP Required)
      html += `<h1>${esc(eventName || '(untitled)')}</h1>`;

      // Meta information - event.startDateISO + event.venue (MVP Required)
      html += '<div class="event-meta">';
      if (startDateISO) {
        const date = new Date(startDateISO + 'T00:00:00');
        html += `<div class="event-meta-item"><strong>📅</strong> ${date.toLocaleDateString('en-US', {
          weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        })}</div>`;
      }
      if (venue) {
        html += `<div class="event-meta-item"><strong>📍</strong> ${esc(venue)}</div>`;
      }
      html += '</div>';
      html += '</div>';

      // === ACTION ROW (event.ctas.primary / event.ctas.secondary) ===
      html += '<div class="action-buttons">';

      // Primary CTA (MVP Required) - trust event.ctas.primary
      // PAYMENTS SEAM: If payments.enabled && payments.checkoutUrl, override with checkout link
      if (payments.enabled && payments.checkoutUrl) {
        // Stripe checkout flow - use payment icon and checkout URL
        const priceLabel = payments.price && payments.currency
          ? ` - ${formatPrice(payments.price, payments.currency)}`
          : '';
        html += `<a class="btn-primary" href="${esc(payments.checkoutUrl)}" target="_blank" rel="noopener">💳 ${esc(ctas.primary?.label || 'Buy Tickets')}${priceLabel}</a>`;
      } else if (ctas.primary?.url) {
        html += `<a class="btn-primary" href="${esc(ctas.primary.url)}" target="_blank" rel="noopener">📝 ${esc(ctas.primary.label || 'Sign Up')}</a>`;
      } else if (ctas.primary?.label) {
        // CTA has label but no URL - show disabled state
        html += `<span class="btn-primary" style="opacity: 0.5; cursor: not-allowed;">📝 ${esc(ctas.primary.label)}</span>`;
      }

      // Secondary CTA (optional) - trust event.ctas.secondary
      if (ctas.secondary?.url && ctas.secondary?.label) {
        html += `<a class="btn-secondary" href="${esc(ctas.secondary.url)}" target="_blank" rel="noopener">${esc(ctas.secondary.label)}</a>`;
      }

      // Back to all events - use links.publicUrl base or fallback
      html += `<a class="btn-secondary" href="${EXEC_URL}?p=events&brand=${BRAND}">← All Events</a>`;
      html += '</div>';

      // === UTILITY BUTTONS: Maps, Calendar, Share ===
      html += '<div class="utility-buttons">';

      // Open in Maps - use media.mapUrl or build from venue
      // Feature 4: Gated by settings.showMap (template-aware toggle)
      if (sectionEnabled('map')) {
        if (media.mapUrl) {
          // Direct map URL from event.media.mapUrl (V2 Optional)
          html += `<a class="btn-utility" href="${esc(media.mapUrl)}" target="_blank" rel="noopener">📍 Open in Maps</a>`;
        } else if (venue) {
          // Build Google Maps search URL from event.venue (MVP Required)
          const mapsUrl = buildMapsUrl(venue);
          html += `<a class="btn-utility" href="${esc(mapsUrl)}" target="_blank" rel="noopener">📍 Open in Maps</a>`;
        }
      }

      // Add to Calendar (Google URL + .ics) - uses event.startDateISO
      if (startDateISO) {
        const gcalUrl = buildGoogleCalendarUrl(data);
        html += `
          <div class="calendar-dropdown">
            <button class="btn-utility" onclick="toggleCalendarDropdown(event)">📅 Add to Calendar</button>
            <div class="calendar-menu">
              <a href="${esc(gcalUrl || '#')}" target="_blank" rel="noopener">📆 Google Calendar</a>
              <a href="#" onclick="event.preventDefault(); downloadICS(currentEventData);">📱 Apple / Outlook (.ics)</a>
            </div>
          </div>
        `;
      }

      // Share / Copy Link - uses current page URL
      html += `<button class="btn-utility" onclick="shareEvent(currentEventData)">🔗 Share / Copy Link</button>`;

      html += '</div>';

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - imageUrl NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add event.media.heroImageUrl to schema when ready
      // ═══════════════════════════════════════════════════════════════
      // if (data.imageUrl) {
      //   html += `<img src="${esc(data.imageUrl)}" alt="${esc(data.name || 'Event')}" class="event-image">`;
      // }

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - summary/summaryLink NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add event.description field to schema when ready
      // ═══════════════════════════════════════════════════════════════
      // if (data.summary || data.summaryLink) {
      //   html += '<div class="event-section">';
      //   html += '<h2>About This Event</h2>';
      //   if (data.summary) {
      //     html += `<p>${esc(data.summary)}</p>`;
      //   }
      //   if (data.summaryLink) {
      //     html += `<p><a href="${esc(data.summaryLink)}" target="_blank" rel="noopener">Learn more →</a></p>`;
      //   }
      //   html += '</div>';
      // }

      // Video Section - uses event.media.videoUrl (V2 OPTIONAL per /schemas/event.schema.json)
      // Feature 4: Gated by settings.showVideo (template-aware toggle)
      if (sectionEnabled('video') && media.videoUrl) {
        html += '<div class="event-section">';
        html += '<h2>Video</h2>';

        // Validate and sanitize video URL with strict regex
        const videoUrl = String(media.videoUrl);
        let embedUrl = null;
        let isValidVideo = false;

        // YouTube validation with strict regex
        const youtubeRegex = /^https?:\/\/(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11}).*$/;
        const youtubeMatch = videoUrl.match(youtubeRegex);
        if (youtubeMatch) {
          const videoId = youtubeMatch[3];
          // Additional validation: ensure videoId is exactly 11 chars and alphanumeric
          if (videoId && videoId.length === 11 && /^[a-zA-Z0-9_-]+$/.test(videoId)) {
            embedUrl = `https://www.youtube.com/embed/${esc(videoId)}`;
            isValidVideo = true;
          }
        }

        // Vimeo validation with strict regex
        if (!isValidVideo) {
          const vimeoRegex = /^https?:\/\/(www\.)?vimeo\.com\/(\d+).*$/;
          const vimeoMatch = videoUrl.match(vimeoRegex);
          if (vimeoMatch) {
            const videoId = vimeoMatch[2];
            // Additional validation: ensure videoId is numeric
            if (videoId && /^\d+$/.test(videoId)) {
              embedUrl = `https://player.vimeo.com/video/${esc(videoId)}`;
              isValidVideo = true;
            }
          }
        }

        if (isValidVideo && embedUrl) {
          html += `<iframe src="${embedUrl}" class="event-video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`;
        } else {
          // Fallback to link for invalid or unsupported videos
          html += `<p><a href="${esc(videoUrl)}" target="_blank" rel="noopener">Watch Video →</a></p>`;
        }
        html += '</div>';
      }

      // Gallery Section - uses event.media.gallery (V2 OPTIONAL per /schemas/event.schema.json)
      // Feature 4: Gated by settings.showGallery (template-aware toggle)
      // media.gallery is an array of URLs, not comma-separated string
      if (sectionEnabled('gallery') && media.gallery && Array.isArray(media.gallery) && media.gallery.length > 0) {
        html += '<div class="event-section">';
        html += '<h2>Gallery</h2>';
        html += '<div class="gallery">';
        media.gallery.forEach(url => {
          html += `<img src="${esc(url)}" alt="Event photo" loading="lazy">`;
        });
        html += '</div>';
        html += '</div>';
      }

      // Schedule Section - uses event.schedule (MVP Optional) + event.settings.showSchedule
      // Week 3 MVP: Show section with TBD placeholder when enabled but empty
      if (sectionEnabled('schedule')) {
        html += '<div class="event-section">';
        html += '<h2>Schedule</h2>';
        if (schedule.length > 0) {
          // Render from event.schedule[] per schema
          html += '<div class="schedule-list">';
          schedule.forEach(item => {
            html += `<div class="schedule-item">`;
            if (item.time) html += `<span class="schedule-time">${esc(item.time)}</span>`;
            if (item.title) html += `<span class="schedule-title">${esc(item.title)}</span>`;
            if (item.description) html += `<span class="schedule-desc">${esc(item.description)}</span>`;
            html += `</div>`;
          });
          html += '</div>';
        } else if (externalData.scheduleUrl) {
          // External data URL from event.externalData.scheduleUrl (V2 Optional)
          html += `<div id="schedule-container" data-url="${esc(externalData.scheduleUrl)}">
            <div class="loading-placeholder">Loading schedule...</div>
          </div>`;
        } else {
          // TBD placeholder when schedule is enabled but no data yet
          html += '<div class="empty-state" style="padding: 24px;">';
          html += '<p style="color: var(--color-gray-500); font-style: italic;">Schedule to be announced</p>';
          html += '</div>';
        }
        html += '</div>';
      }

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - albumUrl/downloadUrl NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add to media schema when template-specific features are ready
      // ═══════════════════════════════════════════════════════════════
      // Template-specific sections
      // Photo Album (photo_gallery, wedding, shower templates)
      // if (data.albumUrl) {
      //   html += '<div class="event-section">';
      //   html += '<h2>Photo Album</h2>';
      //   html += `<p><a class="btn-primary" href="${esc(data.albumUrl)}" target="_blank" rel="noopener">📸 View Photo Album</a></p>`;
      //   if (data.downloadUrl) {
      //     html += `<p><a class="btn-secondary" href="${esc(data.downloadUrl)}" target="_blank" rel="noopener">⬇️ Download All Photos</a></p>`;
      //   }
      //   html += '</div>';
      // }

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - registryUrl NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add to event schema when gift registry feature is ready
      // ═══════════════════════════════════════════════════════════════
      // Registry (wedding, shower templates)
      // if (data.registryUrl) {
      //   html += '<div class="event-section">';
      //   html += '<h2>Gift Registry</h2>';
      //   html += `<p><a class="btn-primary" href="${esc(data.registryUrl)}" target="_blank" rel="noopener">🎁 View Registry</a></p>`;
      //   html += '</div>';
      // }

      // === STANDINGS SECTION - uses event.standings (MVP Optional) + event.settings.showStandings ===
      // Week 3 MVP: Show section with TBD placeholder when enabled but empty
      if (sectionEnabled('standings')) {
        html += '<div class="event-section">';
        html += '<h2>Standings</h2>';
        if (standings.length > 0) {
          // Render from event.standings[] per schema
          html += '<table class="data-table standings-table">';
          html += '<thead><tr><th>Team</th><th>W</th><th>L</th><th>Pts</th></tr></thead>';
          html += '<tbody>';
          standings.forEach((row, idx) => {
            html += `<tr class="${idx < 3 ? 'top-rank' : ''}">`;
            html += `<td><span class="rank">${row.rank || idx + 1}</span> ${esc(row.team || '')}</td>`;
            html += `<td>${row.wins || 0}</td>`;
            html += `<td>${row.losses || 0}</td>`;
            html += `<td>${row.points || 0}</td>`;
            html += '</tr>';
          });
          html += '</tbody></table>';
        } else if (externalData.standingsUrl) {
          // External data URL from event.externalData.standingsUrl (V2 Optional)
          html += `<div id="standings-container" data-url="${esc(externalData.standingsUrl)}">
            <div class="loading-placeholder">Loading standings...</div>
          </div>`;
        } else {
          // TBD placeholder when standings is enabled but no data yet
          html += '<div class="empty-state" style="padding: 24px;">';
          html += '<p style="color: var(--color-gray-500); font-style: italic;">Standings to be announced</p>';
          html += '</div>';
        }
        html += '</div>';
      }

      // === BRACKET SECTION - uses event.bracket (MVP Optional) + event.settings.showBracket ===
      // Week 3 MVP: Show section with TBD placeholder when enabled but empty
      if (sectionEnabled('bracket')) {
        html += '<div class="event-section">';
        html += '<h2>Bracket</h2>';
        if (bracket && bracket.rounds && bracket.rounds.length > 0) {
          // Render from event.bracket per schema
          html += '<div class="bracket-container"><div class="bracket-rounds">';
          bracket.rounds.forEach(round => {
            html += `<div class="bracket-round">`;
            html += `<h4 class="round-title">${esc(round.name || 'Round')}</h4>`;
            html += '<div class="bracket-matches">';
            (round.matches || []).forEach(match => {
              html += '<div class="bracket-match">';
              html += `<div class="match-team ${match.winner === match.team1 ? 'winner' : ''}">`;
              html += `<span class="team-name">${esc(match.team1 || 'TBD')}</span>`;
              if (match.score1 !== undefined) html += `<span class="team-score">${match.score1}</span>`;
              html += '</div>';
              html += '<div class="match-vs">vs</div>';
              html += `<div class="match-team ${match.winner === match.team2 ? 'winner' : ''}">`;
              html += `<span class="team-name">${esc(match.team2 || 'TBD')}</span>`;
              if (match.score2 !== undefined) html += `<span class="team-score">${match.score2}</span>`;
              html += '</div>';
              html += '</div>';
            });
            html += '</div></div>';
          });
          html += '</div></div>';
        } else if (externalData.bracketUrl) {
          // External data URL from event.externalData.bracketUrl (V2 Optional)
          html += `<div id="bracket-container" data-url="${esc(externalData.bracketUrl)}">
            <div class="loading-placeholder">Loading bracket...</div>
          </div>`;
        } else {
          // TBD placeholder when bracket is enabled but no data yet
          html += '<div class="empty-state" style="padding: 24px;">';
          html += '<p style="color: var(--color-gray-500); font-style: italic;">Bracket to be announced</p>';
          html += '</div>';
        }
        html += '</div>';
      }

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - vendorListUrl NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add externalData.vendorsUrl to schema when vendor feature is ready
      // ═══════════════════════════════════════════════════════════════
      // Vendor List (farmers_market template) - supports Google Sheets BYOD
      // if (data.vendorListUrl) {
      //   html += '<div class="event-section">';
      //   html += '<h2>Vendors</h2>';
      //   html += `<div id="vendors-container" data-url="${esc(data.vendorListUrl)}">
      //     <div class="loading-placeholder">Loading vendors...</div>
      //   </div>`;
      //   html += '</div>';
      // }

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - goalAmount/raisedAmount/donationUrl NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add fundraising object to schema when donation feature is ready
      // ═══════════════════════════════════════════════════════════════
      // Donation Progress (fundraiser template)
      // if (data.goalAmount && data.raisedAmount !== undefined) {
      //   const progress = Math.min(100, Math.round((data.raisedAmount / data.goalAmount) * 100));
      //   html += '<div class="event-section">';
      //   html += '<h2>Fundraising Progress</h2>';
      //   html += `<div class="fundraising-progress">`;
      //   html += `<div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>`;
      //   html += `<p class="progress-text">$${data.raisedAmount.toLocaleString()} raised of $${data.goalAmount.toLocaleString()} goal (${progress}%)</p>`;
      //   html += `</div>`;
      //   if (data.donationUrl) {
      //     html += `<p><a class="btn-primary" href="${esc(data.donationUrl)}" target="_blank" rel="noopener">💝 Donate Now</a></p>`;
      //   }
      //   html += '</div>';
      // }

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - bio/bioLink/notes NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add description field to schema when rich text support is ready
      // ═══════════════════════════════════════════════════════════════
      // Bio/Notes Section (respects sections.notes) - uses custom label from template
      // if (data.bio || data.bioLink || data.notes) {
      //   html += '<div class="event-section">';
      //   html += `<h2>More Information</h2>`;
      //   if (data.notes) {
      //     html += `<p>${esc(data.notes)}</p>`;
      //   }
      //   if (data.bio) {
      //     html += `<p>${esc(data.bio)}</p>`;
      //   }
      //   if (data.bioLink) {
      //     html += `<p><a href="${esc(data.bioLink)}" target="_blank" rel="noopener">Read more →</a></p>`;
      //   }
      //   html += '</div>';
      // }

      // ═══════════════════════════════════════════════════════════════
      // V2 COMMENTED OUT - feedbackUrl NOT IN /schemas/event.schema.json
      // V2 FEATURE – NOT MVP: Add links.feedbackUrl to schema when feedback feature is ready
      // ═══════════════════════════════════════════════════════════════
      // Feedback Survey
      // if (data.feedbackUrl) {
      //   html += '<div class="event-section">';
      //   html += '<h2>Feedback</h2>';
      //   html += `<p><a class="btn-primary" href="${esc(data.feedbackUrl)}" target="_blank" rel="noopener">📋 Share Your Feedback</a></p>`;
      //   html += '</div>';
      // }

      html += '</div>';

      root.innerHTML = html;

      // Populate Google Sheets data asynchronously (BYOD)
      populateSheetData();
    }

    // Fetch and populate all sheet data containers
    async function populateSheetData() {
      const containers = [
        { id: 'schedule-container', renderer: renderScheduleTable },
        { id: 'standings-container', renderer: renderStandingsTable },
        { id: 'bracket-container', renderer: renderBracketTable },
        { id: 'vendors-container', renderer: renderVendorList }
      ];

      for (const { id, renderer } of containers) {
        const container = document.getElementById(id);
        if (!container) continue;

        const url = container.dataset.url;
        const sheetData = await fetchSheetData(url);

        if (sheetData && sheetData.rows.length > 0) {
          // Google Sheet data fetched - render styled
          container.innerHTML = renderer(sheetData);
        } else {
          // Not a Google Sheet or fetch failed - show link fallback
          container.innerHTML = `<p><a class="btn-secondary" href="${esc(url)}" target="_blank" rel="noopener">View Full Data →</a></p>`;
        }
      }
    }

    // S12/S13: Error state renderer using shared StateRenderer for consistent UX
    // Accepts either a type string or error object from safeRpc
    function showError(typeOrError = 'load') {
      const root = document.getElementById('list');
      const backUrl = `${EXEC_URL}?p=events&brand=${BRAND}`;

      // S13: Handle error objects from safeRpc (has code/message properties)
      if (typeOrError && typeof typeOrError === 'object' && typeOrError.code) {
        // Use showFromError which handles SERVICE_UNAVAILABLE, TIMEOUT, etc.
        SharedUtils.StateRenderer.showFromError(root, typeOrError, {
          onRetry: () => location.reload(),
          backUrl
        });
      } else if (typeOrError === 'notfound') {
        SharedUtils.StateRenderer.showEventNotFound(root, { backUrl });
      } else if (typeOrError === 'nodata') {
        SharedUtils.StateRenderer.showNoData(root, { context: 'content', backUrl });
      } else {
        SharedUtils.StateRenderer.showError(root, {
          title: 'Something Went Wrong',
          message: 'We couldn\'t load the events right now. This might be a temporary issue.',
          hint: 'Please try again in a moment.',
          onRetry: () => location.reload()
        });
      }
    }

    // Load event data
    // SCHEMA: /schemas/event.schema.json via Worker /api/v2/events/:id/bundle/public
    // Story 2.2/5.3: Uses Worker v2 endpoint (GAS retired)
    if (ID) {
      (async () => {
        // Story 2.2: Fetch from Worker endpoint (no GAS calls)
        const res = await fetchPublicBundleFromWorker(ID, BRAND);

        // Handle API errors with proper classification
        if (!res.ok) {
          console.error('API error:', res.code, res.message);
          showError(res);
          return;
        }

        try {
          if (res.value && res.value.event) {
            // getPublicBundle returns { event: Event, config: { ... }, lifecyclePhase: { phase, label, isLive } }
            const bundle = res.value;

            // === LOG PUBLIC VIEW METRIC (uses SponsorUtils.logEvent which is fire-and-forget) ===
            logEvent({ eventId: bundle.event.id, surface: 'public', metric: 'view', value: 1 });

            renderDetail(bundle.event, bundle.config, bundle.lifecyclePhase);
          } else if (res.value && !res.value.event) {
            // API returned ok but no event data
            showError('nodata');
          } else {
            showError('notfound');
          }
        } catch (renderErr) {
          console.error('Render error:', renderErr);
          showError('load');
        }
      })();
    } else {
      // List view - Story 2.2: Now uses Worker endpoint instead of GAS api_list
      (async () => {
        const res = await fetchEventsListFromWorker(BRAND);

        // Handle API errors with proper classification
        if (!res.ok) {
          console.error('API error:', res.code, res.message);
          showError(res);
          return;
        }

        try {
          if (res.value) {
            renderList(res.value.items || []);
          } else {
            showError('load');
          }
        } catch (renderErr) {
          console.error('Render error:', renderErr);
          showError('load');
        }
      })();
    }
  </script>
</body>
</html>
