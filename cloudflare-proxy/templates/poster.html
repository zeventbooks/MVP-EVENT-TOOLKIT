<!--
================================================================================
MVP SURFACE - Focus Group Critical
================================================================================
Page: Poster.html
Purpose: Printable event poster with QR codes and sponsor branding
Status: HARDENED for MVP v1.0

SCHEMA CONTRACT: /schemas/event.schema.json

═══════════════════════════════════════════════════════════════════════════════
READS FROM EVENT SCHEMA (via api_getPosterBundle):
═══════════════════════════════════════════════════════════════════════════════
  Identity (MVP Required):
    - event.id              → Analytics tracking
    - event.name            → #eventName heading
    - event.startDateISO    → #eventDate (formatted)
    - event.venue           → #eventLocation

  Links (MVP Required):
    - event.links.publicUrl → QR code label text
    - event.links.signupUrl → QR code label text

  QR Codes (MVP Required):
    - event.qr.public       → Public page QR (base64 PNG)
    - event.qr.signup       → Sign-up QR (base64 PNG)

  CTAs (MVP Required):
    - event.ctas.primary.label → Sign-up QR title text

  Settings (V2 Optional):
    - event.settings.showSponsors   → Master sponsor toggle
    - event.settings.showQRSection  → QR codes section visibility (default: true)

  Sponsors (V2 Optional):
    - event.sponsors[].id, name, logoUrl, linkUrl, placement
    - Filter: placement === 'poster'

═══════════════════════════════════════════════════════════════════════════════
SECTION GATES (schema-backed visibility):
═══════════════════════════════════════════════════════════════════════════════
  Sponsor Strip: if (settings.showSponsors && sponsors.some(s => s.placement === 'poster'))
  QR Codes:      if (settings.showQRSection !== false)
                 && (qr.public) → Public QR; if (qr.signup) → Signup QR

  INVARIANT: "NO QR UNLESS VERIFIED URL"
  Backend (_buildEventContract_ in Code.gs) enforces QR codes are ONLY
  generated for validated URLs. Poster trusts event.qr.* as pre-verified.
  DO NOT generate QR codes client-side from raw URL strings.

DO NOT add fields without updating:
  - /schemas/event.schema.json (source of truth)
  - src/mvp/Code.gs (_buildEventContract_)

Related MVP Surfaces: Admin, Display, Public, Sponsor, SharedReport
================================================================================
-->
<!DOCTYPE html>
<!--
  Template: Poster
  Bundled: 2025-12-13T18:30:37.121Z
  Hash: e52c18db
  Source: GAS templates (src/mvp/)
  Generator: scripts/bundle-worker-templates.js

  Variables (replaced at runtime):
  - <?= appTitle ?> - Page title
  - <?= brandId ?> - Brand identifier
  - <?= scope ?> - Scope (events, leagues, etc.)
  - <?= execUrl ?> - API endpoint URL
-->

<html>
<head>
  <meta charset="utf-8"/>
  <title><?= appTitle ?> · Poster</title>
  <style>
  /* ===== Zeventbook Design Tokens ===== */
  /*
    This file defines the design system foundation using CSS custom properties (variables).
    These tokens ensure consistent branding across Admin, Poster, Display, and Public pages.

    Usage: Include this file BEFORE Styles.html in all templates.
    Reference tokens using var(--token-name) in any CSS.
  */

  :root {
    /* ========== Color Palette ========== */

    /* Primary Brand Colors */
    --color-primary: #2563eb;           /* Main brand blue */
    --color-primary-dark: #1d4ed8;      /* Darker blue for hover states */
    --color-primary-light: #3b82f6;     /* Lighter blue for accents */
    --color-primary-bg: #eff6ff;        /* Light blue for selected backgrounds */
    --color-primary-pale: #dbeafe;      /* Very light blue for backgrounds */

    /* Semantic Colors */
    --color-success: #10b981;           /* Green for success states */
    --color-success-dark: #059669;      /* Darker green for hover */
    --color-success-light: #34d399;     /* Lighter green for accents */
    --color-success-bg: #dcfce7;        /* Light green for backgrounds */
    --color-success-pale: #d1fae5;      /* Very light green background */

    --color-danger: #ef4444;            /* Red for errors/warnings */
    --color-danger-dark: #dc2626;       /* Darker red for hover */
    --color-danger-pale: #fce7f3;       /* Light red background */

    --color-warning: #f59e0b;           /* Orange for warnings */
    --color-warning-dark: #d97706;      /* Darker orange for hover */
    --color-warning-darker: #78350f;    /* Darkest orange for text */
    --color-warning-light: #fbbf24;     /* Lighter orange for accents */
    --color-warning-bg: #fef3c7;        /* Light orange background */
    --color-warning-pale: #fed7aa;      /* Very light orange background */

    /* Neutral Palette (Slate) */
    --color-gray-50: #f8fafc;           /* Lightest gray - body background */
    --color-gray-100: #f1f5f9;          /* Light gray - hover backgrounds */
    --color-gray-200: #e2e8f0;          /* Border color, dividers */
    --color-gray-300: #cbd5e1;          /* Disabled states */
    --color-gray-400: #94a3b8;          /* Muted text */
    --color-gray-500: #64748b;          /* Secondary text */
    --color-gray-600: #475569;          /* Primary text */
    --color-gray-700: #334155;          /* Dark text */
    --color-gray-800: #1e293b;          /* Headings */
    --color-gray-900: #0f172a;          /* Darkest text */

    /* Sponsor Tier Colors */
    --color-sponsor-gold-bg: #fef3c7;   /* Gold sponsor background */
    --color-sponsor-gold-text: #92400e; /* Gold sponsor text */
    --color-sponsor-silver-bg: #e5e7eb; /* Silver sponsor background */
    --color-sponsor-silver-text: #374151; /* Silver sponsor text */
    --color-sponsor-bronze-bg: #fed7aa; /* Bronze sponsor background */
    --color-sponsor-bronze-text: #9a3412; /* Bronze sponsor text */

    /* Gradient Backgrounds (for stat cards) */
    --gradient-purple: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --gradient-blue: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
    --gradient-green: linear-gradient(135deg, #10b981 0%, #059669 100%);
    --gradient-orange: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    --gradient-red: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    --gradient-sponsor-bg: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);

    /* ========== Typography ========== */

    /* Font Families */
    --font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
    --font-family-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;

    /* Font Sizes */
    --font-size-xs: 0.75rem;    /* 12px */
    --font-size-sm: 0.875rem;   /* 14px */
    --font-size-base: 1rem;     /* 16px */
    --font-size-lg: 1.125rem;   /* 18px */
    --font-size-xl: 1.25rem;    /* 20px */
    --font-size-2xl: 1.5rem;    /* 24px */
    --font-size-3xl: 1.875rem;  /* 30px */
    --font-size-4xl: 2.25rem;   /* 36px */
    --font-size-5xl: 3rem;      /* 48px */

    /* Font Weights */
    --font-weight-normal: 400;
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;

    /* Line Heights */
    --line-height-tight: 1.2;
    --line-height-base: 1.6;
    --line-height-relaxed: 1.8;

    /* Letter Spacing */
    --letter-spacing-tight: -0.025em;
    --letter-spacing-normal: 0;
    --letter-spacing-wide: 0.025em;
    --letter-spacing-wider: 0.05em;

    /* ========== Spacing Scale ========== */

    --space-0: 0;
    --space-1: 0.25rem;   /* 4px */
    --space-2: 0.5rem;    /* 8px */
    --space-3: 0.75rem;   /* 12px */
    --space-4: 1rem;      /* 16px */
    --space-5: 1.25rem;   /* 20px */
    --space-6: 1.5rem;    /* 24px */
    --space-8: 2rem;      /* 32px */
    --space-10: 2.5rem;   /* 40px */
    --space-12: 3rem;     /* 48px */
    --space-16: 4rem;     /* 64px */
    --space-20: 5rem;     /* 80px */

    /* ========== Border Radius ========== */

    --radius-sm: 6px;     /* Small radius for inputs */
    --radius-base: 8px;   /* Base radius for buttons */
    --radius-md: 12px;    /* Medium radius for cards */
    --radius-lg: 16px;    /* Large radius for containers */
    --radius-full: 9999px; /* Full radius for pills/badges */

    /* ========== Shadows ========== */

    --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
    --shadow-base: 0 1px 3px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
    --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.1);
    --shadow-primary: 0 4px 12px rgba(37, 99, 235, 0.3);
    --shadow-primary-sm: 0 0 0 3px rgba(37, 99, 235, 0.1);
    --shadow-primary-alpha: rgba(37, 99, 235, 0.1);
    --focus-ring-color-alpha: rgba(37, 99, 235, 0.1);

    /* ========== Transitions ========== */

    --transition-fast: 0.15s ease;
    --transition-base: 0.2s ease;
    --transition-slow: 0.3s ease;

    /* ========== Layout ========== */

    --container-max-width: 1200px;
    --content-max-width: 800px;

    /* Grid Breakpoints (for reference in media queries) */
    --breakpoint-sm: 640px;
    --breakpoint-md: 768px;
    --breakpoint-lg: 1024px;
    --breakpoint-xl: 1440px;

    /* Touch Target Sizes (WCAG AAA) */
    --touch-target-min: 44px;
    --touch-target-comfortable: 48px;

    /* Card Padding (responsive 24/20/16 pattern) */
    --card-padding: 24px;         /* Desktop default */
    --card-padding-tablet: 20px;  /* Tablet */
    --card-padding-mobile: 16px;  /* Mobile */

    /* ========== Mobile-First Responsive Tokens ========== */

    /* Overflow prevention */
    --overflow-wrap: break-word;
    --word-break: break-word;

    /* Mobile container padding */
    --container-padding-mobile: 12px;
    --container-padding-tablet: 16px;
    --container-padding-desktop: 20px;

    /* Minimum readable font sizes */
    --font-size-mobile-min: 16px; /* Prevents iOS zoom on focus */
    --line-height-mobile: 1.5;

    /* Thumb-friendly spacing */
    --tap-spacing: 12px;          /* Minimum gap between tappable elements */

    /* Mobile-specific shadows (lighter for performance) */
    --shadow-mobile: 0 1px 2px rgba(0, 0, 0, 0.08);

    /* Safe bottom padding for fixed action buttons */
    --safe-bottom-padding: 80px;

    /* ========== Z-Index Scale ========== */

    --z-index-base: 1;
    --z-index-dropdown: 10;
    --z-index-sticky: 100;
    --z-index-modal: 1000;
    --z-index-overlay: 9999;

    /* ========== Surface-Specific Tokens ========== */

    /* Sponsor Logo Sizing (unified across surfaces) */
    --sponsor-logo-height: 60px;           /* Standard height for most surfaces */
    --sponsor-logo-height-sm: 40px;        /* Compact banners, mobile (640px and below) */
    --sponsor-logo-height-xs: 32px;        /* Very small mobile (375px and below) */
    --sponsor-logo-height-lg: 80px;        /* Large displays */
    --sponsor-logo-height-tv: 120px;       /* TV mode (10-foot viewing) */
    --sponsor-logo-max-width-mobile: 160px; /* Max width on mobile to prevent overflow */
    --sponsor-logo-gap-mobile: 10px;       /* Reduced gap on mobile */
    --sponsor-logo-max-width: 220px;       /* Max width to prevent overflow */
    --sponsor-logo-gap: 16px;              /* Gap between logos */

    /* Poster */
    --poster-border-width: 3px;
    --poster-qr-max-width: 250px;
    --poster-sponsor-logo-height: 70px;    /* Slightly larger for print */

    /* D-AUDIT: Print Safety Margins */
    /* Consumer printers typically need 0.5-1in unprintable margins */
    --print-margin-safe: 0.75in;        /* Safe margin for most printers */
    --print-margin-min: 0.5in;          /* Minimum margin for edge printers */
    --print-padding-inner: 0.25in;      /* Inner content padding */

    /* Display (TV/Kiosk) */
    --display-overlay-opacity: 0.95;
    --display-carousel-duration: 5s;
    --display-sponsor-logo-height-top: 72px;
    --display-sponsor-logo-height-side: 64px;

    /* TV Mode Colors (dark theme for 10ft viewing) */
    --color-tv-bg: #111111;
    --color-tv-bg-elevated: #1a1a1a;
    --color-tv-bg-card: #1f1f1f;
    --color-tv-border: #2a2a2a;
    --color-tv-border-hover: #3a3a3a;
    --color-tv-text: #eeeeee;
    --color-tv-text-muted: #aaaaaa;
    --color-tv-accent: #3b82f6;

    /* D-AUDIT: TV Mode Font Sizing (10ft viewing distance) */
    /* Minimum readable sizes for TV displays at 10-12ft viewing distance */
    --tv-font-size-min: 1rem;           /* 16px minimum for any text */
    --tv-font-size-label: 0.875rem;     /* 14px for labels (uppercase helps legibility) */
    --tv-font-size-body: 1.125rem;      /* 18px for body text */
    --tv-font-size-heading: 1.5rem;     /* 24px for headings */
    --tv-font-size-title: 2rem;         /* 32px for titles */

    /* Public Page */
    --public-hero-min-height: 300px;
    --public-card-hover-lift: -2px;

    /* Admin */
    --admin-sidebar-width: 250px;
    --admin-header-height: 64px;

    /* ========== Animation Durations ========== */

    --animation-spin: 1s;
    --animation-fade: 0.3s;
    --animation-slide: 0.4s;
  }

  /* ========== Dark Mode Tokens (Optional Future Enhancement) ========== */

  @media (prefers-color-scheme: dark) {
    :root {
      /* Currently not implemented, but tokens are ready for dark mode support */
      /* Uncomment and customize when ready to support dark mode:

      --color-gray-50: #0f172a;
      --color-gray-100: #1e293b;
      --color-gray-200: #334155;
      --color-gray-800: #f1f5f9;
      --color-gray-900: #f8fafc;

      */
    }
  }

  /* ========== Accessibility Tokens ========== */

  :root {
    /* Minimum contrast ratios (WCAG AA) */
    --contrast-min-normal: 4.5;   /* For normal text */
    --contrast-min-large: 3;      /* For large text (18px+) */

    /* Focus indicators */
    --focus-ring-width: 3px;
    --focus-ring-color: var(--color-primary);
    --focus-ring-offset: 2px;

    /* Reduced motion support */
    --animation-duration-default: var(--transition-base);
  }

  @media (prefers-reduced-motion: reduce) {
    :root {
      --animation-duration-default: 0.01ms;
      --transition-fast: 0.01ms;
      --transition-base: 0.01ms;
      --transition-slow: 0.01ms;
    }
  }
</style>

  <style>
  /* ===== Zeventbook Global Styles ===== */

  /* Reset & Base */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  /* Mobile-First: Prevent horizontal scroll globally */
  html, body {
    overflow-x: hidden;
    max-width: 100vw;
  }

  body {
    font-family: var(--font-family-base, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif);
    line-height: var(--line-height-base, 1.6);
    color: var(--color-gray-800, #1e293b);
    background: var(--color-gray-50, #f8fafc);
    /* Safe area support for notched devices (iPhone X+) */
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Mobile-first: prevent text overflow */
    word-wrap: break-word;
    overflow-wrap: break-word;
    -webkit-text-size-adjust: 100%;
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    /* Additional safe area padding on mobile */
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
  }

  /* Header */
  .site-header {
    background: white;
    border-bottom: 2px solid var(--color-primary, #2563eb);
    padding: 16px 0;
    margin-bottom: 24px;
    box-shadow: var(--shadow-sm, 0 2px 4px rgba(0,0,0,0.05));
  }

  .header-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
    display: flex;
    align-items: center;
    gap: 20px;
  }

  .header-logo {
    max-height: var(--sponsor-logo-height, 60px);
    width: auto;
  }

  /* TS-002: Using design token instead of hardcoded 1.8rem */
  .header-title h1 {
    color: var(--color-primary, #2563eb);
    font-size: 1.8rem;
    margin-bottom: 4px;
  }

  .build-info {
    color: var(--color-gray-500, #64748b);
    font-size: 0.85rem;
  }

  /* Cards - Standardized padding: 24px desktop / 20px tablet / 16px mobile */
  .card {
    background: white;
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding, 24px);
    margin-bottom: var(--space-6, 24px);
    box-shadow: var(--shadow-base, 0 1px 3px rgba(0,0,0,0.1));
    border-left: 4px solid var(--color-primary, #2563eb);
  }

  .card h2 {
    margin-bottom: 16px;
    color: var(--color-gray-800, #1e293b);
    font-size: 1.5rem;
    border-bottom: 2px solid var(--color-gray-200, #e2e8f0);
    padding-bottom: 8px;
  }

  /* Section separators for better information density */
  /* CR-001: Merged duplicate .card h3 rules into single coherent block */
  .card h3 {
    margin-top: 28px;
    margin-bottom: 16px;
    padding-top: 20px;
    border-top: 1px solid var(--color-gray-100, #f1f5f9);
  }

  .card h3:first-of-type {
    margin-top: var(--space-5, 20px);
    padding-top: 0;
    border-top: none;
  }

  .card h3 {
    margin-top: 20px;
    margin-bottom: 12px;
    color: var(--color-gray-600, #475569);
    font-size: 1.2rem;
  }

  .card h4 {
    margin-top: 16px;
    margin-bottom: 8px;
    color: var(--color-gray-500, #64748b);
    font-size: 1rem;
  }

  /* Forms */
  .form-group {
    margin-bottom: 20px;
  }

  /* Form rows - Mobile-first with better density */
  .form-row {
    display: grid;
    grid-template-columns: 1fr; /* Mobile: single column for clarity */
    gap: 20px; /* More breathing room */
    margin-bottom: 20px;
  }

  /* Tablet and up: side-by-side fields */
  @media (min-width: 640px) {
    .form-row {
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }
  }

  label {
    display: block;
    margin-bottom: 6px;
    color: var(--color-gray-600, #475569);
    font-weight: 500;
    font-size: 14px;
  }

  input[type="text"],
  input[type="email"],
  input[type="tel"],
  input[type="url"],
  input[type="date"],
  input[type="time"],
  input[type="number"],
  select,
  textarea {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--color-gray-200, #e2e8f0);
    border-radius: 6px;
    font-size: 14px;
    font-family: inherit;
    transition: border-color 0.2s, box-shadow 0.2s;
    min-height: 44px; /* WCAG 2.5.5 touch target minimum */
  }

  /* Disabled input states - accessibility enhancement */
  input:disabled,
  select:disabled,
  textarea:disabled {
    background-color: var(--color-gray-50, #f8fafc);
    color: var(--color-gray-400, #94a3b8);
    cursor: not-allowed;
    opacity: 0.65;
    border-color: var(--color-gray-300, #cbd5e1);
  }

  input:focus,
  select:focus,
  textarea:focus {
    outline: none;
    border-color: var(--color-primary, #2563eb);
    box-shadow: 0 0 0 3px var(--focus-ring-color-alpha, rgba(37, 99, 235, 0.1));
  }

  textarea {
    min-height: 80px;
    resize: vertical;
  }

  /* Buttons - Mobile-first, thumb-friendly 44px minimum tap target */
  .btn-primary {
    background: var(--color-primary, #2563eb);
    color: white;
    padding: 14px 28px;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 16px);
    font-weight: var(--font-weight-semibold, 600);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    display: inline-block;
    text-decoration: none;
    min-height: var(--touch-target-min, 44px);
    line-height: 1.2;
    text-align: center;
  }

  .btn-primary:hover {
    background: var(--color-primary-dark, #1d4ed8);
    transform: translateY(-1px);
    box-shadow: var(--shadow-primary, 0 4px 12px rgba(37, 99, 235, 0.3));
  }

  .btn-primary:active {
    transform: translateY(0);
  }

  .btn-secondary {
    background: white;
    color: var(--color-gray-600, #475569);
    padding: 12px 24px;
    border: 2px solid var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 15px);
    font-weight: var(--font-weight-medium, 500);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    display: inline-block;
    text-decoration: none;
    min-height: var(--touch-target-min, 44px);
    line-height: 1.2;
    text-align: center;
  }

  .btn-secondary:hover {
    background: var(--color-gray-50, #f8fafc);
    border-color: var(--color-primary, #2563eb);
    color: var(--color-primary, #2563eb);
  }

  .btn-success {
    background: var(--color-success, #10b981);
    color: white;
    padding: 14px 28px;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 16px);
    font-weight: var(--font-weight-semibold, 600);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    min-height: var(--touch-target-min, 44px);
  }

  .btn-success:hover {
    background: var(--color-success-dark, #059669);
  }

  .btn-danger {
    background: var(--color-danger, #ef4444);
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-base, 15px);
    font-weight: var(--font-weight-medium, 500);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s ease);
    min-height: var(--touch-target-min, 44px);
  }

  .btn-danger:hover {
    background: var(--color-danger-dark, #dc2626);
  }

  /* Disabled button states - accessibility enhancement */
  .btn-primary:disabled,
  .btn-secondary:disabled,
  .btn-success:disabled,
  .btn-danger:disabled,
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    pointer-events: none;
    transform: none;
    box-shadow: none;
  }

  .btn-primary:disabled {
    background-color: var(--color-gray-300, #cbd5e1);
  }

  .btn-secondary:disabled {
    background-color: var(--color-gray-100, #f1f5f9);
    border-color: var(--color-gray-300, #cbd5e1);
    color: var(--color-gray-400, #94a3b8);
  }

  .button-group {
    display: flex;
    gap: 12px;
    margin-top: 24px;
    flex-wrap: wrap;
  }

  /* Mobile: Stack buttons vertically with full width */
  @media (max-width: 640px) {
    .button-group {
      flex-direction: column;
      gap: 12px;
    }

    .button-group .btn-primary,
    .button-group .btn-secondary,
    .button-group .btn-success,
    .button-group .btn-danger {
      width: 100%;
      text-align: center;
    }
  }

  /* Tabs */
  .tabs {
    display: flex;
    gap: 8px;
    margin-bottom: var(--space-6, 24px);
    border-bottom: 2px solid var(--color-gray-200, #e2e8f0);
  }

  .tab-button {
    padding: 12px 24px;
    background: transparent;
    border: none;
    border-bottom: 3px solid transparent;
    font-size: var(--font-size-base, 15px);
    font-weight: var(--font-weight-medium, 500);
    color: var(--color-gray-500, #64748b);
    cursor: pointer;
    transition: all var(--transition-base, 0.2s);
    margin-bottom: -2px;
  }

  .tab-button:hover {
    color: var(--color-primary, #2563eb);
    background: var(--color-gray-100, #f1f5f9);
  }

  .tab-button.active {
    color: var(--color-primary, #2563eb);
    border-bottom-color: var(--color-primary, #2563eb);
    background: white;
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  /* Grids - Mobile-first responsive layout */
  .events-grid {
    display: grid;
    grid-template-columns: 1fr; /* Mobile: single column */
    gap: 16px;
    margin-top: 20px;
  }

  /* Tablet: 2 columns */
  @media (min-width: 640px) {
    .events-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
    }
  }

  /* Desktop: 3 columns */
  @media (min-width: 1024px) {
    .events-grid {
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
    }
  }

  /* Large desktop: 4 columns */
  @media (min-width: 1440px) {
    .events-grid {
      grid-template-columns: repeat(4, 1fr);
    }
  }

  .event-card {
    background: var(--color-gray-50, #f8fafc);
    border: 1px solid var(--color-gray-200, #e2e8f0);
    border-left: 3px solid var(--color-gray-500, #64748b); /* Subtle left accent for visual hierarchy */
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-tablet, 20px);
    transition: all var(--transition-base, 0.2s);
  }

  .event-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md, 0 4px 12px rgba(0,0,0,0.1));
    border-left-color: var(--color-primary, #2563eb); /* Blue accent on hover */
    background: white;
  }

  .event-card h3 {
    margin: 0 0 12px 0;
    color: var(--color-gray-800, #1e293b);
    font-size: 1.1rem;
  }

  .event-card h4 {
    margin: 0 0 8px 0;
    color: var(--color-gray-600, #475569);
    font-size: 1rem;
  }

  .event-card p {
    color: var(--color-gray-500, #64748b);
    margin-bottom: 8px;
    font-size: var(--font-size-sm, 14px);
  }

  .event-card small {
    color: var(--color-gray-400, #94a3b8);
    font-size: var(--font-size-xs, 12px);
  }

  /* QR Codes */
  .qr-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 24px;
    margin: 24px 0;
  }

  .qr-code {
    text-align: center;
    padding: var(--card-padding-tablet, 20px);
    background: var(--color-gray-50, #f8fafc);
    border-radius: var(--radius-md, 12px);
    border: 2px solid var(--color-gray-200, #e2e8f0);
  }

  .qr-code h3 {
    margin: 0 0 8px 0;
    color: var(--color-gray-800, #1e293b);
    font-size: 1rem;
  }

  .qr-code h4 {
    margin: 0 0 12px 0;
    color: var(--color-gray-600, #475569);
    font-size: 0.9rem;
  }

  .qr-code img {
    width: 100%;
    max-width: 250px;
    height: auto;
    margin: 12px auto;
    display: block;
  }

  .qr-code p {
    margin-top: 12px;
    color: var(--color-gray-500, #64748b);
    font-size: var(--font-size-sm, 13px);
    word-break: break-all;
  }

  /* Loading Overlay */
  .loading-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.95);
    z-index: 9999;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }

  .spinner {
    border: 4px solid var(--color-gray-200, #e2e8f0);
    border-top: 4px solid var(--color-primary, #2563eb);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .loading-overlay p {
    margin-top: 16px;
    color: var(--color-gray-500, #64748b);
    font-weight: var(--font-weight-medium, 500);
  }

  /* Utilities */
  .muted {
    color: var(--color-gray-400, #94a3b8);
    font-size: 0.9em;
  }

  .text-center {
    text-align: center;
  }

  .mt-1 { margin-top: 8px; }
  .mt-2 { margin-top: 16px; }
  .mt-3 { margin-top: 24px; }
  .mb-1 { margin-bottom: 8px; }
  .mb-2 { margin-bottom: 16px; }
  .mb-3 { margin-bottom: 24px; }

  /* Sponsor Badges */
  .sponsor-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
  }

  .sponsor-badge.gold {
    background: #fef3c7;
    color: #92400e;
  }

  .sponsor-badge.silver {
    background: #e5e7eb;
    color: #374151;
  }

  .sponsor-badge.bronze {
    background: #fed7aa;
    color: #9a3412;
  }

  /* Data Visualization Components */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin: 24px 0;
  }

  .stat-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: var(--space-6, 24px); /* D-AUDIT: Using design token for consistent rhythm */
    border-radius: var(--radius-md, 12px); /* D-AUDIT: Using design token for consistency */
    text-align: center;
    box-shadow: var(--shadow-md, 0 4px 12px rgba(0,0,0,0.1));
    transition: transform var(--transition-base, 0.2s ease);
  }

  .stat-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  }

  .stat-card.blue {
    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
  }

  .stat-card.green {
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  }

  .stat-card.purple {
    background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
  }

  .stat-card.orange {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  }

  .stat-card.red {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  }

  .stat-value {
    font-size: 2.5rem;
    font-weight: 700;
    line-height: 1;
    margin-bottom: 8px;
  }

  .stat-label {
    font-size: var(--font-size-sm, 0.875rem); /* D-AUDIT: Aligned to type scale from 0.9rem */
    opacity: 0.95;
    font-weight: var(--font-weight-medium, 500);
    text-transform: uppercase;
    letter-spacing: var(--letter-spacing-wide, 0.025em);
  }

  .stat-trend {
    margin-top: var(--space-2, 8px);
    font-size: var(--font-size-sm, 0.875rem); /* D-AUDIT: Aligned to type scale from 0.85rem */
    opacity: 0.9;
  }

  .stat-trend.up::before {
    content: '↑ ';
  }

  .stat-trend.down::before {
    content: '↓ ';
  }

  /* Progress Bars */
  .progress-bar {
    width: 100%;
    height: 8px;
    background: var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-sm, 4px);
    overflow: hidden;
    margin: 12px 0;
  }

  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--color-primary, #2563eb) 0%, var(--color-primary-light, #3b82f6) 100%);
    border-radius: var(--radius-sm, 4px);
    transition: width 0.3s ease;
  }

  .progress-bar-fill.green {
    background: linear-gradient(90deg, var(--color-success, #10b981) 0%, var(--color-success-light, #34d399) 100%);
  }

  .progress-bar-fill.orange {
    background: linear-gradient(90deg, var(--color-warning, #f59e0b) 0%, var(--color-warning-light, #fbbf24) 100%);
  }

  /* Phase Indicators */
  .phase-indicator {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 16px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .phase-indicator.pre-event {
    background: #dbeafe;
    color: #1e40af;
  }

  .phase-indicator.event-day {
    background: #d1fae5;
    color: #065f46;
  }

  .phase-indicator.post-event {
    background: #fce7f3;
    color: #9f1239;
  }

  .phase-indicator::before {
    content: '';
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: currentColor;
  }

  /* Metric Cards */
  .metric-card {
    background: white;
    border: 2px solid var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-tablet, 20px);
    transition: all var(--transition-base, 0.2s ease);
  }

  .metric-card:hover {
    border-color: var(--color-primary, #2563eb);
    box-shadow: 0 4px 12px var(--shadow-primary-alpha, rgba(37, 99, 235, 0.1));
  }

  .metric-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .metric-title {
    font-size: 0.9rem;
    color: var(--color-gray-500, #64748b);
    font-weight: var(--font-weight-medium, 500);
    text-transform: uppercase;
    letter-spacing: var(--letter-spacing-wide, 0.025em);
  }

  .metric-value {
    font-size: 2rem;
    font-weight: var(--font-weight-bold, 700);
    color: var(--color-gray-800, #1e293b);
    line-height: 1;
  }

  .metric-subtitle {
    margin-top: 8px;
    font-size: 0.85rem;
    color: var(--color-gray-400, #94a3b8);
  }

  /* Status Badges */
  .status-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
  }

  .status-badge.active {
    background: #d1fae5;
    color: #065f46;
  }

  .status-badge.upcoming {
    background: #dbeafe;
    color: #1e40af;
  }

  .status-badge.ended {
    background: #f1f5f9;
    color: #475569;
  }

  .status-badge::before {
    content: '';
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: currentColor;
  }

  /* Mobile Touch Optimizations */
  @media (max-width: 768px) {
    /* Increase tap targets for mobile */
    input[type="text"],
    input[type="email"],
    input[type="tel"],
    input[type="url"],
    input[type="date"],
    input[type="time"],
    input[type="number"],
    select {
      min-height: 44px;
      font-size: 16px; /* Prevents iOS zoom on focus */
    }

    /* Bottom-aligned sticky action buttons for one-handed use */
    .sticky-bottom-actions {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 12px 16px;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
      z-index: 100;
      border-top: 1px solid var(--color-gray-200, #e2e8f0);
    }

    .sticky-bottom-actions .btn-primary,
    .sticky-bottom-actions .btn-secondary {
      width: 100%;
      margin-bottom: 8px;
    }

    .sticky-bottom-actions .btn-primary:last-child,
    .sticky-bottom-actions .btn-secondary:last-child {
      margin-bottom: 0;
    }
  }

  /* Enhanced Sponsor Banners */
  .sponsor-banner {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 12px;
    margin: 24px 0;
  }

  .sponsor-logo {
    max-height: var(--sponsor-logo-height, 60px);
    width: auto;
    object-fit: contain;
    transition: transform var(--transition-base, 0.2s ease);
    cursor: pointer;
  }

  .sponsor-logo:hover {
    transform: scale(1.1);
  }

  .sponsor-banner.compact .sponsor-logo {
    max-height: 40px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .container {
      padding: 12px;
      /* Respect safe areas on mobile */
      padding-left: max(12px, env(safe-area-inset-left));
      padding-right: max(12px, env(safe-area-inset-right));
    }

    .card {
      padding: 16px; /* Reduced padding on mobile for better information density */
      border-radius: 8px; /* Slightly smaller border radius */
      margin-bottom: 16px;
    }

    .card h2 {
      font-size: 1.25rem; /* Slightly smaller headings on mobile */
    }

    .header-title h1 {
      font-size: 1.5rem;
    }

    .header-logo {
      max-height: 48px;
    }

    .form-row {
      grid-template-columns: 1fr;
    }

    .events-grid {
      grid-template-columns: 1fr;
    }

    .qr-grid {
      grid-template-columns: 1fr;
    }

    .stats-grid {
      grid-template-columns: 1fr;
    }

    .stat-value {
      font-size: 2rem;
    }

    .metric-value {
      font-size: 1.75rem;
    }

    .tabs {
      overflow-x: auto;
    }

    .tab-button {
      white-space: nowrap;
    }

    .button-group {
      flex-direction: column;
    }

    .button-group .btn-primary,
    .button-group .btn-secondary {
      width: 100%;
      text-align: center;
    }

    .sponsor-banner {
      padding: 16px;
      gap: 12px;
    }

    .sponsor-logo {
      max-height: var(--sponsor-logo-height-sm, 50px);
    }
  }

  /* ===== Alert Components ===== */
  .alert {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 12px 16px;
    border-radius: 8px;
    margin-bottom: 16px;
    font-size: 14px;
    font-weight: 500;
    animation: alert-slide-in 0.3s ease-out;
  }

  @keyframes alert-slide-in {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .alert-fade-out {
    animation: alert-fade-out 0.3s ease-out forwards;
  }

  @keyframes alert-fade-out {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(-10px);
    }
  }

  .alert-info {
    background: #dbeafe;
    color: #1e40af;
    border: 1px solid #93c5fd;
  }

  .alert-success {
    background: #dcfce7;
    color: #166534;
    border: 1px solid #86efac;
  }

  .alert-error {
    background: #fee2e2;
    color: #991b1b;
    border: 1px solid #fca5a5;
  }

  .alert-warning {
    background: #fef3c7;
    color: #92400e;
    border: 1px solid #fde68a;
  }

  .alert-dismiss {
    background: transparent;
    border: none;
    font-size: 20px;
    line-height: 1;
    cursor: pointer;
    opacity: 0.6;
    padding: 0 4px;
    color: inherit;
  }

  .alert-dismiss:hover {
    opacity: 1;
  }

  /* ===== Tier Badges ===== */
  .tier-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 9999px;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.025em;
  }

  .tier-badge.platinum,
  .tier-platinum {
    background: #e5e7eb;
    color: #1f2937;
  }

  .tier-badge.gold,
  .tier-gold {
    background: #fef3c7;
    color: #92400e;
  }

  .tier-badge.silver,
  .tier-silver {
    background: #f3f4f6;
    color: #374151;
  }

  .tier-badge.bronze,
  .tier-bronze {
    background: #fed7aa;
    color: #7c2d12;
  }

  /* ===== Form Validation States ===== */
  /* Full class names for specificity */
  .form-input-error,
  input.form-input-error,
  select.form-input-error,
  textarea.form-input-error,
  /* Short aliases (I-004) */
  .input-error,
  input.input-error,
  select.input-error,
  textarea.input-error {
    border-color: var(--color-danger, #ef4444) !important;
    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1) !important;
  }

  .form-input-success,
  input.form-input-success,
  select.form-input-success,
  textarea.form-input-success,
  /* Short aliases (I-004) */
  .input-success,
  input.input-success,
  select.input-success,
  textarea.input-success {
    border-color: var(--color-success, #10b981) !important;
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1) !important;
  }

  /* Validation message styling */
  .input-error-message,
  .form-error-message {
    color: var(--color-danger, #ef4444);
    font-size: var(--font-size-sm, 0.875rem);
    margin-top: 4px;
  }

  .input-success-message {
    color: var(--color-success, #10b981);
    font-size: var(--font-size-sm, 0.875rem);
    margin-top: 4px;
  }

  .form-hint {
    margin-top: 4px;
    font-size: var(--font-size-sm, 13px);
    color: var(--color-gray-500, #64748b);
  }

  .form-error-message {
    margin-top: 4px;
    font-size: var(--font-size-sm, 13px);
    color: var(--color-danger, #ef4444);
  }

  /* ===== Page Layout Components ===== */
  /* Shared page section styles (MVP: Admin.html, Public.html) */
  .page-section {
    background: white;
    border-radius: 16px;
    padding: 2rem;
    margin-bottom: 2rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  }

  .page-section h2 {
    margin: 0 0 1.5rem 0;
    font-size: 1.5rem;
    color: var(--color-gray-800, #1f2937);
    border-bottom: 2px solid var(--color-gray-200, #e5e7eb);
    padding-bottom: 0.75rem;
  }

  .page-header-card {
    background: white;
    border-radius: var(--radius-lg, 16px);
    padding: 2rem;
    margin-bottom: 2rem;
    box-shadow: var(--shadow-lg, 0 10px 30px rgba(0, 0, 0, 0.1));
  }

  .page-header-card h1 {
    margin: 0 0 0.5rem 0;
    font-size: 2rem;
    color: var(--color-gray-800, #1f2937);
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .page-header-card .subtitle {
    color: var(--color-gray-500, #6b7280);
    font-size: 1rem;
  }

  .nav-breadcrumb {
    margin-bottom: 1rem;
  }

  .nav-breadcrumb a {
    color: var(--color-primary, #2563eb);
    text-decoration: none;
    transition: color var(--transition-base, 0.2s);
  }

  .nav-breadcrumb a:hover {
    text-decoration: underline;
  }

  /* ===== Entity Card Grid ===== */
  /* Shared grid for sponsors, events, forms, etc. */
  .entity-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-top: 1.5rem;
  }

  .entity-card {
    background: var(--color-gray-50, #f9fafb);
    border: 2px solid var(--color-gray-200, #e5e7eb);
    border-radius: var(--radius-md, 12px);
    padding: 1.5rem;
    transition: all var(--transition-base, 0.2s);
  }

  .entity-card:hover {
    border-color: var(--color-primary, #2563eb);
    box-shadow: var(--shadow-md, 0 4px 12px rgba(0, 0, 0, 0.1));
  }

  .entity-card h3 {
    margin: 0 0 0.5rem 0;
    font-size: 1.25rem;
    color: var(--color-gray-800, #1f2937);
  }

  .entity-card-info {
    font-size: var(--font-size-sm, 0.875rem);
    color: var(--color-gray-500, #6b7280);
    margin-bottom: 0.5rem;
  }

  .entity-card-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }

  /* ===== Analytics Cards ===== */
  .analytics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
  }

  .analytics-card {
    background: var(--color-gray-50, #f9fafb);
    border: 2px solid var(--color-gray-200, #e5e7eb);
    border-radius: var(--radius-base, 8px);
    padding: 1.5rem;
    text-align: center;
    transition: all var(--transition-base, 0.2s);
  }

  .analytics-card:hover {
    border-color: var(--color-primary, #2563eb);
  }

  .analytics-card .value {
    font-size: 2rem;
    font-weight: var(--font-weight-bold, 700);
    color: var(--color-gray-800, #1f2937);
    margin-bottom: 0.5rem;
  }

  .analytics-card .label {
    font-size: var(--font-size-sm, 0.875rem);
    color: var(--color-gray-500, #6b7280);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* ===== Button Size Variants ===== */
  .btn-sm {
    padding: 8px 16px;
    font-size: 14px;
    min-height: 36px;
  }

  .btn-full {
    width: 100%;
  }

  /* ===== Retry Button (D-005: Centralized from 4 pages) ===== */
  .btn-retry {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 10px 20px;
    background: var(--color-primary, #2563eb);
    color: white;
    border: none;
    border-radius: var(--radius-base, 8px);
    font-size: var(--font-size-sm, 0.875rem);
    font-weight: var(--font-weight-medium, 500);
    cursor: pointer;
    text-decoration: none;
    transition: background var(--transition-fast, 0.15s ease);
  }

  .btn-retry:hover {
    background: var(--color-primary-dark, #1d4ed8);
  }

  .btn-retry:focus-visible {
    outline: var(--focus-ring-width, 3px) solid var(--focus-ring-color, var(--color-primary));
    outline-offset: var(--focus-ring-offset, 2px);
  }

  /* ===== Empty State ===== */
  .empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--color-gray-500, #6b7280);
  }

  .empty-state-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
  }

  .empty-state h3 {
    margin: 0 0 0.5rem 0;
    color: var(--color-gray-700, #374151);
  }

  /* ===== Loading State ===== */
  .loading-state {
    text-align: center;
    padding: 2rem;
    color: var(--color-gray-500, #6b7280);
  }

  /* Print Styles */
  @media print {
    body {
      background: white;
    }

    .site-header {
      border-bottom: 1px solid #000;
    }

    .build-info,
    .button-group,
    .tabs {
      display: none !important;
    }

    .card {
      box-shadow: none;
      page-break-inside: avoid;
      border: 1px solid var(--color-gray-200, #e2e8f0);
    }

    .qr-code {
      page-break-inside: avoid;
    }
  }

  /* ===== Mobile-First Critical Patterns ===== */

  /* Prevent any element from causing horizontal scroll */
  img, video, iframe, embed, object {
    max-width: 100%;
    height: auto;
  }

  /* Table overflow handling for mobile */
  .table-responsive {
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* Text overflow prevention */
  h1, h2, h3, h4, h5, h6, p, span, a, li {
    word-wrap: break-word;
    overflow-wrap: break-word;
  }

  /* Long URLs and codes */
  code, pre, .monospace, [style*="monospace"] {
    word-break: break-all;
    overflow-wrap: anywhere;
  }

  /* Mobile-optimized links (finger-friendly) */
  @media (max-width: 640px) {
    a {
      -webkit-tap-highlight-color: transparent;
    }

    /* Ensure all interactive elements have adequate spacing */
    .card a,
    .card button {
      min-height: 44px;
      display: inline-flex;
      align-items: center;
    }
  }

  /* Collapsible card headers - Mobile tap-friendly */
  .collapsible-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    padding: 12px 16px;
    min-height: var(--touch-target-min, 44px);
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }

  .collapsible-header:active {
    background: var(--color-gray-100, #f1f5f9);
  }

  .collapsible-icon {
    transition: transform var(--transition-base, 0.2s);
    font-size: 0.8em;
  }

  .collapsible-header.collapsed .collapsible-icon {
    transform: rotate(-90deg);
  }

  /* Mobile-friendly error card */
  .error-card {
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-left: 4px solid #ef4444;
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-mobile, 16px);
    margin: 16px 0;
    word-wrap: break-word;
  }

  .error-card h3 {
    color: #dc2626;
    font-size: 1.1rem;
    margin-bottom: 8px;
  }

  .error-card p {
    color: #7f1d1d;
    font-size: 0.9rem;
    line-height: 1.5;
  }

  .error-card .corr-id {
    font-family: var(--font-family-mono, monospace);
    font-size: 0.75rem;
    color: #9ca3af;
    margin-top: 12px;
    word-break: break-all;
  }

  /* ===== Story 4: Configuration Issue Card ===== */
  /* Shows when backend is misconfigured (4xx errors, GAS_UPSTREAM_NON_JSON) */
  .config-issue-state {
    background: #fef9e7;
    border: 1px solid #fcd34d;
    border-left: 4px solid #f59e0b;
    border-radius: var(--radius-md, 12px);
    padding: var(--card-padding-tablet, 24px);
    text-align: center;
  }

  .config-issue-state h3 {
    color: #92400e;
    margin-bottom: 8px;
  }

  .config-issue-state p {
    color: #78350f;
    margin-bottom: 16px;
  }

  .config-issue-state .btn-retry {
    background: #f59e0b;
    color: white;
  }

  .config-issue-state .btn-retry:hover {
    background: #d97706;
  }

  /* ===== Story 4: Diagnostic Panel (Staging Only) ===== */
  /* Expandable panel showing technical error details */
  .diagnostic-panel {
    margin-top: 16px;
    text-align: left;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid #fcd34d;
    border-radius: var(--radius-base, 8px);
    overflow: hidden;
  }

  .diagnostic-toggle {
    display: block;
    padding: 10px 16px;
    cursor: pointer;
    font-size: var(--font-size-sm, 0.875rem);
    font-weight: var(--font-weight-medium, 500);
    color: #92400e;
    background: rgba(252, 211, 77, 0.2);
    user-select: none;
    list-style: none;
  }

  .diagnostic-toggle::-webkit-details-marker {
    display: none;
  }

  .diagnostic-toggle::before {
    content: '▶';
    display: inline-block;
    margin-right: 8px;
    font-size: 0.7em;
    transition: transform var(--transition-base, 0.2s);
  }

  .diagnostic-panel[open] .diagnostic-toggle::before {
    transform: rotate(90deg);
  }

  .diagnostic-content {
    padding: 12px 16px;
    font-size: var(--font-size-sm, 0.875rem);
    background: white;
  }

  .diagnostic-row {
    display: flex;
    gap: 8px;
    padding: 6px 0;
    border-bottom: 1px solid #f3f4f6;
  }

  .diagnostic-row:last-child {
    border-bottom: none;
  }

  .diagnostic-label {
    color: #6b7280;
    font-weight: var(--font-weight-medium, 500);
    min-width: 100px;
    flex-shrink: 0;
  }

  .diagnostic-content code {
    background: #f3f4f6;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: var(--font-family-mono, monospace);
    font-size: 0.85em;
    color: #374151;
    word-break: break-all;
  }

  /* Mobile adjustments for diagnostic panel */
  @media (max-width: 640px) {
    .diagnostic-row {
      flex-direction: column;
      gap: 4px;
    }

    .diagnostic-label {
      min-width: auto;
    }
  }

  /* Sticky bottom action bar for mobile */
  .sticky-action-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    padding: 12px 16px;
    padding-bottom: max(12px, env(safe-area-inset-bottom));
    box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
    z-index: var(--z-index-sticky, 100);
    border-top: 1px solid var(--color-gray-200, #e2e8f0);
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .sticky-action-bar .btn-primary,
  .sticky-action-bar .btn-secondary {
    width: 100%;
    justify-content: center;
  }

  /* Checkbox group for mobile - tap-friendly */
  .checkbox-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .checkbox-label {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--color-gray-50, #f8fafc);
    border: 1px solid var(--color-gray-200, #e2e8f0);
    border-radius: var(--radius-base, 8px);
    cursor: pointer;
    min-height: var(--touch-target-min, 44px);
    font-size: var(--font-size-sm, 0.875rem);
    transition: all var(--transition-fast, 0.15s);
    -webkit-tap-highlight-color: transparent;
  }

  .checkbox-label:hover {
    background: var(--color-gray-100, #f1f5f9);
  }

  .checkbox-label input[type="checkbox"] {
    width: 20px;
    height: 20px;
    accent-color: var(--color-primary, #2563eb);
  }

  .checkbox-label:has(input:checked) {
    background: var(--color-primary-bg, #eff6ff);
    border-color: var(--color-primary-light, #bfdbfe);
  }

  /* Site footer - unified across surfaces */
  .site-footer {
    text-align: center;
    padding: 24px 16px;
    color: var(--color-gray-400, #94a3b8);
    font-size: var(--font-size-sm, 0.875rem);
    border-top: 1px solid var(--color-gray-200, #e2e8f0);
    margin-top: 40px;
    background: var(--color-gray-50, #f8fafc);
  }

  .site-footer a {
    color: var(--color-primary, #2563eb);
    text-decoration: none;
  }

  .site-footer a:hover {
    text-decoration: underline;
  }

  /* TV mode footer */
  body[data-tv="1"] .site-footer {
    background: transparent;
    border-top-color: var(--color-tv-border, #333);
    color: var(--color-tv-text-muted, #888);
    padding: 12px;
    font-size: max(0.75rem, 12px);
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    margin: 0;
  }

  body[data-tv="1"] .site-footer a {
    color: var(--color-tv-accent, #60a5fa);
  }

  /* Mobile footer adjustment for sticky buttons */
  @media (max-width: 640px) {
    body.has-sticky-actions .site-footer {
      padding-bottom: 100px;
    }
  }
</style>

  <script>
window.SKIN = {
  container: 'container',
  header: 'header',
  card: 'card',
  btnPri: 'btn-primary',
  btnSec: 'btn-secondary',
  btnGroup: 'button-group',
  formGroup: 'form-group',
  formRow: 'form-row',
  eventsGrid: 'events-grid',
  eventCard: 'event-card',
  qrGrid: 'qr-grid',
  qrCode: 'qr-code',
  overlay: 'loading-overlay',
  spinner: 'spinner'
};
</script>

  <!--
═══════════════════════════════════════════════════════════════════════════════
NUSDK v2.2 - Fetch-Based NU SDK for Google Apps Script
═══════════════════════════════════════════════════════════════════════════════

RESPONSIBILITY: This file provides the RPC client for frontend→backend calls ONLY.
It does NOT implement business logic - that belongs in Code.gs.

WINDOW ADDITIONS:
- window.NU        - Main SDK object
- window.__NU_LOGS__ - Rolling log buffer for diagnostics
- window.NU_DIAG   - Diagnostic helper for Test.html

INITIALIZATION:
Call NU.init({ execUrl, brand }) early in page setup to configure transport.
Falls back to template variables when available:
  NU.init({ execUrl: '<?= execUrl ?>', brand: '<?= brandId ?>' });

TRANSPORT OPTIONS:
1. Worker Proxy (default): Fetch-based (/api/<path>) through Cloudflare Worker
   - Used when: NU.init() called with no execUrl or empty execUrl
2. Direct GAS Transport: Fetch-based ({execUrl}?action={method}&brand={brand})
   - Used when: NU.init({ execUrl: '...', brand: '...' }) called with valid URL
   - Legacy enable: NU.configureDirectTransport(execUrl, brand)
   - Includes retry logic with exponential backoff
   - Includes correlation ID for distributed tracing

LOGGING LEVELS:
- Staging: 'debug' (all logs)
- Production: 'error' (errors only)

RESPONSE ENVELOPE CONTRACT (all API endpoints follow this pattern):

SUCCESS:
{
  ok: true,
  etag?: string,           // Optional cache tag for SWR
  notModified?: boolean,   // True if content unchanged (304 equivalent)
  value: { ... }           // Endpoint-specific payload per ApiSchemas.gs
}

ERROR:
{
  ok: false,
  code: "BAD_INPUT" | "NOT_FOUND" | "RATE_LIMITED" | "INTERNAL" | "UNAUTHORIZED",
  message: "Human-readable error description"
}

USAGE:
  const res = await NU.rpc('events/list', { brandId });
  if (!res.ok) {
    console.error(res.code, res.message);
    return;
  }
  const { events } = res.value;

See ApiSchemas.gs for full endpoint inventory and schemas.
═══════════════════════════════════════════════════════════════════════════════
-->
<script>
// =============================================================================
// Rolling Log Buffer - Global diagnostic storage
// =============================================================================
window.__NU_LOGS__ = [];

// =============================================================================
// NU SDK - Main SDK Object
// =============================================================================
window.NU = {
  /**
   * SDK Version
   */
  VERSION: '2.2.0',

  /**
   * Configuration
   * @private
   */
  _config: {
    logLevel: 'debug', // 'debug' | 'error' | 'none' - auto-detected from environment
    maxLogs: 100,      // Max entries in rolling log buffer
    apiBase: '/api',   // Base path for API endpoints
    dedupeWindow: 5000 // Error deduplication window (ms)
  },

  /**
   * Direct transport configuration (for direct GAS exec URL calls)
   * @private
   */
  _directTransport: {
    enabled: false,    // Whether to use direct GAS transport instead of Worker proxy
    execUrl: null,     // GAS web app exec URL
    brand: null,       // Brand identifier for multi-tenant routing
    maxRetries: 3,     // Max retry attempts for transient failures
    retryDelayMs: 1000 // Base delay for exponential backoff (doubles each retry)
  },

  /**
   * Log level constants
   * @private
   */
  _LOG_LEVELS: Object.freeze({ none: 0, error: 1, debug: 2 }),

  /**
   * Pending requests for flush tracking
   * @private
   */
  _pending: [],

  /**
   * Error deduplication tracking
   * @private
   */
  _errorDedupeMap: new Map(),

  /**
   * Environment flags - detected once at init
   * @private
   */
  _env: {
    isStaging: false,
    isProduction: false,
    hostname: ''
  },

  /**
   * Initialize SDK - auto-detect environment and set log level
   * @private
   */
  _init() {
    // Auto-detect environment from hostname
    // SECURITY: Use exact match or suffix match to prevent subdomain spoofing
    // e.g., "fake-eventangle.com" should NOT match as production
    const hostname = window.location?.hostname || '';

    // Helper for safe domain suffix check
    const isDomain = (host, domain) =>
      host === domain || host.endsWith('.' + domain);

    const isStaging = isDomain(hostname, 'stg.eventangle.com') ||
                      hostname === 'localhost' ||
                      hostname === '127.0.0.1';
    const isProduction = isDomain(hostname, 'eventangle.com') && !isStaging;

    // Store environment flags for use by other components
    NU._env = { isStaging, isProduction, hostname };

    // Set log level based on environment
    if (isProduction) {
      NU._config.logLevel = 'error';
    } else {
      NU._config.logLevel = 'debug';
    }

    NU._log('debug', 'init', {
      version: NU.VERSION,
      logLevel: NU._config.logLevel,
      hostname,
      isStaging,
      isProduction
    });
  },

  /**
   * Initialization state tracking
   * @private
   */
  _initialized: false,

  /**
   * Initialize the SDK with configuration
   *
   * Call this method early in your page initialization to configure the SDK.
   * If execUrl is provided, the SDK will use direct GAS transport.
   * If not provided (or empty), the SDK will use the Cloudflare Worker proxy.
   *
   * Fallback behavior:
   * - In GAS-hosted pages: Pass template vars: NU.init({ execUrl: '<?= execUrl ?>', brand: '<?= brandId ?>' })
   * - In proxy contexts: Call with no args or empty config to use Worker proxy
   *
   * @param {object} config - Configuration object
   * @param {string} [config.execUrl] - GAS web app exec URL for direct transport
   * @param {string} [config.brand] - Brand identifier for multi-tenant routing
   * @param {object} [config.directTransportOptions] - Optional direct transport settings { maxRetries?, retryDelayMs? }
   * @returns {void}
   *
   * @example
   * // Initialize with direct GAS transport (from GAS-hosted template)
   * NU.init({
   *   execUrl: '<?= execUrl ?>',  // Template var from GAS
   *   brand: '<?= brandId ?>'     // Template var from GAS
   * });
   *
   * @example
   * // Initialize with proxy transport (default, no config needed)
   * NU.init(); // or NU.init({})
   *
   * @example
   * // Initialize with custom retry settings
   * NU.init({
   *   execUrl: 'https://script.google.com/macros/s/ABC123/exec',
   *   brand: 'eventangle',
   *   directTransportOptions: { maxRetries: 5, retryDelayMs: 500 }
   * });
   */
  init(config = {}) {
    const { execUrl, brand, directTransportOptions = {} } = config;

    // Determine if we have a valid execUrl for direct transport
    // Empty strings from unpopulated template vars (<?= execUrl ?>) should be treated as falsy
    const hasValidExecUrl = execUrl && typeof execUrl === 'string' && execUrl.trim() !== '';

    if (hasValidExecUrl) {
      // Validate URL format before enabling direct transport
      try {
        new URL(execUrl);

        // Configure and enable direct transport
        NU._directTransport = {
          enabled: true,
          execUrl: execUrl.trim(),
          brand: brand || null,
          maxRetries: directTransportOptions.maxRetries ?? 3,
          retryDelayMs: directTransportOptions.retryDelayMs ?? 1000
        };

        NU._log('debug', 'init_config', {
          transport: 'direct',
          execUrl: execUrl.substring(0, 50) + (execUrl.length > 50 ? '...' : ''),
          brand: brand || '(none)',
          maxRetries: NU._directTransport.maxRetries,
          retryDelayMs: NU._directTransport.retryDelayMs
        });

      } catch {
        // Invalid URL - fall back to proxy transport
        NU._log('error', 'init_config', {
          error: 'Invalid execUrl format, falling back to proxy transport',
          execUrl: execUrl.substring(0, 50)
        });
        // Keep direct transport disabled (default)
      }
    } else {
      // No execUrl provided - use Worker proxy (default)
      NU._log('debug', 'init_config', {
        transport: 'proxy',
        apiBase: NU._config.apiBase,
        reason: hasValidExecUrl === false ? 'execUrl not provided' : 'execUrl empty'
      });
    }

    NU._initialized = true;
  },

  /**
   * Check if SDK has been initialized via init()
   * @returns {boolean} True if init() has been called
   */
  isInitialized() {
    return NU._initialized;
  },

  /**
   * Get current transport mode
   * @returns {'direct' | 'proxy'} Current transport mode
   */
  getTransportMode() {
    return NU._directTransport.enabled ? 'direct' : 'proxy';
  },

  /**
   * Check if running in staging environment
   * Useful for showing diagnostic information in staging only
   * @returns {boolean} True if staging environment
   */
  isStaging() {
    return NU._env.isStaging;
  },

  /**
   * Check if running in production environment
   * @returns {boolean} True if production environment
   */
  isProduction() {
    return NU._env.isProduction;
  },

  /**
   * Internal logging with rolling buffer
   * Logs to both __NU_LOGS__ buffer and console (based on log level)
   *
   * @param {string} level - 'debug' | 'error'
   * @param {string} type - Log type: 'start' | 'ok' | 'network_fail' | 'http_fail' | 'json_fail' | 'error'
   * @param {object} data - Log data
   * @private
   */
  _log(level, type, data = {}) {
    const entry = {
      timestamp: new Date().toISOString(),
      level,
      type,
      ...data
    };

    // Add timing if startTime provided
    if (data.startTime) {
      entry.durationMs = Date.now() - data.startTime;
      delete entry.startTime;
    }

    // Add to rolling buffer
    window.__NU_LOGS__.push(entry);
    if (window.__NU_LOGS__.length > NU._config.maxLogs) {
      window.__NU_LOGS__.shift();
    }

    // Console output based on log level
    const currentLevel = NU._LOG_LEVELS[NU._config.logLevel] || 0;
    const entryLevel = NU._LOG_LEVELS[level] || 0;

    if (entryLevel <= currentLevel) {
      const prefix = '[NUSDK]';
      const logData = { ...entry };
      delete logData.timestamp;
      delete logData.level;

      if (level === 'error') {
        console.error(prefix, type, JSON.stringify(logData));
      } else {
        console.debug(prefix, type, JSON.stringify(logData));
      }
    }
  },

  /**
   * Check for duplicate error (deduplication within time window)
   * @private
   */
  _isDuplicateError(path, code) {
    const key = `${path}:${code}`;
    const now = Date.now();
    const lastTime = NU._errorDedupeMap.get(key);

    if (lastTime && (now - lastTime) < NU._config.dedupeWindow) {
      return true;
    }

    NU._errorDedupeMap.set(key, now);

    // Clean old entries periodically
    if (NU._errorDedupeMap.size > 100) {
      for (const [k, t] of NU._errorDedupeMap.entries()) {
        if (now - t > NU._config.dedupeWindow) {
          NU._errorDedupeMap.delete(k);
        }
      }
    }

    return false;
  },

  /**
   * Generate a correlation ID for distributed tracing
   * Format: timestamp-randomhex (e.g., "1702345678901-a3f2b1c9")
   * @private
   * @returns {string} Correlation ID
   */
  _generateCorrId() {
    const timestamp = Date.now();
    const randomPart = Math.random().toString(16).slice(2, 10);
    return `${timestamp}-${randomPart}`;
  },

  /**
   * Sleep helper for retry delays
   * @private
   * @param {number} ms - Milliseconds to sleep
   * @returns {Promise<void>}
   */
  _sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  /**
   * Direct GAS transport via exec URL
   * Calls {execUrl}?action={method}&brand={brand} with POST body
   *
   * Features:
   * - Retry logic with exponential backoff for transient failures
   * - Correlation ID header for distributed tracing
   * - Consistent error envelope: { ok, value?, code?, message? }
   *
   * @private
   * @param {string} method - API method name (e.g., 'events/list', 'getPublicBundle')
   * @param {object} payload - Request payload
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string, corrId?: string}>}
   */
  async _fetchTransport(method, payload = {}) {
    const { execUrl, brand, maxRetries, retryDelayMs } = NU._directTransport;
    const corrId = NU._generateCorrId();
    const startTime = Date.now();

    // Validate configuration
    if (!execUrl) {
      NU._log('error', 'transport_error', {
        method,
        corrId,
        error: 'Direct transport not configured: execUrl is required'
      });
      return {
        ok: false,
        code: 'CONFIG_ERROR',
        message: 'Direct transport not configured',
        corrId
      };
    }

    // Build URL with query parameters
    const url = new URL(execUrl);
    url.searchParams.set('action', method);
    if (brand) {
      url.searchParams.set('brand', brand);
    }

    NU._log('debug', 'transport_start', {
      method,
      corrId,
      url: url.toString(),
      payloadKeys: Object.keys(payload)
    });

    let lastError = null;
    let attempt = 0;

    while (attempt <= maxRetries) {
      try {
        const response = await fetch(url.toString(), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Correlation-Id': corrId
          },
          body: JSON.stringify(payload)
        });

        // Handle HTTP errors
        if (!response.ok) {
          const httpError = {
            ok: false,
            code: 'HTTP_ERROR',
            message: `HTTP ${response.status}`,
            status: response.status,
            corrId
          };

          // Try to parse error body for more details
          try {
            const errorBody = await response.json();
            if (errorBody.code) httpError.code = errorBody.code;
            if (errorBody.message) httpError.message = errorBody.message;
          } catch {
            // Ignore JSON parse errors for error responses
          }

          // Don't retry client errors (4xx), only server errors (5xx)
          if (response.status >= 400 && response.status < 500) {
            NU._log('error', 'http_fail', {
              method,
              corrId,
              status: response.status,
              code: httpError.code,
              attempt,
              startTime
            });
            return httpError;
          }

          // Server error - retry if we have attempts left
          lastError = httpError;
          if (attempt < maxRetries) {
            const delay = retryDelayMs * Math.pow(2, attempt);
            NU._log('debug', 'transport_retry', {
              method,
              corrId,
              attempt: attempt + 1,
              maxRetries,
              delayMs: delay,
              status: response.status
            });
            await NU._sleep(delay);
            attempt++;
            continue;
          }

          NU._log('error', 'http_fail', {
            method,
            corrId,
            status: response.status,
            code: httpError.code,
            attempt,
            startTime
          });
          return httpError;
        }

        // Parse successful response
        let data;
        try {
          data = await response.json();
        } catch (jsonError) {
          NU._log('error', 'json_fail', {
            method,
            corrId,
            error: jsonError.message,
            attempt,
            startTime
          });
          return {
            ok: false,
            code: 'PARSE_ERROR',
            message: 'Invalid JSON response from server',
            corrId
          };
        }

        // Add corrId to response for tracing
        if (typeof data === 'object' && data !== null) {
          data.corrId = corrId;
        }

        NU._log('debug', 'transport_ok', {
          method,
          corrId,
          hasValue: !!data?.value,
          attempt,
          startTime
        });

        return data;

      } catch (networkError) {
        // Network error (DNS, connection refused, timeout, etc.)
        lastError = {
          ok: false,
          code: 'NETWORK_ERROR',
          message: String(networkError.message || networkError),
          corrId
        };

        if (attempt < maxRetries) {
          const delay = retryDelayMs * Math.pow(2, attempt);
          NU._log('debug', 'transport_retry', {
            method,
            corrId,
            attempt: attempt + 1,
            maxRetries,
            delayMs: delay,
            error: networkError.message
          });
          await NU._sleep(delay);
          attempt++;
          continue;
        }

        NU._log('error', 'network_fail', {
          method,
          corrId,
          error: networkError.message,
          attempt,
          startTime
        });
        return lastError;
      }
    }

    // Should not reach here, but return last error just in case
    return lastError || {
      ok: false,
      code: 'UNKNOWN_ERROR',
      message: 'Request failed after retries',
      corrId
    };
  },

  /**
   * Make an RPC call to the backend
   *
   * Transport selection:
   * - If direct transport is enabled: uses {execUrl}?action={path}&brand={brand}
   * - Otherwise: uses Cloudflare Worker proxy at /api/{path}
   *
   * Uses fetch for all requests. NO google.script.run fallback
   * as it fails when proxied through Cloudflare.
   *
   * @param {string} path - API path (e.g., 'events/list', 'getPublicBundle')
   * @param {object} payload - Request parameters
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async rpc(path, payload = {}) {
    // Use direct GAS transport if configured and enabled
    if (NU._directTransport.enabled) {
      return NU._fetchTransport(path, payload);
    }

    const startTime = Date.now();
    const requestId = Math.random().toString(36).slice(2, 10);

    // Log request start
    NU._log('debug', 'start', { path, requestId, payloadKeys: Object.keys(payload) });

    // Track pending request
    const pendingEntry = { path, requestId, startTime };
    NU._pending.push(pendingEntry);

    try {
      // Build API URL - support both path formats:
      // - 'events/list' -> '/api/events/list'
      // - 'api_getPublicBundle' -> '/api/rpc' with method in body (legacy)
      const isLegacyMethod = path.startsWith('api_');
      const url = isLegacyMethod
        ? `${NU._config.apiBase}/rpc`
        : `${NU._config.apiBase}/${path}`;

      const body = isLegacyMethod
        ? JSON.stringify({ method: path, payload })
        : JSON.stringify(payload);

      // Make fetch request (NO google.script.run fallback - fails through Cloudflare)
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-Request-Id': requestId
        },
        body,
        credentials: 'same-origin'
      });

      // Handle HTTP errors
      // Story 4: Preserve status and errorCode from Worker for frontend error classification
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          errorData = { ok: false, code: 'INTERNAL', message: `HTTP ${response.status}` };
        }

        // Ensure status is always present for error classification
        // Story 4: Worker may return { ok, errorCode, status, message }
        if (!errorData.status) {
          errorData.status = response.status;
        }

        NU._log('error', 'http_fail', {
          path,
          requestId,
          status: errorData.status,
          code: errorData.code || errorData.errorCode,
          errorCode: errorData.errorCode,
          startTime
        });

        return errorData;
      }

      // Parse JSON response
      let data;
      try {
        data = await response.json();
      } catch (jsonError) {
        NU._log('error', 'json_fail', {
          path,
          requestId,
          error: jsonError.message,
          startTime
        });
        return { ok: false, code: 'INTERNAL', message: 'Invalid JSON response' };
      }

      // Log success with timing
      NU._log('debug', 'ok', {
        path,
        requestId,
        hasValue: !!data?.value,
        startTime
      });

      return data;

    } catch (fetchError) {
      // Network error - NO fallback to google.script.run (fails through Cloudflare)
      NU._log('error', 'network_fail', {
        path,
        requestId,
        error: fetchError.message,
        startTime
      });
      return {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Cannot connect to backend. Check your connection.'
      };

    } finally {
      // Remove from pending
      const idx = NU._pending.indexOf(pendingEntry);
      if (idx > -1) NU._pending.splice(idx, 1);
    }
  },

  /**
   * Flush all pending requests
   * Waits for all in-flight requests to complete
   *
   * @returns {Promise<void>}
   */
  async flush() {
    if (NU._pending.length === 0) {
      NU._log('debug', 'flush', { message: 'No pending requests' });
      return;
    }

    NU._log('debug', 'flush', { pendingCount: NU._pending.length });

    // Wait for all pending requests (with timeout)
    const timeout = 5000;
    const startTime = Date.now();

    while (NU._pending.length > 0 && (Date.now() - startTime) < timeout) {
      await new Promise(r => setTimeout(r, 100));
    }

    if (NU._pending.length > 0) {
      NU._log('error', 'flush', {
        message: 'Timeout waiting for pending requests',
        remaining: NU._pending.length
      });
    } else {
      NU._log('debug', 'flush', { message: 'All requests completed' });
    }
  },

  /**
   * Stale-while-revalidate pattern for cached data
   * Returns cached data immediately, then fetches fresh data
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - { staleMs, onUpdate }
   */
  swr(path, payload, { staleMs = 120000, onUpdate } = {}) {
    const key = `swr:${path}:${JSON.stringify(payload || {})}`;
    const cached = JSON.parse(localStorage.getItem(key) || '{}');

    if (cached.data) {
      setTimeout(() => onUpdate && onUpdate(cached.data), 0);
    }

    NU.rpc(path, { ...(payload || {}), ifNoneMatch: cached.etag }).then(res => {
      if (res?.notModified) return;
      if (res?.ok && res.value) {
        localStorage.setItem(key, JSON.stringify({
          etag: res.etag,
          data: res.value,
          t: Date.now()
        }));
        onUpdate && onUpdate(res.value);
      }
    });
  },

  /**
   * Escapes HTML special characters to prevent XSS
   *
   * @param {string} s - String to escape
   * @returns {string} HTML-safe string
   */
  esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  },

  /**
   * Safe RPC wrapper with graceful error handling for UI display
   * Normalizes all error types to a consistent format for StateRenderer
   *
   * Story 4: Preserves status and errorCode from Worker for error classification:
   * - status: HTTP status code (400-599)
   * - errorCode: Specific error code like 'GAS_UPSTREAM_NON_JSON'
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - { onError, silent }
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string, status?: number, errorCode?: string}>}
   */
  async safeRpc(path, payload, options = {}) {
    const { onError, silent = false } = options;

    try {
      const res = await NU.rpc(path, payload);

      // Handle backend error responses (ok: false)
      if (!res.ok) {
        // Story 4: Preserve status and errorCode for frontend error classification
        const errorInfo = {
          ok: false,
          code: res.code || res.errorCode || 'UNKNOWN',
          errorCode: res.errorCode,  // Specific error code from Worker (e.g., GAS_UPSTREAM_NON_JSON)
          status: res.status,         // HTTP status code for classification
          message: res.message || 'An unexpected error occurred',
          corrId: res.corrId
        };

        // Log error (with deduplication)
        if (!silent && !NU._isDuplicateError(path, errorInfo.code)) {
          NU._log('error', 'error', {
            path,
            code: errorInfo.code,
            errorCode: errorInfo.errorCode,
            status: errorInfo.status,
            message: errorInfo.message,
            corrId: errorInfo.corrId
          });
        }

        if (onError) onError(errorInfo);
        return errorInfo;
      }

      return res;

    } catch (e) {
      // Handle network/runtime errors
      const errorInfo = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'We\'re having trouble connecting. Please check your connection and try again.'
      };

      if (!silent && !NU._isDuplicateError(path, 'NETWORK_ERROR')) {
        NU._log('error', 'network_fail', {
          path,
          error: e?.message || errorInfo.message
        });
      }

      if (onError) onError(errorInfo);
      return errorInfo;
    }
  },

  /**
   * Fire-and-forget analytics logging that NEVER throws or blocks UI
   *
   * @param {string} path - Analytics API path
   * @param {object} payload - Analytics data
   * @returns {void}
   */
  safeAnalytics(path, payload) {
    // Fire and forget - don't await, don't block
    (async () => {
      try {
        const url = path.startsWith('api_')
          ? `${NU._config.apiBase}/rpc`
          : `${NU._config.apiBase}/${path}`;

        const body = path.startsWith('api_')
          ? JSON.stringify({ method: path, payload })
          : JSON.stringify(payload);

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body,
          credentials: 'same-origin'
        });

        if (!response.ok) {
          NU._log('debug', 'analytics_fail', { path, status: response.status });
        }

      } catch (fetchError) {
        // Story 4.1: No google.script.run fallback - fetch is the only transport
        // Analytics failures are silently ignored (fire-and-forget pattern)
        NU._log('debug', 'analytics_skip', { path, reason: 'fetch_failed', error: fetchError?.message });
      }
    })();
  },

  /**
   * Safe analytics batch logger
   *
   * @param {Array} items - Array of analytics items
   */
  safeLogEvents(items) {
    if (!items?.length) return;
    NU.safeAnalytics('api_logEvents', { items });
  },

  /**
   * Safe external click logger
   *
   * @param {object} params - { eventId, sponsorId, surface, linkType?, ua? }
   */
  safeLogClick(params) {
    NU.safeAnalytics('api_logExternalClick', {
      ...params,
      ua: params.ua || navigator.userAgent
    });
  },

  /**
   * Set log level manually
   *
   * @param {'debug' | 'error' | 'none'} level - Log level
   */
  setLogLevel(level) {
    if (NU._LOG_LEVELS.hasOwnProperty(level)) {
      NU._config.logLevel = level;
      NU._log('debug', 'config', { logLevel: level });
    }
  },

  /**
   * Get current configuration (for diagnostics)
   *
   * @returns {object} Current SDK configuration including transport state
   */
  getConfig() {
    return {
      ...NU._config,
      version: NU.VERSION,
      initialized: NU._initialized,
      transportMode: NU.getTransportMode(),
      directTransport: {
        enabled: NU._directTransport.enabled,
        hasExecUrl: !!NU._directTransport.execUrl,
        hasBrand: !!NU._directTransport.brand
      }
    };
  },

  /**
   * Configure and enable direct GAS transport
   * When enabled, rpc() calls will use the direct exec URL instead of Worker proxy
   *
   * @param {string} execUrl - GAS web app exec URL (required)
   * @param {string} brand - Brand identifier for multi-tenant routing (optional)
   * @param {object} options - Additional options { maxRetries?, retryDelayMs? }
   * @returns {void}
   *
   * @example
   * // Enable direct transport
   * NU.configureDirectTransport(
   *   'https://script.google.com/macros/s/ABC123/exec',
   *   'eventangle'
   * );
   *
   * // With custom retry settings
   * NU.configureDirectTransport(
   *   'https://script.google.com/macros/s/ABC123/exec',
   *   'eventangle',
   *   { maxRetries: 5, retryDelayMs: 500 }
   * );
   */
  configureDirectTransport(execUrl, brand = null, options = {}) {
    if (!execUrl) {
      NU._log('error', 'config', { error: 'execUrl is required for direct transport' });
      throw new Error('execUrl is required for configureDirectTransport');
    }

    // Validate URL format
    try {
      new URL(execUrl);
    } catch {
      NU._log('error', 'config', { error: 'Invalid execUrl format', execUrl });
      throw new Error('Invalid execUrl format');
    }

    const { maxRetries = 3, retryDelayMs = 1000 } = options;

    NU._directTransport = {
      enabled: true,
      execUrl,
      brand,
      maxRetries,
      retryDelayMs
    };

    NU._log('debug', 'config', {
      type: 'direct_transport_configured',
      execUrl: execUrl.substring(0, 50) + '...', // Truncate for logging
      brand,
      maxRetries,
      retryDelayMs
    });
  },

  /**
   * Disable direct transport and revert to Worker proxy
   * @returns {void}
   */
  disableDirectTransport() {
    NU._directTransport.enabled = false;
    NU._log('debug', 'config', { type: 'direct_transport_disabled' });
  },

  /**
   * Check if direct transport is enabled
   * @returns {boolean}
   */
  isDirectTransportEnabled() {
    return NU._directTransport.enabled;
  },

  // =============================================================================
  // Story 4.3: Enhanced API Wrappers with Global Error Handling
  // =============================================================================

  /**
   * Enhanced RPC with automatic retry and user feedback
   * Integrates with GlobalErrorHandler for comprehensive error handling
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Enhanced options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async resilientRpc(path, payload = {}, options = {}) {
    const {
      retry = true,
      maxAttempts = 3,
      showToast = true,
      showDialog = false,
      onError = null,
      onRetryAttempt = null,
      context = path
    } = options;

    // Use GlobalErrorHandler if available
    const handler = window.GlobalErrorHandler;

    const makeRequest = async () => {
      const res = await NU.rpc(path, payload);
      if (!res.ok) {
        // Convert to throwable error for retry logic
        const err = new Error(res.message || 'Request failed');
        err.code = res.code;
        err.corrId = res.corrId;
        err.response = res;
        throw err;
      }
      return res;
    };

    try {
      if (retry && handler) {
        // Use GlobalErrorHandler's retry with exponential backoff
        return await handler.withRetry(makeRequest, {
          attempts: maxAttempts,
          shouldRetry: (err) => {
            // Only retry network and transient errors
            const code = err?.code || err?.response?.code;
            return ['NETWORK_ERROR', 'TIMEOUT', 'SERVICE_UNAVAILABLE'].includes(code);
          },
          onRetryAttempt: (attempt, total, delay, err) => {
            NU._log('debug', 'retry', { path, attempt, total, delay, code: err?.code });
            if (onRetryAttempt) onRetryAttempt(attempt, total, delay, err);
          }
        });
      } else {
        return await makeRequest();
      }
    } catch (err) {
      // Return the original error response if available
      if (err.response) {
        if (onError) onError(err.response);

        if (handler) {
          if (showDialog) {
            handler.showErrorDialog({
              title: 'Unable to Complete Request',
              message: `We couldn't ${context}. Please try again.`,
              corrId: err.corrId,
              onRetry: () => NU.resilientRpc(path, payload, options)
            });
          } else if (showToast) {
            handler.showErrorToast(`Unable to ${context}. Please try again.`);
          }
        }

        return err.response;
      }

      // Network error without response
      const errorResponse = {
        ok: false,
        code: 'NETWORK_ERROR',
        message: 'Cannot connect to server. Please check your connection.'
      };

      if (onError) onError(errorResponse);

      if (handler && showToast) {
        handler.showErrorToast('Connection error. Please check your network.');
      }

      return errorResponse;
    }
  },

  /**
   * Load data with comprehensive error handling and UI state management
   * Perfect for initial page loads and data refresh
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Load options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async loadData(path, payload = {}, options = {}) {
    const {
      container = null,
      onSuccess = null,
      onError = null,
      showLoading = true,
      retry = true,
      context = 'load data'
    } = options;

    const StateRenderer = window.SharedUtils?.StateRenderer;

    // Show loading state
    if (showLoading && container && StateRenderer) {
      StateRenderer.showLoading(container, { message: 'Loading...' });
    }

    const res = await NU.resilientRpc(path, payload, {
      retry,
      showToast: false,
      context
    });

    if (res.ok) {
      if (onSuccess) onSuccess(res.value);
    } else {
      // Show error state in container
      if (container && StateRenderer) {
        StateRenderer.showFromError(container, res, {
          onRetry: () => NU.loadData(path, payload, options)
        });
      }
      if (onError) onError(res);
    }

    return res;
  },

  /**
   * Submit data with user feedback (for forms, saves, etc.)
   * Shows appropriate toast/dialog feedback
   *
   * @param {string} path - API path
   * @param {object} payload - Request parameters
   * @param {object} options - Submit options
   * @returns {Promise<{ok: boolean, value?: any, code?: string, message?: string}>}
   */
  async submitData(path, payload = {}, options = {}) {
    const {
      successMessage = 'Saved successfully!',
      errorMessage = 'Unable to save. Please try again.',
      onSuccess = null,
      onError = null,
      button = null,
      context = 'save'
    } = options;

    const showToast = window.SharedUtils?.showToast;

    // Disable button during submit
    if (button) {
      button.disabled = true;
      button.dataset.originalText = button.textContent;
      button.textContent = 'Saving...';
    }

    try {
      const res = await NU.resilientRpc(path, payload, {
        retry: true,
        showToast: false,
        context
      });

      if (res.ok) {
        if (showToast) showToast(successMessage, 'success');
        if (onSuccess) onSuccess(res.value);
      } else {
        if (showToast) showToast(errorMessage, 'error');
        if (onError) onError(res);
      }

      return res;

    } finally {
      // Re-enable button
      if (button) {
        button.disabled = false;
        button.textContent = button.dataset.originalText || 'Save';
      }
    }
  }
};

// =============================================================================
// NU_DIAG - Diagnostic Helper for Test.html
// =============================================================================
window.NU_DIAG = {
  /**
   * Get all logs from the rolling buffer
   *
   * @param {object} options - { type?, level?, limit? }
   * @returns {Array} Filtered log entries
   */
  getLogs(options = {}) {
    const { type, level, limit = 100 } = options;
    let logs = [...window.__NU_LOGS__];

    if (type) {
      logs = logs.filter(l => l.type === type);
    }
    if (level) {
      logs = logs.filter(l => l.level === level);
    }

    return logs.slice(-limit);
  },

  /**
   * Clear all logs from the buffer
   */
  clearLogs() {
    window.__NU_LOGS__.length = 0;
    console.debug('[NU_DIAG] Logs cleared');
  },

  /**
   * Get statistics about logged requests
   *
   * @returns {object} Statistics object
   */
  getStats() {
    const logs = window.__NU_LOGS__;
    const stats = {
      totalLogs: logs.length,
      byType: {},
      byLevel: {},
      errors: [],
      avgDurationMs: 0
    };

    let totalDuration = 0;
    let durationCount = 0;

    logs.forEach(log => {
      // Count by type
      stats.byType[log.type] = (stats.byType[log.type] || 0) + 1;

      // Count by level
      stats.byLevel[log.level] = (stats.byLevel[log.level] || 0) + 1;

      // Track errors
      if (log.level === 'error') {
        stats.errors.push({
          timestamp: log.timestamp,
          type: log.type,
          path: log.path,
          code: log.code,
          error: log.error
        });
      }

      // Track durations
      if (log.durationMs) {
        totalDuration += log.durationMs;
        durationCount++;
      }
    });

    stats.avgDurationMs = durationCount > 0
      ? Math.round(totalDuration / durationCount)
      : 0;

    return stats;
  },

  /**
   * Test an RPC call and return detailed diagnostics
   *
   * @param {string} path - API path to test
   * @param {object} payload - Request payload
   * @returns {Promise<object>} Test result with timing and diagnostics
   */
  async testRpc(path, payload = {}) {
    const startTime = Date.now();
    const logsBefore = window.__NU_LOGS__.length;

    console.group(`[NU_DIAG] Testing RPC: ${path}`);
    console.debug('Payload:', payload);

    try {
      const result = await NU.rpc(path, payload);
      const endTime = Date.now();
      const newLogs = window.__NU_LOGS__.slice(logsBefore);

      const diagnostic = {
        success: result.ok,
        path,
        payload,
        result,
        durationMs: endTime - startTime,
        logs: newLogs,
        timestamp: new Date().toISOString()
      };

      console.debug('Result:', result);
      console.debug('Duration:', diagnostic.durationMs, 'ms');
      console.debug('Logs generated:', newLogs.length);
      console.groupEnd();

      return diagnostic;

    } catch (error) {
      const endTime = Date.now();
      const newLogs = window.__NU_LOGS__.slice(logsBefore);

      const diagnostic = {
        success: false,
        path,
        payload,
        error: error.message,
        durationMs: endTime - startTime,
        logs: newLogs,
        timestamp: new Date().toISOString()
      };

      console.error('Error:', error);
      console.groupEnd();

      return diagnostic;
    }
  },

  /**
   * Run a quick health check
   *
   * @returns {Promise<object>} Health check results
   */
  async healthCheck() {
    console.group('[NU_DIAG] Health Check');

    const health = {
      sdk: {
        version: NU.VERSION,
        config: NU.getConfig(),
        pendingRequests: NU._pending.length
      },
      logs: {
        count: window.__NU_LOGS__.length,
        maxSize: NU._config.maxLogs
      },
      environment: {
        hostname: window.location?.hostname,
        protocol: window.location?.protocol,
        hasGoogleScript: !!window.google?.script?.run
      },
      timestamp: new Date().toISOString()
    };

    // Test connectivity with a simple ping
    try {
      const pingStart = Date.now();
      const pingResult = await NU.rpc('status', {});
      health.connectivity = {
        ok: pingResult.ok,
        durationMs: Date.now() - pingStart,
        response: pingResult.ok ? 'connected' : pingResult.code
      };
    } catch (e) {
      health.connectivity = {
        ok: false,
        error: e.message
      };
    }

    console.debug('Health:', health);
    console.groupEnd();

    return health;
  },

  /**
   * Export logs as JSON for debugging
   *
   * @returns {string} JSON string of all logs
   */
  exportLogs() {
    const exportData = {
      sdk: {
        version: NU.VERSION,
        config: NU.getConfig()
      },
      stats: NU_DIAG.getStats(),
      logs: window.__NU_LOGS__,
      exportedAt: new Date().toISOString()
    };

    return JSON.stringify(exportData, null, 2);
  },

  /**
   * Print a summary to console
   */
  printSummary() {
    const stats = NU_DIAG.getStats();
    console.group('[NU_DIAG] Summary');
    console.log('SDK Version:', NU.VERSION);
    console.log('Log Level:', NU._config.logLevel);
    console.log('Total Logs:', stats.totalLogs);
    console.log('By Type:', stats.byType);
    console.log('By Level:', stats.byLevel);
    console.log('Avg Duration:', stats.avgDurationMs, 'ms');
    if (stats.errors.length > 0) {
      console.warn('Recent Errors:', stats.errors.slice(-5));
    }
    console.groupEnd();
  }
};

// =============================================================================
// Auto-initialize SDK
// =============================================================================
NU._init();
</script>

  <script>
/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SharedUtils - Common utilities for all front-end pages
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * RESPONSIBILITY: This file provides UI utilities (alerts, dates, forms) ONLY.
 * It does NOT handle data entities or business logic - that belongs in Code.gs.
 *
 * WINDOW ADDITION: window.SharedUtils
 *
 * Dependencies: NUSDK.html (for NU.esc)
 * Used by: Public.html, Display.html, Poster.html, SharedReport.html, Admin.html
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * HELPER INDEX (keep updated when adding/removing functions):
 * ═══════════════════════════════════════════════════════════════════════════════
 *   showAlert(message, type, options)  → Alert notifications (Admin.html)
 *   showToast(message, type, duration) → Toast notifications (all surfaces)
 *   formatDate(dateInput, options)     → Date formatting (Admin.html)
 *   formatTime(timeStr)                → Time formatting (Admin.html)
 *   debounce(fn, delay)                → Event debouncing (Admin.html)
 *   copyToClipboard(text)              → Clipboard utility (Admin.html)
 *   validateUrl(url)                   → URL validation (Admin.html)
 *   sectionEnabled(settings, key)      → Section visibility check (Feature 4)
 *     Keys: schedule, standings, bracket, sponsors, video, map, gallery
 *
 * S12: StateRenderer - Unified error/empty/loading states (all surfaces)
 *   StateRenderer.showError(container, options)      → Error state
 *   StateRenderer.showEmpty(container, options)      → Empty state
 *   StateRenderer.showLoading(container, options)    → Loading state
 *   StateRenderer.showEventNotFound(container, opts) → Event not found
 *   StateRenderer.showNoData(container, opts)        → No data yet
 *   StateRenderer.showNetworkError(container, opts)  → Connection error
 *   StateRenderer.showUnauthorized(container, opts)  → Access denied
 *   StateRenderer.showFromError(container, err, opts)→ Auto-detect type
 *   ERROR_TYPES                                      → Standard error types
 *   classifyError(error)                             → Map error to type
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * @version 1.3.0
 */
window.SharedUtils = (function() {
  'use strict';

  // === Alert/Notification System ===

  /**
   * Shows a dismissible alert notification
   * @param {string} message - Alert message text
   * @param {string} type - Alert type: 'info', 'success', 'error', 'warning'
   * @param {Object} options - Optional configuration
   * @param {number} options.duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
   * @param {string} options.containerId - ID of alert container element
   */
  function showAlert(message, type = 'info', options = {}) {
    const {
      duration = 5000,
      containerId = 'alert-container'
    } = options;

    const container = document.getElementById(containerId);
    if (!container) {
      console.warn(`SharedUtils.showAlert: Container #${containerId} not found`);
      return;
    }

    const alert = document.createElement('div');
    alert.className = `alert alert-${type}`;
    alert.setAttribute('role', 'alert');

    // Create alert content with dismiss button
    const content = document.createElement('span');
    content.textContent = message;

    const dismissBtn = document.createElement('button');
    dismissBtn.type = 'button';
    dismissBtn.className = 'alert-dismiss';
    dismissBtn.innerHTML = '&times;';
    dismissBtn.setAttribute('aria-label', 'Dismiss');
    dismissBtn.onclick = () => alert.remove();

    alert.appendChild(content);
    alert.appendChild(dismissBtn);

    // Clear existing alerts and add new one
    container.innerHTML = '';
    container.appendChild(alert);

    // Auto-dismiss if duration > 0
    if (duration > 0) {
      setTimeout(() => {
        if (alert.parentNode) {
          alert.classList.add('alert-fade-out');
          setTimeout(() => alert.remove(), 300);
        }
      }, duration);
    }

    return alert;
  }

  // === Date Formatting ===

  /**
   * Formats a date string to a human-readable format
   * @param {string|Date} dateInput - Date string or Date object
   * @param {Object} options - Intl.DateTimeFormat options
   * @returns {string} Formatted date string
   */
  function formatDate(dateInput, options = {}) {
    if (!dateInput) return 'Date TBD';

    try {
      const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
      if (isNaN(date.getTime())) return 'Invalid Date';

      const defaultOptions = {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      };

      return date.toLocaleDateString('en-US', { ...defaultOptions, ...options });
    } catch (e) {
      return 'Date TBD';
    }
  }

  /**
   * Formats a date string to a relative time (e.g., "2 days ago")
   * @param {string|Date} dateInput - Date string or Date object
   * @returns {string} Relative time string
   */
  function formatRelativeTime(dateInput) {
    if (!dateInput) return '';

    try {
      const date = dateInput instanceof Date ? dateInput : new Date(dateInput);
      if (isNaN(date.getTime())) return '';

      const now = new Date();
      const diffMs = now - date;
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

      if (diffDays === 0) return 'Today';
      if (diffDays === 1) return 'Yesterday';
      if (diffDays < 7) return `${diffDays} days ago`;
      if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
      if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
      return `${Math.floor(diffDays / 365)} years ago`;
    } catch (e) {
      return '';
    }
  }

  // === Form Utilities ===

  /**
   * Validates a form and returns validation status
   * @param {string|HTMLFormElement} formIdOrEl - Form ID or form element
   * @returns {Object} { valid: boolean, errors: Array<{field, message}> }
   */
  function validateForm(formIdOrEl) {
    const form = typeof formIdOrEl === 'string'
      ? document.getElementById(formIdOrEl)
      : formIdOrEl;

    if (!form) return { valid: false, errors: [{ field: null, message: 'Form not found' }] };

    const errors = [];
    const requiredInputs = form.querySelectorAll('[required]');

    requiredInputs.forEach(input => {
      // Clear previous error state
      input.classList.remove('form-input-error');

      if (!input.value.trim()) {
        errors.push({
          field: input.name || input.id,
          message: `${input.labels?.[0]?.textContent || input.name || 'Field'} is required`
        });
        input.classList.add('form-input-error');
      }
    });

    // Validate email fields
    form.querySelectorAll('input[type="email"]').forEach(input => {
      if (input.value && !isValidEmail(input.value)) {
        errors.push({ field: input.name || input.id, message: 'Invalid email address' });
        input.classList.add('form-input-error');
      }
    });

    // Validate URL fields
    form.querySelectorAll('input[type="url"]').forEach(input => {
      if (input.value && !isValidUrl(input.value)) {
        errors.push({ field: input.name || input.id, message: 'Invalid URL' });
        input.classList.add('form-input-error');
      }
    });

    return { valid: errors.length === 0, errors };
  }

  /**
   * Validates an email address
   * @param {string} email - Email to validate
   * @returns {boolean} True if valid
   */
  function isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  /**
   * Validates a URL
   * @param {string} url - URL to validate
   * @returns {boolean} True if valid
   */
  function isValidUrl(url) {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  // === Loading State Management ===

  /**
   * Executes an async function with loading state management
   * @param {Function} asyncFn - Async function to execute
   * @param {Object} options - Configuration options
   * @param {string} options.loadingElId - ID of loading indicator element
   * @param {string} options.emptyElId - ID of empty state element
   * @param {string} options.contentElId - ID of content container element
   * @param {HTMLButtonElement} options.button - Submit button to disable
   * @returns {Promise<any>} Result of asyncFn
   */
  async function withLoadingState(asyncFn, options = {}) {
    const { loadingElId, emptyElId, contentElId, button } = options;

    const loadingEl = loadingElId ? document.getElementById(loadingElId) : null;
    const emptyEl = emptyElId ? document.getElementById(emptyElId) : null;
    const contentEl = contentElId ? document.getElementById(contentElId) : null;

    // Show loading state
    if (loadingEl) loadingEl.style.display = 'block';
    if (emptyEl) emptyEl.style.display = 'none';
    if (contentEl) contentEl.style.display = 'none';
    if (button) button.disabled = true;

    try {
      const result = await asyncFn();
      return result;
    } finally {
      // Hide loading state
      if (loadingEl) loadingEl.style.display = 'none';
      if (button) button.disabled = false;
    }
  }

  // === DOM Utilities ===

  /**
   * Toggles element visibility
   * @param {string} elementId - ID of element to toggle
   * @param {string} className - Class to toggle (default: 'hidden')
   */
  function toggleElement(elementId, className = 'hidden') {
    const el = document.getElementById(elementId);
    if (el) el.classList.toggle(className);
  }

  /**
   * Shows an element by removing hidden class
   * @param {string} elementId - ID of element to show
   */
  function showElement(elementId) {
    const el = document.getElementById(elementId);
    if (el) el.style.display = 'block';
  }

  /**
   * Hides an element by setting display none
   * @param {string} elementId - ID of element to hide
   */
  function hideElement(elementId) {
    const el = document.getElementById(elementId);
    if (el) el.style.display = 'none';
  }

  // === XSS Prevention (delegating to NU.esc) ===

  /**
   * Escapes HTML special characters to prevent XSS
   * Delegates to NU.esc if available, otherwise uses local implementation
   *
   * IMPORTANT: Prefer using NU.esc() directly when NUSDK is included.
   * This is provided for backwards compatibility.
   *
   * @param {string} unsafe - String to escape
   * @returns {string} HTML-safe string
   */
  function esc(unsafe) {
    // Delegate to NU.esc if available (canonical implementation)
    if (window.NU && typeof window.NU.esc === 'function') {
      return window.NU.esc(unsafe);
    }
    // Fallback implementation (should rarely be used)
    if (!unsafe) return '';
    return String(unsafe).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  }

  // === Debounce/Throttle ===

  /**
   * Creates a debounced version of a function
   * @param {Function} fn - Function to debounce
   * @param {number} delay - Delay in milliseconds
   * @returns {Function} Debounced function
   */
  function debounce(fn, delay = 300) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  /**
   * Creates a throttled version of a function
   * @param {Function} fn - Function to throttle
   * @param {number} limit - Minimum time between calls in milliseconds
   * @returns {Function} Throttled function
   */
  function throttle(fn, limit = 100) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        fn.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  // === Toast Notifications (non-blocking) ===

  /**
   * Shows a brief toast notification (non-blocking alternative to alert())
   * @param {string} message - Toast message
   * @param {string} type - 'success', 'error', 'info', 'warning'
   * @param {number} duration - Auto-dismiss duration in ms (default: 3000)
   */
  function showToast(message, type = 'info', duration = 3000) {
    // Remove existing toast
    const existing = document.querySelector('.shared-toast');
    if (existing) existing.remove();

    const toast = document.createElement('div');
    toast.className = `shared-toast shared-toast-${type}`;
    toast.setAttribute('role', 'status');
    toast.textContent = message;

    // Inject minimal styles if not present
    if (!document.getElementById('shared-toast-styles')) {
      const style = document.createElement('style');
      style.id = 'shared-toast-styles';
      style.textContent = `
        .shared-toast {
          position: fixed; bottom: 20px; right: 20px;
          padding: 12px 20px; border-radius: 8px;
          font-size: 14px; font-weight: 500; z-index: 9999;
          animation: toast-slide-in 0.3s ease;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .shared-toast-success { background: #10b981; color: white; }
        .shared-toast-error { background: #ef4444; color: white; }
        .shared-toast-info { background: #3b82f6; color: white; }
        .shared-toast-warning { background: #f59e0b; color: white; }
        @keyframes toast-slide-in { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(toast);

    // Auto-dismiss
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(20px)';
      toast.style.transition = 'all 0.3s ease';
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  // === StateRenderer (unified error/empty/loading states) ===

  /**
   * Standard error types for consistent UX across all surfaces
   * S12: Error & Empty State Polish
   * S13: Graceful Degradation - added SERVICE_UNAVAILABLE, TIMEOUT
   * Story 4: Added CONFIGURATION_ISSUE for 4xx errors and GAS_UPSTREAM_NON_JSON
   */
  const ERROR_TYPES = {
    EVENT_NOT_FOUND: 'event_not_found',
    NO_DATA: 'no_data',
    NETWORK_ERROR: 'network_error',
    UNAUTHORIZED: 'unauthorized',
    SERVICE_UNAVAILABLE: 'service_unavailable',
    TIMEOUT: 'timeout',
    CONFIGURATION_ISSUE: 'configuration_issue',  // Story 4: Backend misconfiguration
    GENERIC: 'generic'
  };

  /**
   * Maps raw error messages/codes to user-friendly error types
   * Prevents leaking internal details (JSON, stack traces, etc.)
   * S13: Added SERVICE_UNAVAILABLE, TIMEOUT detection
   * Story 4: Added CONFIGURATION_ISSUE detection for 4xx and GAS errors
   *
   * @param {string|Error|Object} error - Raw error message, Error object, or {code, message, status, errorCode}
   * @returns {string} User-friendly error type from ERROR_TYPES
   */
  function classifyError(error) {
    // Handle error objects with code property (from NU.safeRpc)
    const code = String(error?.code || '').toUpperCase();
    const errorCode = String(error?.errorCode || '').toUpperCase();
    const status = error?.status;
    const msg = String(error?.message || error || '').toLowerCase();

    // Story 4: Check for configuration issues first (GAS upstream errors or 4xx status)
    // GAS_UPSTREAM_NON_JSON indicates backend returned non-JSON (likely misconfigured)
    if (errorCode === 'GAS_UPSTREAM_NON_JSON' || code === 'GAS_UPSTREAM_NON_JSON') {
      return ERROR_TYPES.CONFIGURATION_ISSUE;
    }

    // Story 4: 4xx status codes indicate client/configuration errors
    if (status && status >= 400 && status < 500) {
      // 404 is special - treat as not found
      if (status === 404) {
        return ERROR_TYPES.EVENT_NOT_FOUND;
      }
      // 401/403 are auth errors
      if (status === 401 || status === 403) {
        return ERROR_TYPES.UNAUTHORIZED;
      }
      // Other 4xx are configuration issues
      return ERROR_TYPES.CONFIGURATION_ISSUE;
    }

    // Story 4: 5xx status codes are temporary server issues
    if (status && status >= 500 && status < 600) {
      return ERROR_TYPES.SERVICE_UNAVAILABLE;
    }

    // Check error codes (most reliable)
    if (code === 'SERVICE_UNAVAILABLE' || code === 'INTERNAL') {
      return ERROR_TYPES.SERVICE_UNAVAILABLE;
    }
    if (code === 'TIMEOUT') {
      return ERROR_TYPES.TIMEOUT;
    }
    if (code === 'NOT_FOUND') {
      return ERROR_TYPES.EVENT_NOT_FOUND;
    }
    if (code === 'UNAUTHORIZED') {
      return ERROR_TYPES.UNAUTHORIZED;
    }
    if (code === 'NETWORK_ERROR') {
      return ERROR_TYPES.NETWORK_ERROR;
    }

    // Fallback to message-based detection
    if (msg.includes('not found') || msg.includes('404') || msg.includes('invalid') || msg.includes('no event')) {
      return ERROR_TYPES.EVENT_NOT_FOUND;
    }
    if (msg.includes('unauthorized') || msg.includes('403') || msg.includes('permission')) {
      return ERROR_TYPES.UNAUTHORIZED;
    }
    if (msg.includes('service unavailable') || msg.includes('503') || msg.includes('temporary issue') || msg.includes('temporary problem')) {
      return ERROR_TYPES.SERVICE_UNAVAILABLE;
    }
    if (msg.includes('timeout') || msg.includes('504') || msg.includes('took too long') || msg.includes('timed out')) {
      return ERROR_TYPES.TIMEOUT;
    }
    if (msg.includes('network') || msg.includes('failed to fetch') || msg.includes('connection') || msg.includes('offline')) {
      return ERROR_TYPES.NETWORK_ERROR;
    }
    if (msg.includes('no data') || msg.includes('empty') || msg.includes('nothing')) {
      return ERROR_TYPES.NO_DATA;
    }
    // Story 4: Check for configuration-related keywords
    if (msg.includes('configuration') || msg.includes('config') || msg.includes('misconfigured')) {
      return ERROR_TYPES.CONFIGURATION_ISSUE;
    }
    return ERROR_TYPES.GENERIC;
  }

  /**
   * StateRenderer - Unified error/empty/loading state rendering
   * S12: Consistent UX across Public, Display, Poster, SharedReport, Admin
   */
  const StateRenderer = {
    // Expose error types for external use
    ERROR_TYPES,
    classifyError,

    /**
     * Render error state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { title, message, onRetry, hint, tvMode }
     */
    showError(container, options = {}) {
      const {
        title = 'Something Went Wrong',
        message = 'Please try again.',
        onRetry = null,
        hint = null,
        tvMode = false
      } = options;

      const stateClass = tvMode ? 'error-state-tv' : 'error-state';
      const iconClass = tvMode ? 'error-icon' : 'error-state-icon';

      container.innerHTML = `
        <div class="${stateClass}">
          <div class="${iconClass}">⚠️</div>
          <h3>${esc(title)}</h3>
          <p>${esc(message)}</p>
          ${hint ? `<p style="font-size: 0.85rem; color: ${tvMode ? '#9ca3af' : '#991b1b'}; margin-top: 8px;">${esc(hint)}</p>` : ''}
          ${onRetry ? '<button class="btn-retry">🔄 Try Again</button>' : ''}
        </div>
      `;
      if (onRetry) {
        container.querySelector('.btn-retry')?.addEventListener('click', onRetry);
      }
    },

    /**
     * Render empty state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { icon, title, message, hint, backUrl, backLabel, tvMode }
     */
    showEmpty(container, options = {}) {
      const {
        icon = '📭',
        title = 'Nothing Here',
        message = '',
        hint = null,
        backUrl = null,
        backLabel = '← Go Back',
        tvMode = false
      } = options;

      const stateClass = tvMode ? 'error-state-tv' : 'empty-state';
      const iconClass = tvMode ? 'error-icon' : 'empty-state-icon';

      container.innerHTML = `
        <div class="${stateClass}">
          <div class="${iconClass}">${icon}</div>
          <h3>${esc(title)}</h3>
          ${message ? `<p>${esc(message)}</p>` : ''}
          ${hint ? `<p style="font-size: 0.85rem; color: #94a3b8; margin-top: 12px;">${esc(hint)}</p>` : ''}
          ${backUrl ? `<a href="${esc(backUrl)}" class="btn-secondary">${esc(backLabel)}</a>` : ''}
        </div>
      `;
    },

    /**
     * Render loading state into a container
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { message }
     */
    showLoading(container, options = {}) {
      const { message = 'Loading...' } = options;
      container.innerHTML = `
        <div class="loading-state">
          <div class="loading-spinner"></div>
          <p>${esc(message)}</p>
        </div>
      `;
    },

    // === Convenience Methods for Common Scenarios (S12) ===

    /**
     * Show "Event Not Found" state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { backUrl, tvMode }
     */
    showEventNotFound(container, options = {}) {
      const { backUrl = null, tvMode = false } = options;
      this.showEmpty(container, {
        icon: '🔍',
        title: 'Event Not Found',
        message: 'We couldn\'t find this event. The link may be outdated, the event ID might be incorrect, or the event may have been removed.',
        hint: 'Double-check the URL or return to the events list to find what you\'re looking for.',
        backUrl,
        backLabel: '← View All Events',
        tvMode
      });
    },

    /**
     * Show "No Data Yet" state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { context, backUrl, tvMode }
     */
    showNoData(container, options = {}) {
      const { context = 'content', backUrl = null, tvMode = false } = options;
      const contextMessages = {
        events: 'Check back soon for new events, or contact the organizer for more information.',
        sponsors: 'No sponsors to display yet. Sponsor information will appear here once configured.',
        schedule: 'The event schedule will appear here once it\'s available.',
        standings: 'Standings will appear here once the competition begins.',
        analytics: 'Once attendees start interacting with your content, you\'ll see engagement data here.',
        content: 'This event exists but doesn\'t have any content to display yet. Check back soon!'
      };
      this.showEmpty(container, {
        icon: '📭',
        title: 'No Data Yet',
        message: contextMessages[context] || contextMessages.content,
        backUrl,
        tvMode
      });
    },

    /**
     * Show network/connection error state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode }
     */
    showNetworkError(container, options = {}) {
      const { onRetry = null, tvMode = false } = options;
      this.showError(container, {
        title: 'Connection Problem',
        message: 'We\'re having trouble connecting right now. This might be a temporary issue.',
        hint: 'Please check your internet connection and try again.',
        onRetry,
        tvMode
      });
    },

    /**
     * Show unauthorized/permission error state
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { backUrl, tvMode }
     */
    showUnauthorized(container, options = {}) {
      const { backUrl = null, tvMode = false } = options;
      this.showError(container, {
        title: 'Access Denied',
        message: 'You don\'t have permission to view this content.',
        hint: 'Please check that you have the correct access link.',
        onRetry: null,
        tvMode
      });
    },

    /**
     * Show temporary service issue state (S13: Graceful Degradation)
     * For 5xx errors from upstream, temporary outages, etc.
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode, corrId }
     */
    showTemporaryIssue(container, options = {}) {
      const { onRetry = null, tvMode = false, corrId = null } = options;
      this.showError(container, {
        title: 'Temporary Issue',
        message: 'We\'re having a temporary issue loading this event.',
        hint: corrId
          ? `Please refresh or try again in a minute. (Ref: ${esc(corrId)})`
          : 'Please refresh or try again in a minute.',
        onRetry,
        tvMode
      });
    },

    /**
     * Show timeout error state (S13: Graceful Degradation)
     * For requests that took too long
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode }
     */
    showTimeout(container, options = {}) {
      const { onRetry = null, tvMode = false } = options;
      this.showError(container, {
        title: 'Taking Too Long',
        message: 'The page is taking longer than expected to load.',
        hint: 'This might be a temporary issue. Please try again.',
        onRetry,
        tvMode
      });
    },

    /**
     * Show configuration issue state (Story 4: Frontend Error Handling)
     * For 4xx errors and GAS_UPSTREAM_NON_JSON - indicates backend misconfiguration
     *
     * Behavior:
     * - Production: Shows user-friendly message without technical details
     * - Staging: Shows expandable diagnostic panel with status, errorCode
     *
     * @param {HTMLElement} container - Target container
     * @param {Object} options - { onRetry, tvMode, error }
     */
    showConfigurationIssue(container, options = {}) {
      const { onRetry = null, tvMode = false, error = {} } = options;
      const isStaging = window.NU?.isStaging?.() || false;

      const stateClass = tvMode ? 'error-state-tv' : 'error-state config-issue-state';
      const iconClass = tvMode ? 'error-icon' : 'error-state-icon';

      // User-friendly message for all environments
      const title = 'Configuration Issue';
      const message = 'We\'re setting this event up. Try again later.';

      // Build diagnostic info for staging only
      let diagnosticHtml = '';
      if (isStaging && (error.status || error.errorCode || error.code)) {
        const status = error.status || 'N/A';
        const errorCode = error.errorCode || error.code || 'N/A';
        const corrId = error.corrId || 'N/A';

        diagnosticHtml = `
          <details class="diagnostic-panel" data-testid="diagnostic-panel">
            <summary class="diagnostic-toggle">Show Diagnostics</summary>
            <div class="diagnostic-content">
              <div class="diagnostic-row"><span class="diagnostic-label">Status:</span> <code>${esc(String(status))}</code></div>
              <div class="diagnostic-row"><span class="diagnostic-label">Error Code:</span> <code>${esc(String(errorCode))}</code></div>
              ${corrId !== 'N/A' ? `<div class="diagnostic-row"><span class="diagnostic-label">Correlation ID:</span> <code>${esc(String(corrId))}</code></div>` : ''}
              ${error.message ? `<div class="diagnostic-row"><span class="diagnostic-label">Message:</span> <code>${esc(String(error.message))}</code></div>` : ''}
            </div>
          </details>
        `;
      }

      container.innerHTML = `
        <div class="${stateClass}" data-testid="config-issue-card">
          <div class="${iconClass}">⚙️</div>
          <h3>${esc(title)}</h3>
          <p>${esc(message)}</p>
          ${diagnosticHtml}
          ${onRetry ? '<button class="btn-retry">🔄 Try Again</button>' : ''}
        </div>
      `;

      if (onRetry) {
        container.querySelector('.btn-retry')?.addEventListener('click', onRetry);
      }
    },

    /**
     * Auto-detect error type and show appropriate state
     * S13: Updated to handle SERVICE_UNAVAILABLE, TIMEOUT
     * Story 4: Added CONFIGURATION_ISSUE handling with staging diagnostics
     *
     * @param {HTMLElement} container - Target container
     * @param {string|Error|Object} error - Raw error, Error object, or {code, message, corrId, status, errorCode}
     * @param {Object} options - { onRetry, backUrl, tvMode }
     */
    showFromError(container, error, options = {}) {
      const { onRetry = null, backUrl = null, tvMode = false } = options;
      const errorType = classifyError(error);
      const corrId = error?.corrId || null;

      switch (errorType) {
        case ERROR_TYPES.EVENT_NOT_FOUND:
          this.showEventNotFound(container, { backUrl, tvMode });
          break;
        case ERROR_TYPES.NO_DATA:
          this.showNoData(container, { backUrl, tvMode });
          break;
        case ERROR_TYPES.NETWORK_ERROR:
          this.showNetworkError(container, { onRetry, tvMode });
          break;
        case ERROR_TYPES.UNAUTHORIZED:
          this.showUnauthorized(container, { backUrl, tvMode });
          break;
        case ERROR_TYPES.SERVICE_UNAVAILABLE:
          this.showTemporaryIssue(container, { onRetry, tvMode, corrId });
          break;
        case ERROR_TYPES.TIMEOUT:
          this.showTimeout(container, { onRetry, tvMode });
          break;
        case ERROR_TYPES.CONFIGURATION_ISSUE:
          // Story 4: Show configuration issue with staging diagnostics
          this.showConfigurationIssue(container, { onRetry, tvMode, error });
          break;
        default:
          this.showError(container, {
            title: 'Something Went Wrong',
            message: 'We couldn\'t load this content right now. This might be a temporary issue.',
            hint: corrId
              ? `Please try again in a moment. (Ref: ${esc(corrId)})`
              : 'Please try again in a moment.',
            onRetry,
            tvMode
          });
      }
    }
  };

  // === EVENT_CONTRACT.md v2.0 Support ===

  /**
   * Checks if an event section is enabled via settings
   * Extracted from Display.html and Poster.html (D-008)
   * Trust the contract - never invent flags
   *
   * Feature 4: Template-Aware Section Toggles - added showVideo, showMap, showGallery
   *
   * @param {Object} settings - Event settings object
   * @param {string} key - Section key: 'schedule', 'standings', 'bracket', 'sponsors', 'video', 'map', 'gallery'
   * @returns {boolean} True if section is enabled
   */
  function sectionEnabled(settings, key) {
    if (!settings) return false;
    switch (key) {
      // Data sections (require explicit true)
      case 'schedule': return settings.showSchedule === true;
      case 'standings': return settings.showStandings === true;
      case 'bracket': return settings.showBracket === true;
      case 'sponsors': return settings.showSponsors === true;
      // Content sections (default true for backwards compat - Feature 4)
      case 'video': return settings.showVideo !== false;
      case 'map': return settings.showMap !== false;
      case 'gallery': return settings.showGallery !== false;
      default: return false;
    }
  }

  // === Public API ===
  return {
    // Alerts
    showAlert,

    // Toast (non-blocking)
    showToast,

    // State rendering (S12: Enhanced with convenience methods)
    StateRenderer,
    ERROR_TYPES,
    classifyError,

    // Date formatting
    formatDate,
    formatRelativeTime,

    // Form utilities
    validateForm,
    isValidEmail,
    isValidUrl,

    // Loading state
    withLoadingState,

    // DOM utilities
    toggleElement,
    showElement,
    hideElement,

    // XSS (delegates to NU.esc)
    esc,

    // Utility functions
    debounce,
    throttle,

    // EVENT_CONTRACT helpers
    sectionEnabled
  };
})();
</script>

  <!--
================================================================================
GlobalErrorHandler.html - Global Error Handling for MVP Surfaces
================================================================================
Story 4.3: Graceful Error Handling in UI

RESPONSIBILITY: This file provides global error handling for client-side JavaScript.
- Catches uncaught exceptions (window.onerror)
- Catches unhandled promise rejections (unhandledrejection)
- Provides error boundary wrapper for async operations
- Shows user-friendly error dialogs
- Implements retry logic with exponential backoff
- Logs errors for developer diagnostics

WINDOW ADDITIONS:
- window.GlobalErrorHandler - Main error handler object

Dependencies: NUSDK.html (for NU._log), SharedUtils.html (for showToast)
Used by: Admin.html, Public.html, Display.html, Poster.html, SharedReport.html

USAGE:
  // Wrap async operations with error boundary
  await GlobalErrorHandler.withErrorBoundary(async () => {
    const res = await NU.rpc('api_getData', payload);
    if (!res.ok) throw res;
    return res.value;
  }, {
    context: 'loading events',
    onError: (err) => SharedUtils.StateRenderer.showFromError(container, err),
    retry: true
  });

  // Manual error reporting
  GlobalErrorHandler.reportError(error, { context: 'user action', userId: '123' });

  // Show error dialog
  GlobalErrorHandler.showErrorDialog({
    title: 'Unable to Save',
    message: 'Your changes could not be saved. Please try again.',
    onRetry: () => saveData()
  });

================================================================================
-->
<script>
(function() {
  'use strict';

  // =============================================================================
  // Configuration
  // =============================================================================
  const CONFIG = {
    // Maximum errors to log before throttling (prevent log spam)
    maxErrorsPerMinute: 10,
    // Error throttle window in ms
    throttleWindow: 60000,
    // Default retry attempts
    defaultRetryAttempts: 3,
    // Base delay for exponential backoff (ms)
    baseRetryDelay: 1000,
    // Maximum retry delay (ms)
    maxRetryDelay: 16000,
    // Errors to ignore (browser extensions, etc.)
    ignoredErrorPatterns: [
      /script error/i,
      /extension/i,
      /chrome-extension/i,
      /moz-extension/i,
      /ResizeObserver loop/i,
      /Loading chunk/i
    ],
    // Auto-dismiss toast errors after this many ms (0 = don't auto-dismiss)
    toastDuration: 5000
  };

  // =============================================================================
  // Error Tracking State
  // =============================================================================
  const errorState = {
    errorCount: 0,
    lastErrorReset: Date.now(),
    recentErrors: [], // Rolling buffer of recent errors for diagnostics
    maxRecentErrors: 50,
    isDialogOpen: false
  };

  // =============================================================================
  // Helper Functions
  // =============================================================================

  /**
   * Check if error should be ignored (browser extensions, etc.)
   * @param {string} message - Error message
   * @param {string} source - Error source URL
   * @returns {boolean} True if error should be ignored
   */
  function shouldIgnoreError(message, source) {
    const combined = `${message || ''} ${source || ''}`;
    return CONFIG.ignoredErrorPatterns.some(pattern => pattern.test(combined));
  }

  /**
   * Check if we're being throttled due to too many errors
   * @returns {boolean} True if throttled
   */
  function isThrottled() {
    const now = Date.now();
    if (now - errorState.lastErrorReset > CONFIG.throttleWindow) {
      errorState.errorCount = 0;
      errorState.lastErrorReset = now;
    }
    return errorState.errorCount >= CONFIG.maxErrorsPerMinute;
  }

  /**
   * Sanitize error message for user display (remove internal details)
   * @param {string} message - Raw error message
   * @returns {string} Sanitized message
   */
  function sanitizeMessage(message) {
    if (!message) return 'An unexpected error occurred';

    // Remove file paths, line numbers, stack traces
    let sanitized = String(message)
      .replace(/at\s+[\w.]+\s+\([^)]+\)/g, '') // Remove stack trace lines
      .replace(/https?:\/\/[^\s]+/g, '[url]')   // Remove URLs
      .replace(/:\d+:\d+/g, '')                  // Remove line:col numbers
      .replace(/\s+/g, ' ')                      // Normalize whitespace
      .trim();

    // If message is too technical, use generic message
    if (sanitized.length > 200 || /\{.*\}/.test(sanitized) || /\[.*\]/.test(sanitized)) {
      return 'An unexpected error occurred';
    }

    return sanitized || 'An unexpected error occurred';
  }

  /**
   * Extract error details for logging (internal use only)
   * @param {Error|string|Object} error - Error to extract details from
   * @returns {Object} Error details
   */
  function extractErrorDetails(error) {
    if (!error) {
      return { message: 'Unknown error', code: 'UNKNOWN', stack: null };
    }

    if (typeof error === 'string') {
      return { message: error, code: 'STRING_ERROR', stack: null };
    }

    return {
      message: error.message || error.msg || String(error),
      code: error.code || 'UNKNOWN',
      corrId: error.corrId || null,
      stack: error.stack || null,
      name: error.name || 'Error'
    };
  }

  /**
   * Log error to NUSDK rolling buffer
   * @param {Object} errorDetails - Error details
   * @param {Object} context - Additional context
   */
  function logError(errorDetails, context = {}) {
    // Check throttling
    if (isThrottled()) {
      console.warn('[GlobalErrorHandler] Error logging throttled due to high error rate');
      return;
    }

    errorState.errorCount++;

    const entry = {
      timestamp: new Date().toISOString(),
      type: 'global_error',
      ...errorDetails,
      context,
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    // Add to recent errors buffer
    errorState.recentErrors.push(entry);
    if (errorState.recentErrors.length > errorState.maxRecentErrors) {
      errorState.recentErrors.shift();
    }

    // Log via NUSDK if available
    if (window.NU && typeof window.NU._log === 'function') {
      window.NU._log('error', 'global_error', entry);
    } else {
      console.error('[GlobalErrorHandler]', entry);
    }
  }

  // =============================================================================
  // Error Dialog UI
  // =============================================================================

  /**
   * Inject error dialog styles (once)
   */
  function injectDialogStyles() {
    if (document.getElementById('global-error-dialog-styles')) return;

    const style = document.createElement('style');
    style.id = 'global-error-dialog-styles';
    style.textContent = `
      .global-error-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fade-in 0.2s ease;
      }

      .global-error-dialog {
        background: #fff;
        border-radius: 16px;
        padding: 32px;
        max-width: 420px;
        width: 90%;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        animation: slide-up 0.3s ease;
      }

      .global-error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .global-error-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: #1e293b;
        margin: 0 0 12px;
      }

      .global-error-message {
        font-size: 1rem;
        color: #64748b;
        margin: 0 0 24px;
        line-height: 1.5;
      }

      .global-error-details {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 12px;
        font-family: monospace;
        font-size: 0.8rem;
        color: #64748b;
        margin-bottom: 24px;
        text-align: left;
        word-break: break-word;
      }

      .global-error-actions {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .global-error-btn {
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
      }

      .global-error-btn-primary {
        background: #2563eb;
        color: #fff;
      }

      .global-error-btn-primary:hover {
        background: #1d4ed8;
      }

      .global-error-btn-secondary {
        background: #f1f5f9;
        color: #475569;
      }

      .global-error-btn-secondary:hover {
        background: #e2e8f0;
      }

      .global-error-support {
        margin-top: 16px;
        font-size: 0.85rem;
        color: #94a3b8;
      }

      .global-error-support a {
        color: #2563eb;
        text-decoration: none;
      }

      .global-error-support a:hover {
        text-decoration: underline;
      }

      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @keyframes slide-up {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
    `;
    document.head.appendChild(style);
  }

  /**
   * Show error dialog to user
   * @param {Object} options - Dialog options
   */
  function showErrorDialog(options = {}) {
    const {
      title = 'Oops, Something Went Wrong',
      message = 'We encountered an unexpected error. Please try again.',
      icon = '😕',
      showRetry = true,
      showDismiss = true,
      showDetails = false,
      details = null,
      corrId = null,
      onRetry = null,
      onDismiss = null,
      supportEmail = null
    } = options;

    // Don't show multiple dialogs
    if (errorState.isDialogOpen) return;
    errorState.isDialogOpen = true;

    injectDialogStyles();

    const overlay = document.createElement('div');
    overlay.className = 'global-error-overlay';
    overlay.setAttribute('role', 'dialog');
    overlay.setAttribute('aria-modal', 'true');
    overlay.setAttribute('aria-labelledby', 'error-dialog-title');

    let detailsHtml = '';
    if (showDetails && (details || corrId)) {
      const detailText = corrId ? `Reference: ${corrId}` : details;
      detailsHtml = `<div class="global-error-details">${escapeHtml(detailText)}</div>`;
    }

    let actionsHtml = '';
    if (showRetry) {
      actionsHtml += '<button class="global-error-btn global-error-btn-primary" data-action="retry">Try Again</button>';
    }
    if (showDismiss) {
      actionsHtml += '<button class="global-error-btn global-error-btn-secondary" data-action="dismiss">Dismiss</button>';
    }

    let supportHtml = '';
    if (supportEmail || corrId) {
      supportHtml = '<div class="global-error-support">';
      if (corrId) {
        supportHtml += `Reference: <code>${escapeHtml(corrId)}</code>`;
      }
      if (supportEmail) {
        supportHtml += corrId ? '<br>' : '';
        supportHtml += `Need help? <a href="mailto:${escapeHtml(supportEmail)}">Contact support</a>`;
      }
      supportHtml += '</div>';
    }

    overlay.innerHTML = `
      <div class="global-error-dialog">
        <div class="global-error-icon">${icon}</div>
        <h2 class="global-error-title" id="error-dialog-title">${escapeHtml(title)}</h2>
        <p class="global-error-message">${escapeHtml(message)}</p>
        ${detailsHtml}
        <div class="global-error-actions">${actionsHtml}</div>
        ${supportHtml}
      </div>
    `;

    // Handle button clicks
    overlay.addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      if (action === 'retry') {
        closeDialog();
        if (onRetry) onRetry();
      } else if (action === 'dismiss' || e.target === overlay) {
        closeDialog();
        if (onDismiss) onDismiss();
      }
    });

    // Handle escape key
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        closeDialog();
        if (onDismiss) onDismiss();
      }
    };
    document.addEventListener('keydown', handleEscape);

    function closeDialog() {
      errorState.isDialogOpen = false;
      document.removeEventListener('keydown', handleEscape);
      overlay.remove();
    }

    document.body.appendChild(overlay);

    // Focus the first button for accessibility
    const firstBtn = overlay.querySelector('button');
    if (firstBtn) firstBtn.focus();
  }

  /**
   * Show error toast (non-modal notification)
   * @param {string} message - Error message
   * @param {Object} options - Toast options
   */
  function showErrorToast(message, options = {}) {
    const { duration = CONFIG.toastDuration } = options;

    // Use SharedUtils.showToast if available
    if (window.SharedUtils && typeof window.SharedUtils.showToast === 'function') {
      window.SharedUtils.showToast(sanitizeMessage(message), 'error', duration);
    } else {
      // Fallback to console
      console.error('[GlobalErrorHandler Toast]', message);
    }
  }

  /**
   * Escape HTML for safe display
   * @param {string} str - String to escape
   * @returns {string} Escaped string
   */
  function escapeHtml(str) {
    if (window.NU && typeof window.NU.esc === 'function') {
      return window.NU.esc(str);
    }
    if (!str) return '';
    return String(str).replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  }

  // =============================================================================
  // Retry Logic
  // =============================================================================

  /**
   * Execute with retry and exponential backoff
   * @param {Function} fn - Async function to execute
   * @param {Object} options - Retry options
   * @returns {Promise<any>} Result of fn
   */
  async function withRetry(fn, options = {}) {
    const {
      attempts = CONFIG.defaultRetryAttempts,
      baseDelay = CONFIG.baseRetryDelay,
      maxDelay = CONFIG.maxRetryDelay,
      shouldRetry = (err) => err?.code === 'NETWORK_ERROR' || err?.code === 'TIMEOUT',
      onRetryAttempt = null
    } = options;

    let lastError;

    for (let attempt = 1; attempt <= attempts; attempt++) {
      try {
        return await fn();
      } catch (err) {
        lastError = err;

        // Check if we should retry
        if (attempt === attempts || !shouldRetry(err)) {
          throw err;
        }

        // Calculate delay with exponential backoff + jitter
        const delay = Math.min(
          baseDelay * Math.pow(2, attempt - 1) + Math.random() * 1000,
          maxDelay
        );

        if (onRetryAttempt) {
          onRetryAttempt(attempt, attempts, delay, err);
        }

        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    throw lastError;
  }

  // =============================================================================
  // Error Boundary Wrapper
  // =============================================================================

  /**
   * Wrap async operations with error boundary
   * @param {Function} fn - Async function to execute
   * @param {Object} options - Error boundary options
   * @returns {Promise<any>} Result of fn or null on error
   */
  async function withErrorBoundary(fn, options = {}) {
    const {
      context = 'operation',
      onError = null,
      showToast = true,
      showDialog = false,
      retry = false,
      retryOptions = {},
      fallbackValue = null,
      rethrow = false
    } = options;

    try {
      if (retry) {
        return await withRetry(fn, retryOptions);
      }
      return await fn();

    } catch (err) {
      const errorDetails = extractErrorDetails(err);

      // Log the error
      logError(errorDetails, { context, retry });

      // Notify via callback
      if (onError) {
        onError(err);
      }

      // Show UI notification
      if (showDialog) {
        showErrorDialog({
          title: 'Unable to Complete Action',
          message: `We couldn't complete ${context}. Please try again.`,
          corrId: errorDetails.corrId,
          onRetry: retry ? () => withErrorBoundary(fn, options) : null
        });
      } else if (showToast) {
        showErrorToast(`Unable to ${context}. Please try again.`);
      }

      if (rethrow) {
        throw err;
      }

      return fallbackValue;
    }
  }

  // =============================================================================
  // Global Error Handlers
  // =============================================================================

  /**
   * Global error handler for uncaught exceptions
   */
  function handleGlobalError(message, source, lineno, colno, error) {
    // Check if we should ignore this error
    if (shouldIgnoreError(message, source)) {
      return false; // Let browser handle it
    }

    const errorDetails = {
      message: String(message),
      source,
      lineno,
      colno,
      stack: error?.stack || null
    };

    logError(errorDetails, { handler: 'window.onerror' });

    // Don't show UI for minor errors that don't affect functionality
    // Only show for critical errors that break the page
    if (error && error.name !== 'SyntaxError') {
      showErrorToast('Something went wrong. Please refresh if the page isn\'t working correctly.');
    }

    return false; // Let error propagate to console for debugging
  }

  /**
   * Global handler for unhandled promise rejections
   */
  function handleUnhandledRejection(event) {
    const error = event.reason;

    // Check if we should ignore this error
    const message = error?.message || String(error);
    if (shouldIgnoreError(message, '')) {
      return;
    }

    const errorDetails = extractErrorDetails(error);
    logError(errorDetails, { handler: 'unhandledrejection' });

    // Show toast for unhandled rejections
    showErrorToast('An unexpected error occurred. Please try again.');
  }

  // =============================================================================
  // Install Global Handlers
  // =============================================================================

  // Only install if not already installed
  if (!window.__GLOBAL_ERROR_HANDLER_INSTALLED__) {
    window.__GLOBAL_ERROR_HANDLER_INSTALLED__ = true;

    // Install window.onerror
    const originalOnError = window.onerror;
    window.onerror = function(message, source, lineno, colno, error) {
      handleGlobalError(message, source, lineno, colno, error);
      if (originalOnError) {
        return originalOnError.call(this, message, source, lineno, colno, error);
      }
      return false;
    };

    // Install unhandledrejection handler
    window.addEventListener('unhandledrejection', handleUnhandledRejection);

    // Log initialization
    if (window.NU && typeof window.NU._log === 'function') {
      window.NU._log('debug', 'init', { module: 'GlobalErrorHandler', version: '1.0.0' });
    }
  }

  // =============================================================================
  // Public API
  // =============================================================================

  window.GlobalErrorHandler = {
    /**
     * Version
     */
    VERSION: '1.0.0',

    /**
     * Wrap async operations with error boundary
     * @param {Function} fn - Async function to execute
     * @param {Object} options - Error boundary options
     * @returns {Promise<any>} Result of fn or fallbackValue on error
     */
    withErrorBoundary,

    /**
     * Execute with retry and exponential backoff
     * @param {Function} fn - Async function to execute
     * @param {Object} options - Retry options
     * @returns {Promise<any>} Result of fn
     */
    withRetry,

    /**
     * Show error dialog to user
     * @param {Object} options - Dialog options
     */
    showErrorDialog,

    /**
     * Show error toast notification
     * @param {string} message - Error message
     * @param {Object} options - Toast options
     */
    showErrorToast,

    /**
     * Report an error manually
     * @param {Error|string|Object} error - Error to report
     * @param {Object} context - Additional context
     */
    reportError(error, context = {}) {
      const errorDetails = extractErrorDetails(error);
      logError(errorDetails, context);
    },

    /**
     * Get recent errors for diagnostics
     * @returns {Array} Recent error entries
     */
    getRecentErrors() {
      return [...errorState.recentErrors];
    },

    /**
     * Clear recent errors
     */
    clearRecentErrors() {
      errorState.recentErrors.length = 0;
    },

    /**
     * Get error statistics
     * @returns {Object} Error statistics
     */
    getStats() {
      return {
        totalRecentErrors: errorState.recentErrors.length,
        errorsThisMinute: errorState.errorCount,
        isThrottled: isThrottled(),
        lastErrorReset: new Date(errorState.lastErrorReset).toISOString()
      };
    },

    /**
     * Configure error handler
     * @param {Object} options - Configuration options
     */
    configure(options = {}) {
      Object.assign(CONFIG, options);
    }
  };

})();
</script>

  <script>
/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * SponsorUtils - Shared utilities for sponsor rendering across surfaces
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * RESPONSIBILITY: This file handles sponsor rendering and analytics ONLY.
 * It does NOT create/modify sponsors - that's Code.gs territory.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 * [MVP] SPONSOR CONTRACT - /schemas/sponsor.schema.json
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * CANONICAL SPONSOR SHAPE (all fields per schema):
 * {
 *   id: string,              // MVP REQUIRED - Unique sponsor identifier
 *   name: string,            // MVP REQUIRED - Display name (1-200 chars)
 *   logoUrl: string,         // MVP REQUIRED - URL to logo image (https://...)
 *   linkUrl?: string|null,   // MVP OPTIONAL - Click-through URL
 *   placement: string        // MVP REQUIRED - "poster"|"display"|"public"|"tv-banner"
 * }
 *
 * This utility normalizes legacy formats (img, url, placements) to the canonical shape.
 * All surfaces MUST use normalizeSponsor() before rendering.
 *
 * ═══════════════════════════════════════════════════════════════════════════════
 *
 * WINDOW ADDITION: window.SponsorUtils
 *
 * Used by: Display.html, Public.html, Poster.html
 * ═══════════════════════════════════════════════════════════════════════════════
 */
window.SponsorUtils = (function() {
  'use strict';

  // === XSS Prevention ===
  function esc(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[m]));
  }

  // === Session ID for analytics attribution ===
  // Ties all events from same page visit together
  let sessionId = null;

  // Generate UUID using crypto API (secure)
  function generateSecureUUID() {
    // Prefer native crypto.randomUUID if available (modern browsers)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback: use crypto.getRandomValues (secure, wider support)
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      const bytes = new Uint8Array(16);
      crypto.getRandomValues(bytes);
      // Set version (4) and variant (RFC4122)
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
      const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
      return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
    }
    // Last resort fallback (very old browsers) - use timestamp + counter for uniqueness
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c, i) => {
      const r = (Date.now() + i) % 16;
      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
  }

  function getSessionId() {
    if (sessionId) return sessionId;
    // Check sessionStorage first (persists across page reloads in same tab)
    try {
      sessionId = sessionStorage.getItem('zeb_session_id');
      if (!sessionId) {
        sessionId = generateSecureUUID();
        sessionStorage.setItem('zeb_session_id', sessionId);
      }
    } catch (_) {
      // sessionStorage not available, use in-memory only
      sessionId = generateSecureUUID();
    }
    return sessionId;
  }

  // === Analytics Logging ===
  const BATCH_SIZE = 5;
  const FLUSH_INTERVAL = 5000;
  let logBatch = [];
  let flushTimer = null;

  function logEvent(evt) {
    try {
      evt.ua = navigator.userAgent;
      evt.ts = Date.now();
      evt.sessionId = getSessionId();  // Always include sessionId
      logBatch.push(evt);
      if (logBatch.length >= BATCH_SIZE) flush();
    } catch (_) {}
  }

  function flush() {
    if (!logBatch.length) return;
    const copy = logBatch.splice(0, logBatch.length);
    NU.safeAnalytics('api_logEvents', { items: copy });
  }

  function initLogging() {
    if (flushTimer) clearInterval(flushTimer);
    flushTimer = setInterval(flush, FLUSH_INTERVAL);
    window.addEventListener('beforeunload', flush);
    getSessionId(); // Initialize sessionId early
  }

  // === Sponsor Filtering ===
  function filterByPlacement(sponsors, placement) {
    return (sponsors || []).filter(s => s?.placements?.[placement]);
  }

  // === Generic Sponsor Renderer ===
  /**
   * Renders sponsors to a container element
   * @param {Object} options
   * @param {Array} options.sponsors - Array of sponsor objects
   * @param {string} options.placement - Placement key (tvTop, tvSide, mobileBanner, posterTop)
   * @param {HTMLElement} options.container - Target container element
   * @param {string} options.surface - Surface name for logging (display, public, poster)
   * @param {string} options.eventId - Event ID for logging
   * @param {string} options.layout - 'inline' (top bar), 'cards' (side panel), 'banner' (single)
   * @param {boolean} options.trackClicks - Whether to track click events
   * @param {boolean} options.trackImpressions - Whether to log impressions
   * @param {boolean} options.wrapLinks - Whether to wrap sponsors with URLs in anchor tags
   * @param {number} options.maxSponsors - Max sponsors to show (0 = all)
   * @returns {Array} - Filtered sponsors that were rendered
   */
  function renderSponsors(options) {
    const {
      sponsors = [],
      placement,
      container,
      surface = 'unknown',
      eventId = '',
      layout = 'inline',
      trackClicks = true,
      trackImpressions = true,
      wrapLinks = true,
      maxSponsors = 0
    } = options;

    if (!container || !placement) return [];

    let picks = filterByPlacement(sponsors, placement);
    if (!picks.length) return [];

    // Limit sponsors if maxSponsors is set
    if (maxSponsors > 0) {
      picks = picks.slice(0, maxSponsors);
    }

    // Render based on layout type
    let html = '';
    switch (layout) {
      case 'cards':
        html = picks.map(s => renderCard(s, wrapLinks)).join('');
        break;
      case 'banner':
        html = picks.map(s => renderBanner(s, wrapLinks)).join('');
        break;
      case 'inline':
      default:
        html = picks.map(s => renderInline(s, wrapLinks)).join('');
    }

    container.innerHTML = html;
    container.hidden = false;

    // Log impressions
    if (trackImpressions) {
      picks.forEach(s => {
        logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id || '' });
      });
    }

    // Attach click handlers
    if (trackClicks && wrapLinks) {
      container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
        a.addEventListener('click', () => {
          logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
        });
      });
    }

    return picks;
  }

  // === Layout Renderers ===
  function renderInline(s, wrapLinks) {
    const content = s.img
      ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">`
      : `<strong>${esc(s.name || '')}</strong>`;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}">${content}</a>`;
    }
    return content;
  }

  function renderCard(s, wrapLinks) {
    const card = `
      <div class="sp-card" data-id="${esc(s.id || '')}">
        ${s.img ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">` : ''}
        <div class="sp-name">${esc(s.name || '')}</div>
      </div>
    `;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}" style="text-decoration:none;color:inherit;">${card}</a>`;
    }
    return card;
  }

  function renderBanner(s, wrapLinks) {
    const content = `
      ${s.img ? `<img src="${esc(s.img)}" alt="${esc(s.name || '')}">` : ''}
      <strong>${esc(s.name || '')}</strong>
    `;

    if (wrapLinks && s.url) {
      return `<a href="${esc(s.url)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id || '')}">${content}</a>`;
    }
    return `<span>${content}</span>`;
  }

  // === Sponsor Normalization ===
  /**
   * Normalize sponsor object to schema-compliant format
   * Schema: /schemas/sponsor.schema.json
   *
   * CANONICAL FIELDS (per schema):
   * - id: string (required)
   * - name: string (required)
   * - logoUrl: string (required)
   * - linkUrl: string (optional)
   * - placement: "poster"|"display"|"public"|"tv-banner" (required)
   * - isPrimary: boolean (optional) - Primary sponsor gets bigger rendering
   *
   * LEGACY FIELD MAPPING (deprecated - will be removed in V3):
   * - s.img → logoUrl
   * - s.url → linkUrl
   * - s.website → linkUrl
   * - s.placements → placement (first key with true value)
   *
   * @param {Object} s - Sponsor object (schema or legacy format)
   * @returns {Object} - Schema-compliant sponsor: { id, name, logoUrl, linkUrl, placement, isPrimary }
   */
  function normalizeSponsor(s) {
    if (!s) return null;

    // Determine placement from schema field or legacy placements object
    let placement = s.placement || '';
    if (!placement && s.placements && typeof s.placements === 'object') {
      // Legacy: find first true placement key
      placement = Object.keys(s.placements).find(k => s.placements[k]) || '';
    }

    return {
      // Schema fields
      id: s.id || '',
      name: s.name || '',
      logoUrl: s.logoUrl || s.img || '',      // Legacy fallback: img
      linkUrl: s.linkUrl || s.website || s.url || '',  // Legacy fallback: website, url
      placement: placement,
      isPrimary: !!s.isPrimary  // Feature 3: Primary sponsor flag
    };
  }

  // === Unified SponsorRenderer ===
  /**
   * Unified sponsor rendering component
   * Replaces duplicate renderSponsor* functions across surfaces
   *
   * All methods expect sponsors in schema format (/schemas/sponsor.schema.json):
   * { id, name, logoUrl, linkUrl?, placement }
   *
   * Legacy formats (img, url, placements) are auto-converted via normalizeSponsor().
   *
   * CENTRALIZED PLACEMENT FILTERING:
   * All methods accept optional `placement` parameter to filter sponsors.
   * Supported placements: 'poster' | 'public' | 'display' | 'tv-banner'
   * For Display surface, use placement: ['display', 'tv-banner'] to match either.
   */
  const SponsorRenderer = {
    /**
     * Filter sponsors by placement(s)
     * @param {Array} sponsors - Normalized sponsor array
     * @param {string|string[]} placement - Single placement or array of placements to match
     * @returns {Array} - Filtered sponsors
     */
    _filterByPlacement(sponsors, placement) {
      if (!placement) return sponsors;
      const placements = Array.isArray(placement) ? placement : [placement];
      return sponsors.filter(s => placements.includes(s.placement));
    },

    /**
     * Render sponsors as horizontal strip (top bar, banner)
     * @param {Object} options
     * @param {HTMLElement} options.container - Target element
     * @param {Array} options.sponsors - Sponsor array (schema or legacy format)
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {string} options.eventId - For analytics
     * @param {string} options.surface - Surface name (display, public, poster)
     * @param {boolean} options.showLinks - Wrap in anchor tags (default: true)
     * @param {boolean} options.showTier - Show PRIMARY badge for primary sponsors (default: false)
     * @param {Function} options.onRender - Callback with rendered sponsor IDs
     * @returns {Array} - Normalized sponsors that were rendered
     */
    renderStrip(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        showTier = false,
        onRender = null
      } = options;

      if (!container) return [];
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const filtered = this._filterByPlacement(normalized, placement);
      // Sort primary sponsors first
      const picks = filtered.sort((a, b) => (b.isPrimary ? 1 : 0) - (a.isPrimary ? 1 : 0));
      if (!picks.length) return [];

      container.innerHTML = picks.map(s => {
        const primaryClass = s.isPrimary ? ' sponsor-primary' : '';
        const tierBadge = showTier && s.isPrimary ? '<span class="sponsor-tier-badge">PRIMARY</span>' : '';
        const content = s.logoUrl
          ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}" class="sponsor-logo${primaryClass}">${tierBadge}`
          : `<strong class="${primaryClass}">${esc(s.name)}</strong>${tierBadge}`;

        if (showLinks && s.linkUrl) {
          return `<a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id)}" class="sponsor-item${primaryClass}">${content}</a>`;
        }
        return `<span class="sponsor-item${primaryClass}">${content}</span>`;
      }).join('');

      container.hidden = false;

      // Log impressions
      picks.forEach(s => logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id }));

      // Attach click handlers
      if (showLinks) {
        container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
          a.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
          });
        });
      }

      // Callback with rendered IDs (for BBN attribution)
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return picks;
    },

    /**
     * Render sponsors as card grid (side panel, TV mode)
     * @param {Object} options - Same as renderStrip plus:
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {HTMLElement} options.mainEl - Optional main element to add 'has-side' class
     * @returns {Array} - Normalized sponsors that were rendered
     */
    renderGrid(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        mainEl = null,
        onRender = null
      } = options;

      if (!container) return [];
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const picks = this._filterByPlacement(normalized, placement);
      if (!picks.length) return [];

      container.innerHTML = picks.map(s => {
        const card = `
          <div class="sp-card" data-id="${esc(s.id)}">
            ${s.logoUrl ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}">` : ''}
            <div class="sp-name">${esc(s.name)}</div>
          </div>
        `;

        if (showLinks && s.linkUrl) {
          return `<a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" data-sponsor-id="${esc(s.id)}" style="text-decoration:none;color:inherit;">${card}</a>`;
        }
        return card;
      }).join('');

      container.hidden = false;
      if (mainEl) mainEl.classList.add('has-side');

      // Log impressions
      picks.forEach(s => logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id }));

      // Attach click handlers
      if (showLinks) {
        container.querySelectorAll('a[data-sponsor-id]').forEach(a => {
          a.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: a.dataset.sponsorId });
          });
        });
      }

      // Callback with rendered IDs
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return picks;
    },

    /**
     * Render sponsors as rotating carousel (one at a time)
     * @param {Object} options - Same as renderStrip plus:
     * @param {string|string[]} options.placement - Filter by placement(s): 'poster'|'public'|'display'|'tv-banner'
     * @param {number} options.rotationMs - Rotation interval (default: 5000)
     * @returns {Object} - { sponsors: Array, stop: Function }
     */
    renderCarousel(options) {
      const {
        container,
        sponsors = [],
        placement = null,
        eventId = '',
        surface = 'unknown',
        showLinks = true,
        showTier = false,
        rotationMs = 5000,
        onRender = null
      } = options;

      if (!container) return { sponsors: [], stop: () => {} };
      // Normalize all sponsors, then filter by placement if specified
      const normalized = sponsors.map(normalizeSponsor).filter(s => s && s.name);
      const picks = this._filterByPlacement(normalized, placement);
      if (!picks.length) return { sponsors: [], stop: () => {} };

      let currentIndex = 0;
      let timer = null;

      function showSponsor(index) {
        const s = picks[index];
        const indicator = picks.length > 1 ? `<span class="sponsor-indicator">${index + 1}/${picks.length}</span>` : '';

        const content = `
          ${s.logoUrl ? `<img src="${esc(s.logoUrl)}" alt="${esc(s.name)}">` : ''}
          <strong>${esc(s.name)}</strong>
        `;

        if (showLinks && s.linkUrl) {
          container.innerHTML = `
            <a href="${esc(s.linkUrl)}" target="_blank" rel="noopener sponsored" class="sponsor-link" data-sponsor-id="${esc(s.id)}">
              ${content}
            </a>
            ${indicator}
          `;
        } else {
          container.innerHTML = `<span>${content}</span>${indicator}`;
        }

        // Log impression
        logEvent({ eventId, surface, metric: 'impression', sponsorId: s.id });

        // Attach click handler
        const linkEl = container.querySelector('.sponsor-link');
        if (linkEl) {
          linkEl.addEventListener('click', () => {
            logEvent({ eventId, surface, metric: 'click', sponsorId: s.id });
          });
        }
      }

      // Show first sponsor
      showSponsor(0);
      container.hidden = false;

      // Start rotation if multiple sponsors
      if (picks.length > 1) {
        timer = setInterval(() => {
          currentIndex = (currentIndex + 1) % picks.length;
          showSponsor(currentIndex);
        }, rotationMs);
      }

      // Callback with rendered IDs
      if (onRender) onRender(picks.map(s => s.id).filter(Boolean));

      return {
        sponsors: picks,
        stop: () => { if (timer) clearInterval(timer); }
      };
    },

    // Expose normalization for external use
    normalizeSponsor
  };

  // === Public API ===
  return {
    esc,
    logEvent,
    flush,
    initLogging,
    getSessionId,  // For external click handlers that need sessionId
    filterByPlacement,
    renderSponsors,
    // Expose individual renderers for custom use
    renderInline,
    renderCard,
    renderBanner,
    // NEW: Unified renderer
    SponsorRenderer,
    normalizeSponsor,
    // Constants
    BATCH_SIZE,
    FLUSH_INTERVAL
  };
})();
</script>

  <!--
================================================================================
FooterComponent - Centralized Trust Footer
================================================================================
Extracted from: Display.html, Poster.html, Public.html, SharedReport.html
Purpose: Consistent "Powered by" footer across all MVP surfaces

Usage:
  include('FooterComponent')

Variants:
  - Default: Standard footer for light backgrounds
  - TV: Subtle footer for dark TV/display mode (use .site-footer-tv)
  - Print: Optimized for print media

DO NOT modify this component's structure without updating:
  - All MVP surfaces that include it
  - Design system documentation
================================================================================
-->
<style>
  /* ===== Trust Footer Component ===== */
  .site-footer {
    text-align: center;
    padding: 24px 16px;
    margin-top: 40px;
    border-top: 1px solid var(--color-gray-200, #e2e8f0);
    color: var(--color-gray-400, #94a3b8);
    font-size: 0.7rem;
  }

  .site-footer a {
    color: var(--color-gray-500, #64748b);
    text-decoration: none;
    transition: color var(--transition-fast, 0.15s ease);
  }

  .site-footer a:hover {
    color: var(--color-primary, #2563eb);
    text-decoration: underline;
  }

  /* TV Mode Variant (dark background) */
  .site-footer-tv,
  body[data-tv="1"] .site-footer {
    position: fixed;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255, 255, 255, 0.3);
    font-size: 0.6rem;
    z-index: 100;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
  }

  .site-footer-tv a,
  body[data-tv="1"] .site-footer a {
    color: rgba(255, 255, 255, 0.4);
  }

  .site-footer-tv a:hover,
  body[data-tv="1"] .site-footer a:hover {
    color: rgba(255, 255, 255, 0.6);
    text-decoration: none;
  }

  /* Print Styles */
  @media print {
    .site-footer {
      border-top: none;
      padding: 12px;
      font-size: 8pt;
      margin-top: 20px;
      page-break-inside: avoid;
    }

    .site-footer-tv {
      position: static;
      transform: none;
    }
  }
</style>

<!-- Default Footer Template (can be included or used as reference) -->
<template id="footer-template">
  <footer class="site-footer">
    <p>Powered by <a href="https://eventangle.com" target="_blank" rel="noopener">EventAngle</a></p>
  </footer>
</template>

  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <meta name="referrer" content="no-referrer"/>
  <style>
    /* Poster-specific styles - uses design tokens from DesignAdapter */
    [hidden] { display:none !important; }
    body { background: #fff; }
    .poster-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 20px;
      background: #fff;
    }

    /* Enhanced Sponsor Strip */
    .sponsor-strip {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 24px;
      padding: 20px;
      border-bottom: 3px solid var(--color-primary, #2563eb);
      margin-bottom: 40px;
      background: var(--gradient-sponsor-bg, linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f8fafc 100%));
      box-shadow: var(--shadow-sm, 0 2px 8px rgba(0,0,0,0.05));
    }
    .sponsor-strip img {
      max-height: var(--poster-sponsor-logo-height, 70px);
      object-fit: contain;
    }
    .sponsor-strip strong {
      color: var(--color-gray-800, #1e293b);
      font-size: 1.3em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Enhanced Event Details */
    .event-details {
      text-align: center;
      margin-bottom: 40px;
      padding: 24px;
      background: linear-gradient(135deg, var(--color-gray-50, #f8fafc) 0%, #ffffff 100%);
      border-radius: var(--radius-md, 12px);
    }
    .event-details h1 {
      color: var(--color-primary, #2563eb);
      font-size: 2.8rem;
      margin-bottom: 20px;
      line-height: 1.2;
      text-shadow: 0 2px 4px rgba(37, 99, 235, 0.1);
    }
    .event-meta {
      font-size: 1.3rem;
      color: var(--color-gray-600, #475569);
      margin: 12px 0;
      line-height: 1.8;
    }
    .event-meta strong {
      color: var(--color-gray-800, #1e293b);
      font-weight: 700;
    }
    /* V2 REMOVED: .event-image and .event-summary CSS deleted - not in schema */

    /* Enhanced QR Codes */
    .qr-section {
      margin-top: 48px;
      padding: 32px 0;
      border-top: 3px solid #e2e8f0;
    }
    .qr-section h2 {
      text-align: center;
      color: #1e293b;
      font-size: 2rem;
      margin-bottom: 32px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .qr-section h2::before {
      content: "📱 ";
      font-size: 1.5em;
    }
    .qr-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 28px;
      margin: 24px 0;
    }
    .qr-code {
      text-align: center;
      padding: 24px;
      background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
      border-radius: 16px;
      border: 3px solid #e2e8f0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      transition: all 0.3s ease;
    }
    .qr-code:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 20px rgba(37, 99, 235, 0.15);
      border-color: #2563eb;
    }
    .qr-code h3 {
      margin: 0 0 8px;
      color: #2563eb;
      font-size: 1.3rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .qr-code h4 {
      margin: 0 0 16px;
      color: #64748b;
      font-size: 0.95rem;
      font-weight: 500;
    }
    .qr-code img {
      width: 100%;
      max-width: 220px;
      height: auto;
      margin: 16px auto;
      display: block;
      border-radius: 8px;
      border: 2px solid #e2e8f0;
      padding: 8px;
      background: white;
    }
    .qr-code p {
      margin-top: 12px;
      color: #94a3b8;
      font-size: 10px;
      word-break: break-all;
      line-height: 1.4;
    }

    /* Print Styles - Optimized for printing */
    /* PR-001, PR-002: Enhanced print safety margins and areas */
    @media print {
      @page {
        margin: 0.5in;
        size: letter portrait;  /* Explicit paper size */
      }

      body {
        background: #fff;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      .poster-container {
        padding: 0;  /* @page margin handles outer spacing */
        max-width: 100%;
      }

      /* PR-002: Safe area for sponsor strip */
      .sponsor-strip {
        border: 0;
        padding: 12px 0.25in;  /* Inset from edge for print safety */
        box-shadow: none;
        background: #fff;
        margin: 0 -0.25in;
        width: calc(100% + 0.5in);
      }

      .event-details {
        background: #fff;
        padding: 16px 0;
      }

      /* PR-003: Prevent title overflow on print */
      .event-details h1 {
        font-size: clamp(1.5rem, 6vw, 2.5rem);
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
      }

      .qr-grid {
        gap: 16px;
        page-break-inside: avoid;
      }

      .qr-code {
        box-shadow: none;
        page-break-inside: avoid;
        border-width: 2px;
      }

      .qr-code:hover {
        transform: none;
      }

      .qr-section {
        page-break-inside: avoid;
      }

      .qr-section h2::before {
        content: "";
      }

      /* Hide interactive elements in print */
      .btn-retry,
      .site-footer a {
        text-decoration: none;
        color: inherit;
      }
    }

    /* Narrow print media (e.g., A5, receipt printers) */
    @media print and (max-width: 6in) {
      .qr-grid {
        grid-template-columns: 1fr 1fr;
      }

      .event-details h1 {
        font-size: 1.5rem;
      }

      .sponsor-strip img {
        max-height: 48px;
      }
    }

    /* Responsive - Mobile and tablet */
    @media (max-width: 768px) {
      body {
        overflow-x: hidden;
      }

      .poster-container {
        padding: 16px 12px;
        max-width: 100%;
      }

      .sponsor-strip {
        padding: 14px 12px;
        gap: 12px;
        margin-bottom: 24px;
        border-radius: 8px;
        flex-direction: row;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        justify-content: flex-start;
      }

      .sponsor-strip img {
        max-height: 48px;
        flex-shrink: 0;
      }

      .sponsor-strip strong {
        font-size: 1rem;
        white-space: nowrap;
      }

      .event-details {
        padding: 16px 12px;
        margin-bottom: 24px;
        border-radius: 8px;
      }

      .event-details h1 {
        font-size: 1.6rem;
        line-height: 1.3;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .event-meta {
        font-size: 1rem;
        line-height: 1.6;
      }

      .qr-section {
        margin-top: 24px;
        padding: 20px 0;
      }

      .qr-section h2 {
        font-size: 1.3rem;
        margin-bottom: 20px;
      }

      .qr-section h2::before {
        font-size: 1.2em;
      }

      .qr-grid {
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .qr-code {
        padding: 16px;
        border-radius: 12px;
      }

      .qr-code h3 {
        font-size: 1rem;
      }

      .qr-code h4 {
        font-size: 0.85rem;
        margin-bottom: 12px;
      }

      .qr-code img {
        max-width: 180px;
        margin: 12px auto;
        padding: 6px;
      }

      .qr-code p {
        font-size: 9px;
        line-height: 1.3;
      }

      .poster-watermark {
        margin-top: 20px;
        padding: 12px 0;
      }

      .watermark-text {
        font-size: 0.75rem;
      }

      .site-footer {
        padding: 16px;
        margin-top: 0;
      }
    }

    /* Very small screens (iPhone SE, etc.) */
    @media (max-width: 375px) {
      .poster-container {
        padding: 12px 8px;
      }

      .event-details h1 {
        font-size: 1.4rem;
      }

      .event-meta {
        font-size: 0.9rem;
      }

      .qr-section h2 {
        font-size: 1.1rem;
      }

      .qr-code {
        padding: 14px;
      }

      .qr-code img {
        max-width: 160px;
      }

      .sponsor-strip img {
        max-height: 40px;
      }
    }

    /* Tablet landscape - two QR codes side by side */
    @media (min-width: 500px) and (max-width: 768px) {
      .qr-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
      }
    }

    /* === MVP Essential: Empty/Error States === */
    .empty-state, .error-state {
      text-align: center;
      padding: 48px 24px;
      max-width: 400px;
      margin: 60px auto;
    }
    .empty-state-icon, .error-state-icon {
      font-size: 3rem;
      margin-bottom: 16px;
      opacity: 0.6;
    }
    .empty-state h3, .error-state h3 {
      color: #475569;
      margin-bottom: 8px;
      font-size: 1.25rem;
    }
    .empty-state p, .error-state p {
      color: #64748b;
      margin-bottom: 16px;
      line-height: 1.6;
    }
    .error-state {
      background: #fef2f2;
      border-radius: 12px;
      border: 1px solid #fecaca;
    }
    .error-state h3 { color: #dc2626; }
    .error-state p { color: #b91c1c; }
    /* .btn-retry - Now centralized in Styles.html (C-001) */
    /* .site-footer - Now centralized in FooterComponent.html (D-005) */

    /* Feature 6: Poster Auto-Branding Watermark */
    .poster-watermark {
      text-align: center;
      margin-top: 32px;
      padding: 16px 0;
      border-top: 2px solid #e2e8f0;
    }
    .watermark-text {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      color: #94a3b8;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }
    .watermark-text::before {
      content: "📐";
      font-size: 1.1rem;
    }
    /* Print-friendly watermark */
    @media print {
      .poster-watermark {
        margin-top: 24px;
        padding: 12px 0;
        border-top-width: 1px;
      }
      .watermark-text {
        font-size: 0.75rem;
        color: #64748b;
      }
      .watermark-text::before {
        content: "";
      }
    }
  </style>
</head>
<body>
  <div class="poster-container">
    <!-- Sponsor Strip (Top) -->
    <div id="sponsorStrip" class="sponsor-strip" hidden></div>

    <!-- Event Details - Schema fields: name, startDateISO, venue -->
    <div class="event-details">
      <h1 id="eventName">Event Name</h1>
      <div class="event-meta">
        <div id="eventDate"></div>
        <div id="eventLocation"></div>
      </div>
    </div>
    <!-- V2 REMOVED: eventTime, eventEntity, eventImage, eventSummary - not in schema -->

    <!--
    =========================================================================
    QR CODES SECTION - MVP SCOPE LOCK (3-QR LIMIT)
    =========================================================================
    RULE: Poster renders EXACTLY 3 QR display slots (no more, no less).

    Backend may define unlimited QR flows, but this UI enforces a hard limit.
    DO NOT add a 4th QR slot. See docs/MVP_SCOPE.md for full rules.

    Current slots (priority order):
      1. Sign Up QR    - event.qr.signup (primary CTA)
      2. Event Page QR - event.qr.public
      3. Reserved      - event.qr.display (v2, currently empty)

    If fewer than 3 QRs exist: show placeholder for empty slots
    If more than 3 QRs exist: only render first 3, hide extras

    CSS grid is set to: grid-template-columns: repeat(3, 1fr)
    =========================================================================
    -->
    <section class="qr-section">
      <h2>Scan to Connect</h2>
      <div id="qrGrid" class="qr-grid"></div>
    </section>

    <!-- Feature 6: Auto-Branding Watermark -->
    <div class="poster-watermark">
      <span class="watermark-text">Powered by EventAngle</span>
    </div>
  </div>

  <!-- Trust Footer -->
  <footer class="site-footer">
    <p>Powered by <a href="https://eventangle.com" target="_blank" rel="noopener">EventAngle</a></p>
  </footer>

  <script>
    const BRAND = '<?= brandId ?>';
    const SCOPE = '<?= scope ?>';
    const ID = new URL(location.href).searchParams.get('id');

    // Use shared utilities from SponsorUtils
    const { esc, logEvent, initLogging } = window.SponsorUtils;
    initLogging();

    // === EVENT_CONTRACT.md v2.0 Support ===
    // Use centralized sectionEnabled from SharedUtils (D-008)
    const sectionEnabled = window.SharedUtils?.sectionEnabled || function(settings, key) {
      if (!settings) return false;
      switch (key) {
        case 'schedule': return settings.showSchedule === true;
        case 'standings': return settings.showStandings === true;
        case 'bracket': return settings.showBracket === true;
        case 'sponsors': return settings.showSponsors === true;
        default: return false;
      }
    };

    // NOTE: Legacy renderSponsorStrip* functions removed in E-003
    // All sponsor rendering now uses SponsorUtils.SponsorRenderer

    /**
     * Render event details section
     * SCHEMA: /schemas/event.schema.json
     *
     * Fields used (ALL from schema):
     * - event.name (MVP Required)
     * - event.startDateISO (MVP Required)
     * - event.venue (MVP Required)
     */
    function renderEventDetails(event) {
      // === SCHEMA FIELDS ONLY ===
      const name = event.name || 'Event Name';
      const startDateISO = event.startDateISO || '';
      const venue = event.venue || '';

      // Event Name → #eventName
      document.getElementById('eventName').textContent = name;

      // Date → #eventDate (parsed from startDateISO)
      const dateEl = document.getElementById('eventDate');
      if (startDateISO) {
        const date = new Date(startDateISO + 'T00:00:00');
        if (!isNaN(date.getTime())) {
          dateEl.innerHTML = `<strong>Date:</strong> ${date.toLocaleDateString('en-US', {
            weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
          })}`;
        }
      }

      // Venue → #eventLocation
      const locEl = document.getElementById('eventLocation');
      if (venue) {
        locEl.innerHTML = `<strong>Location:</strong> ${esc(venue)}`;
      }
    }

    /**
     * Render QR codes section
     * SCHEMA: /schemas/event.schema.json
     *
     * =========================================================================
     * MVP SCOPE LOCK: 3-QR DISPLAY SLOT LIMIT
     * =========================================================================
     * This function enforces a HARD LIMIT of 3 QR display slots on the poster.
     * DO NOT add a 4th QR slot. See docs/MVP_SCOPE.md for full rules.
     *
     * Slot allocation (priority order):
     *   Slot 1: Sign Up QR    (event.qr.signup)
     *   Slot 2: Event Page QR (event.qr.public)
     *   Slot 3: Reserved      (event.qr.display - v2)
     *
     * Backend may define unlimited QR flows, but poster ONLY renders 3.
     * =========================================================================
     *
     * Fields used (ALL from schema):
     * - event.qr.public (MVP Required) - Base64 PNG data URI
     * - event.qr.signup (MVP Required) - Base64 PNG data URI
     * - event.links.publicUrl (MVP Required) - URL text below QR
     * - event.links.signupUrl (MVP Required) - URL text below QR
     * - event.ctas.primary.label (MVP Required) - Sign-up button label
     *
     * QR codes MUST come from event.qr.* - no manual generation.
     */
    function renderQRCodes(event) {
      const el = document.getElementById('qrGrid');
      el.innerHTML = '';

      // === SCHEMA FIELDS ===
      const qr = event.qr || {};
      const links = event.links || {};
      const ctas = event.ctas || { primary: { label: 'Sign Up', url: '' } };

      // QR Code 1: Sign Up - MUST use event.qr.signup (no manual generation)
      const signupQR = qr.signup;
      const signupUrl = links.signupUrl || '';
      const signupLabel = ctas.primary?.label || 'Sign Up';

      if (signupQR) {
        // Only render if server-generated QR is present
        el.innerHTML += `
          <div class="qr-code">
            <h3>${esc(signupLabel)}</h3>
            <h4>Register Now</h4>
            <img alt="Sign Up QR Code" src="${signupQR}">
            <p>${esc(signupUrl)}</p>
          </div>
        `;
      }

      // QR Code 2: Public Event Page - MUST use event.qr.public (no manual generation)
      const publicQR = qr.public;
      const publicUrl = links.publicUrl || '';

      if (publicQR) {
        // Only render if server-generated QR is present
        el.innerHTML += `
          <div class="qr-code">
            <h3>Event Page</h3>
            <h4>View Details</h4>
            <img alt="Public Page QR Code" src="${publicQR}">
            <p>${esc(publicUrl)}</p>
          </div>
        `;
      }

      // If no QR codes available
      if (el.innerHTML === '') {
        el.innerHTML = `
          <div style="text-align:center; color:#64748b; grid-column: 1 / -1; padding: 24px;">
            <div style="font-size: 2rem; margin-bottom: 12px; opacity: 0.5;">📱</div>
            <p style="margin: 0 0 8px; font-weight: 600; color: #475569;">No QR Codes Available Yet</p>
            <p style="margin: 0; font-size: 0.9rem; color: #94a3b8;">QR codes will appear here once a sign-up URL has been configured for this event.</p>
          </div>
        `;
      }
    }

    /**
     * Render poster from event data
     * SCHEMA: /schemas/event.schema.json
     *
     * Fields used (ALL from schema):
     * - event.name, event.startDateISO, event.venue (MVP Required)
     * - event.qr.public, event.qr.signup (MVP Required)
     * - event.links.publicUrl, event.links.signupUrl (MVP Required)
     * - event.settings.showSponsors (V2 Optional)
     * - event.settings.showQRSection (default: true) - QR section visibility
     * - event.sponsors[] with placement === 'poster' (V2 Optional)
     */
    function renderPoster(event) {
      if (!event) {
        // S12: Use shared StateRenderer for consistent empty state
        SharedUtils.StateRenderer.showEventNotFound(document.querySelector('.poster-container'));
        return;
      }

      // Log poster view
      logEvent({ eventId: event.id, surface: 'poster', metric: 'view', value: 1 });

      // === SCHEMA FIELDS ===
      const settings = event.settings || { showSponsors: false };
      const sponsors = event.sponsors || [];

      // === SPONSOR STRIP (V2 Optional) ===
      // Schema: event.sponsors[].placement MUST be 'poster' - no fallback
      const sponsorStrip = document.getElementById('sponsorStrip');
      if (settings.showSponsors && sponsors.length > 0) {
        // Use centralized SponsorRenderer with placement filter (E-003 centralization)
        const { SponsorRenderer } = window.SponsorUtils;
        const renderedSponsors = SponsorRenderer.renderStrip({
          container: sponsorStrip,
          sponsors: sponsors,
          placement: 'poster',  // Filter to poster placement only
          eventId: event.id,
          surface: 'poster',
          showLinks: false, // Poster is print-friendly, no clickable links
          showTier: false
        });
        // Hide if no sponsors matched placement filter
        if (!renderedSponsors.length) {
          sponsorStrip.innerHTML = '';
          sponsorStrip.hidden = true;
        }
      } else {
        sponsorStrip.innerHTML = '';
        sponsorStrip.hidden = true;
      }

      // Render event details and QR codes
      renderEventDetails(event);

      // === QR SECTION (MVP Required, gated by showQRSection setting) ===
      // Feature: settings.showQRSection (default: true) gates entire QR section
      const qrSection = document.querySelector('.qr-section');
      if (settings.showQRSection !== false) {
        renderQRCodes(event);
        qrSection.hidden = false;
      } else {
        qrSection.hidden = true;
      }

      // Track print events
      window.addEventListener('beforeprint', () => {
        logEvent({ eventId: event.id, surface: 'poster', metric: 'print', value: 1 });
      });
    }

    /**
     * Boot Poster.html
     * API: api_getPosterBundle → { event, qrCodes, print }
     * SCHEMA: /schemas/event.schema.json
     */
    async function boot() {
      const container = document.querySelector('.poster-container');

      // S12: Check for missing event ID
      if (!ID) {
        SharedUtils.StateRenderer.showEmpty(container, {
          icon: '🔍',
          title: 'No Event Specified',
          message: 'This poster link is missing an event ID. Please check the URL and try again.'
        });
        return;
      }

      // S13: Use safeRpc for graceful error handling
      const res = await NU.safeRpc('api_getPosterBundle', { brandId: BRAND, scope: SCOPE, id: ID });

      // S13: Handle API errors with showFromError (handles SERVICE_UNAVAILABLE, TIMEOUT, etc.)
      if (!res.ok) {
        console.error('Poster API error:', res.code, res.message);
        SharedUtils.StateRenderer.showFromError(container, res, {
          onRetry: () => location.reload()
        });
        return;
      }

      try {
        if (res.value && res.value.event) {
          // getPosterBundle returns { event: Event, qrCodes: {...} }
          renderPoster(res.value.event);
        } else if (res.value) {
          // Backward compat: direct event object
          renderPoster(res.value);
        } else {
          renderPoster(null);
        }
      } catch (renderErr) {
        // S12: Render error - use shared StateRenderer
        console.error('Poster render error:', renderErr);
        SharedUtils.StateRenderer.showError(container, {
          title: 'Display Error',
          message: 'We encountered an issue displaying this poster.',
          onRetry: () => location.reload()
        });
      }
    }

    // Boot on load
    boot();
  </script>
</body>
</html>
