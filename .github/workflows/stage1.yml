# Stage-1 Validation, Staging Deploy & Production Release Workflow
#
# Purpose: Validate code quality, deploy to staging on main push,
#          and deploy to production on tagged releases.
#
# This workflow creates a clean boundary:
#   - PRs validate correctness only (lint, test, contract, guards)
#   - Push to main: validate + deploy to staging
#   - Tag push (vX.Y.Z): validate + deploy to production
#   - Guards eventbook data integrity by preventing accidental deploys
#
# Acceptance Criteria:
#   - PR to main triggers: checkout, npm ci, npm run stage1-local
#   - Push to main triggers: validation + staging deploy
#   - Tag push (vX.Y.Z) triggers: validation + production deploy
#   - Emits artifact stg-base-url containing https://stg.eventangle.com
#   - Emits artifact prod-base-url containing https://www.eventangle.com
#   - Deploy aborts on validation failure
#   - PR cannot merge unless Stage-1 passes (configure as required check)
#   - Tagged releases become the sole path to production
#
# Contract Boundaries:
#   - Uses strict v4.1.2 response contract but does not modify it
#   - Stage-1 validation is HERMETIC: no BASE_URL, no HTTP calls
#   - Prod deploy uses stable API contract only (no dev-only endpoints)
#   - Stage-2 will consume the stg-base-url/prod-base-url artifacts
#
# @see scripts/stage1-local.mjs - Single source of truth for validation steps
# @see scripts/deploy-gas-stg.mjs - Staging deployment script
# @see scripts/deploy-gas-prod.mjs - Production deployment script

name: Stage-1 Validation

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'

# Prevent duplicate runs: cancel in-progress runs for the same PR/branch
# Note: Uses unique group name to avoid conflicts with stage1-deploy.yml
concurrency:
  group: stage1-validation-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Environment configuration
env:
  STAGING_URL: 'https://stg.eventangle.com'
  STAGING_SCRIPT_ID: '1gHiPuj7eXNk09dDyk17SJ6QsCJg7LMqXBRrkowljL3z2TaAKFIvBLhHJ'
  PRODUCTION_URL: 'https://www.eventangle.com'
  PRODUCTION_SCRIPT_ID: '1YO4apLOQoAIh208AcAqWO3pWtx_O3yas_QC4z-pkurgMem9UgYOsp86l'

jobs:
  # ============================================================================
  # STAGE-1 VALIDATION
  # ============================================================================
  # Runs the unified truth script: npm run stage1-local
  #
  # This job is designed to be a REQUIRED STATUS CHECK for PR merges.
  # Configure in GitHub Settings > Branches > Branch protection rules:
  #   - Require status checks to pass before merging
  #   - Select "Stage-1 Validation / validate"
  #
  # Components validated (via scripts/stage1-local.mjs):
  #   - ESLint code quality
  #   - Jest unit tests (MVP logic + security)
  #   - Jest contract tests (schema + API + bundles + GAS HTML guardrails)
  #   - Security-specific test validation
  #   - MVP guards (surfaces, dead code, schema, API checks)
  #   - V2 file guardrails (no V2 files in MVP directory)
  #   - Bundle compilation verification
  #
  # HERMETIC: Stage-1 validation has ZERO external dependencies.
  # No BASE_URL, no HTTP calls, no staging/prod access.
  # ============================================================================
  validate:
    name: Validate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ========================================================================
      # HERMETIC GUARD: Stage-1 must have zero BASE_URL dependency
      # Ensures Stage-1 cannot be broken by staging/prod DNS or CF issues
      # ========================================================================
      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 PR validation!"
            echo ""
            echo "Stage-1 must be hermetic - it cannot depend on external URLs."
            echo "BASE_URL should only be used in Stage-2 (post-deploy validation)."
            echo ""
            echo "Found BASE_URL: $BASE_URL"
            exit 1
          fi
          echo "Hermetic guard passed: no BASE_URL dependency"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run Stage-1 validation
        run: |
          echo "=================================================="
          echo "STAGE-1 PR VALIDATION"
          echo "=================================================="
          echo ""
          echo "Running: npm run stage1-local"
          echo ""
          echo "This is the SINGLE SOURCE OF TRUTH for Stage-1."
          echo "Same script runs locally and in CI - zero drift."
          echo ""
          echo "Components:"
          echo "  - ESLint code quality"
          echo "  - Jest unit tests (MVP logic + security)"
          echo "  - Jest contract tests (schema + API + bundles + GAS HTML guardrails)"
          echo "  - Security-specific test validation"
          echo "  - MVP guards (surfaces, dead code, schema, API)"
          echo "  - V2 file guardrails"
          echo "  - Bundle compilation verification"
          echo ""
          echo "=================================================="
          npm run stage1-local

      - name: Create validation summary
        if: always()
        run: |
          echo "## Stage-1 Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" == "success" ]; then
            echo "### PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              echo "All Stage-1 checks passed. PR is ready for review." >> $GITHUB_STEP_SUMMARY
            else
              echo "All Stage-1 checks passed. Staging deploy will proceed." >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Validated Components:**" >> $GITHUB_STEP_SUMMARY
            echo "- ESLint Code Quality" >> $GITHUB_STEP_SUMMARY
            echo "- Jest Unit Tests (MVP Logic + Security)" >> $GITHUB_STEP_SUMMARY
            echo "- Jest Contract Tests (Schema + API + Bundles)" >> $GITHUB_STEP_SUMMARY
            echo "- Security-Specific Tests" >> $GITHUB_STEP_SUMMARY
            echo "- MVP Guards (Surfaces, Dead Code, Schema, API)" >> $GITHUB_STEP_SUMMARY
            echo "- V2 File Guardrails" >> $GITHUB_STEP_SUMMARY
            echo "- Bundle Compilation Verification" >> $GITHUB_STEP_SUMMARY
          else
            echo "### FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              echo "One or more Stage-1 checks failed. PR cannot be merged." >> $GITHUB_STEP_SUMMARY
            else
              echo "One or more Stage-1 checks failed. **Staging deploy aborted.**" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To reproduce locally:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "npm run stage1-local" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Fix the failing checks and push again." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # STAGING DEPLOY (Push to main only)
  # ============================================================================
  # Deploys to staging environment after validation passes.
  #
  # This job:
  #   - Only runs on push to main (not on PRs)
  #   - Depends on validation passing (aborts if validation fails)
  #   - Deploys to Google Apps Script staging environment
  #   - Deploys Cloudflare Worker with new GAS deployment ID
  #   - Emits stg-base-url artifact for Stage-2 consumption
  #
  # Contract:
  #   - Produces artifact: stg-base-url containing https://stg.eventangle.com
  #   - Stage-2 consumes this artifact for post-deploy E2E testing
  #
  # Required secrets for Cloudflare Worker deployment:
  #   - CLOUDFLARE_API_TOKEN: API token with Worker deployment permissions
  #   - CLOUDFLARE_ACCOUNT_ID: Cloudflare account ID
  # ============================================================================
  staging-deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [validate]
    # Only deploy on push to main, not on PRs
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      base_url: ${{ steps.emit-url.outputs.base_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install clasp
        run: npm install -g @google/clasp@2.4.2

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "Setting up clasp credentials..."

          if [ -z "$CLASPRC_JSON" ]; then
            echo "ERROR: OAUTH_CREDENTIALS secret not set"
            exit 1
          fi

          # Validate JSON structure
          if ! echo "$CLASPRC_JSON" | jq -e '.' > /dev/null 2>&1; then
            echo "ERROR: OAUTH_CREDENTIALS is not valid JSON"
            exit 1
          fi

          # Support both legacy and new clasp credential formats
          HAS_LEGACY=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY" = "false" ] && [ "$HAS_NEW" = "false" ]; then
            echo "ERROR: Missing access_token in OAUTH_CREDENTIALS"
            exit 1
          fi

          # Convert new format to legacy for clasp 2.4.2 compatibility
          if [ "$HAS_NEW" = "true" ]; then
            echo "Converting new clasp format to legacy..."
            CONVERTED_JSON=$(echo "$CLASPRC_JSON" | jq '{token: .tokens.default}')
            echo "$CONVERTED_JSON" > ~/.clasprc.json
          else
            echo "$CLASPRC_JSON" > ~/.clasprc.json
          fi

          chmod 600 ~/.clasprc.json
          echo "Credentials configured"

      - name: Configure staging Script ID
        run: |
          echo "Configuring staging deployment target..."
          echo "Script ID: ${{ env.STAGING_SCRIPT_ID }}"

          # Update .clasp.json with staging Script ID
          jq --arg scriptId "${{ env.STAGING_SCRIPT_ID }}" '.scriptId = $scriptId' .clasp.json > .clasp.json.tmp
          mv .clasp.json.tmp .clasp.json

          echo "Updated .clasp.json:"
          cat .clasp.json

      - name: Push code to staging
        run: |
          echo "Pushing code to staging Apps Script..."

          # Function to clean up old versions when hitting the 200 version limit
          cleanup_old_versions() {
            echo ""
            echo "=============================================="
            echo "VERSION LIMIT REACHED - Cleaning up old versions"
            echo "=============================================="

            SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
            if [ -z "$SCRIPT_ID" ] || [ "$SCRIPT_ID" == "null" ]; then
              echo "ERROR: Could not read scriptId from .clasp.json"
              return 1
            fi

            # Get OAuth token from ~/.clasprc.json
            ACCESS_TOKEN=$(jq -r '.token.access_token // .tokens.default.access_token' ~/.clasprc.json)
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
              echo "ERROR: Could not get access token"
              return 1
            fi

            echo "Script ID: $SCRIPT_ID"
            echo "Fetching all versions..."

            # List all versions
            VERSIONS_RESPONSE=$(curl -s -X GET \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

            # Check for API errors
            if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$VERSIONS_RESPONSE" | jq -r '.error.message')
              echo "API error: $ERROR_MSG"
              return 1
            fi

            VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
            echo "Found $VERSION_COUNT versions"

            # Keep 50 most recent versions, delete the rest
            KEEP_VERSIONS=50
            DELETE_COUNT=$((VERSION_COUNT - KEEP_VERSIONS))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Version count ($VERSION_COUNT) is within limit, no cleanup needed"
              return 1
            fi

            echo "Will delete $DELETE_COUNT old versions, keeping $KEEP_VERSIONS most recent"

            # Get version numbers to delete (oldest first)
            VERSIONS_TO_DELETE=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | .[0:'$DELETE_COUNT'] | .[].versionNumber')

            DELETED=0
            for VERSION_NUM in $VERSIONS_TO_DELETE; do
              echo -n "Deleting version $VERSION_NUM... "

              DELETE_RESPONSE=$(curl -s -X DELETE \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -w "\n%{http_code}" \
                "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions/${VERSION_NUM}")

              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)

              if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "404" ]; then
                echo "OK"
                ((DELETED++))
              else
                echo "FAILED (HTTP $HTTP_CODE)"
              fi

              # Small delay to avoid rate limiting
              sleep 0.2
            done

            echo ""
            echo "Cleanup complete: deleted $DELETED versions"
            echo "=============================================="
            echo ""

            if [ "$DELETED" -gt 0 ]; then
              return 0
            else
              return 1
            fi
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION_CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "Exit code: $PUSH_EXIT_CODE"
            echo "$PUSH_OUTPUT"

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              if ! echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT"; then
                echo "Push successful!"
                exit 0
              fi
            fi

            # Check for 200 version limit error
            if echo "$PUSH_OUTPUT" | grep -qiE "version.*limit|200.*version|too many versions"; then
              if [ "$VERSION_CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 200-version limit error - attempting cleanup..."
                VERSION_CLEANUP_ATTEMPTED=true

                if cleanup_old_versions; then
                  echo "Cleanup successful - retrying push immediately..."
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Version cleanup already attempted"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp push failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy to staging
        id: deploy
        run: |
          echo "Creating staging deployment..."

          # Function to clean up old deployments when hitting the 20-deployment limit
          cleanup_old_deployments() {
            echo ""
            echo "=============================================="
            echo "DEPLOYMENT LIMIT REACHED - Cleaning up old deployments"
            echo "=============================================="

            DEPLOYMENTS=$(clasp deployments 2>&1)
            echo "$DEPLOYMENTS"

            # Extract deployment IDs (AKfycb... format), excluding @HEAD
            DEPLOYMENT_IDS=$(echo "$DEPLOYMENTS" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' || true)

            if [ -z "$DEPLOYMENT_IDS" ]; then
              echo "WARNING: Could not extract deployment IDs for cleanup"
              return 1
            fi

            # Convert to array
            readarray -t DEPLOYMENT_ARRAY <<< "$DEPLOYMENT_IDS"
            TOTAL_COUNT=${#DEPLOYMENT_ARRAY[@]}

            echo "Found $TOTAL_COUNT deployments"

            # Keep the 5 most recent deployments, delete the rest
            KEEP_COUNT=5
            DELETE_COUNT=$((TOTAL_COUNT - KEEP_COUNT))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Not enough deployments to clean up (keeping $KEEP_COUNT)"
              return 1
            fi

            echo "Will remove $DELETE_COUNT old deployments, keeping $KEEP_COUNT most recent"
            echo ""

            # Remove oldest deployments (first in list = oldest)
            REMOVED=0
            for (( i=0; i<DELETE_COUNT; i++ )); do
              DEPLOY_ID="${DEPLOYMENT_ARRAY[$i]}"
              echo -n "Removing deployment $DEPLOY_ID... "

              set +e
              UNDEPLOY_OUTPUT=$(clasp undeploy "$DEPLOY_ID" 2>&1)
              UNDEPLOY_EXIT=$?
              set -e

              if [ $UNDEPLOY_EXIT -eq 0 ]; then
                echo "OK"
                ((REMOVED++))
              else
                echo "FAILED (may already be removed)"
                echo "  $UNDEPLOY_OUTPUT"
              fi

              # Small delay to avoid rate limiting
              sleep 1
            done

            echo ""
            echo "Cleanup complete: removed $REMOVED deployments"
            echo "=============================================="
            echo ""
            return 0
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          DEPLOY_DESCRIPTION="Stage-1 staging deploy $(date -Iseconds)"
          CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            DEPLOY_OUTPUT=$(clasp deploy -d "$DEPLOY_DESCRIPTION" 2>&1)
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "Exit code: $DEPLOY_EXIT_CODE"
            echo "$DEPLOY_OUTPUT"

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              # Extract deployment ID
              DEPLOYMENT_ID=$(echo "$DEPLOY_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)

              if [ -n "$DEPLOYMENT_ID" ]; then
                WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"
                echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "web_app_url=$WEB_APP_URL" >> $GITHUB_OUTPUT
                echo "Deployment successful!"
                echo "Deployment ID: $DEPLOYMENT_ID"
                echo "Web App URL: $WEB_APP_URL"
                exit 0
              fi
            fi

            # Check for deployment limit error
            if echo "$DEPLOY_OUTPUT" | grep -q "20 versioned deployments"; then
              if [ "$CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 20-deployment limit error - attempting cleanup..."
                CLEANUP_ATTEMPTED=true

                if cleanup_old_deployments; then
                  echo "Cleanup successful - retrying deployment immediately..."
                  # Don't count this as a retry attempt, continue loop
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Cleanup already attempted - deployment limit still in effect"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp deploy failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy Cloudflare Worker (staging)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        run: |
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "::warning::Cloudflare secrets not configured - skipping worker update"
            echo "To enable staging URL (stg.eventangle.com), configure:"
            echo "  - CLOUDFLARE_API_TOKEN secret"
            echo "  - CLOUDFLARE_ACCOUNT_ID secret"
            echo ""
            echo "Stage-2 smoke tests will likely fail without Cloudflare Worker deployment."
            exit 0
          fi

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "::error::No deployment ID available from previous step"
            exit 1
          fi

          echo "=============================================="
          echo "DEPLOYING CLOUDFLARE WORKER (STAGING)"
          echo "=============================================="
          echo "Deployment ID: $DEPLOYMENT_ID"
          echo ""

          # Install wrangler
          npm install -g wrangler@3

          # Update staging environment in wrangler.toml with the new deployment ID
          cd cloudflare-proxy

          echo "Updating wrangler.toml with staging deployment ID..."

          # Update STAGING_DEPLOYMENT_ID in the staging section
          sed -i "s|STAGING_DEPLOYMENT_ID = \"[^\"]*\"|STAGING_DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|g" wrangler.toml

          # Update DEPLOYMENT_ID in the staging section (after STAGING_DEPLOYMENT_ID line)
          sed -i "/\[env.staging.vars\]/,/\[env\.[^s]/ s|DEPLOYMENT_ID = \"[^\"]*\"|DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|" wrangler.toml

          # Update GAS_DEPLOYMENT_BASE_URL in staging section
          GAS_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"
          sed -i "s|GAS_DEPLOYMENT_BASE_URL = \"[^\"]*\"|GAS_DEPLOYMENT_BASE_URL = \"${GAS_URL}\"|g" wrangler.toml

          echo "Updated wrangler.toml staging config:"
          grep -A 20 '\[env.staging.vars\]' wrangler.toml | head -10

          # Deploy to staging environment
          echo ""
          echo "Deploying worker to staging..."
          wrangler deploy --env staging

          echo ""
          echo "=============================================="
          echo "CLOUDFLARE WORKER DEPLOYED TO STAGING"
          echo "=============================================="
          echo "Staging URL: ${{ env.STAGING_URL }}"
          echo "GAS URL: $GAS_URL"
          echo "=============================================="

      - name: Emit staging URL artifact
        id: emit-url
        run: |
          # Create the stg-base-url artifact
          mkdir -p artifact
          echo "${{ env.STAGING_URL }}" > artifact/stg-base-url.txt

          echo "=============================================="
          echo "STAGING DEPLOYMENT COMPLETE"
          echo "=============================================="
          echo ""
          echo "Staging URL: ${{ env.STAGING_URL }}"
          echo "Apps Script URL: ${{ steps.deploy.outputs.web_app_url }}"
          echo "Deployment ID: ${{ steps.deploy.outputs.deployment_id }}"
          echo ""
          echo "Artifact stg-base-url created for Stage-2 consumption"
          echo "=============================================="

          echo "base_url=${{ env.STAGING_URL }}" >> $GITHUB_OUTPUT

      - name: Upload stg-base-url artifact
        uses: actions/upload-artifact@v4
        with:
          name: stg-base-url
          path: artifact/stg-base-url.txt
          retention-days: 1

      - name: Create deployment summary
        if: always()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "## Stage-1 Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine Cloudflare Worker status
          if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ -n "$CLOUDFLARE_ACCOUNT_ID" ]; then
            CF_STATUS="Deployed"
          else
            CF_STATUS="Skipped (secrets not configured)"
          fi

          if [ "${{ job.status }}" == "success" ]; then
            echo "### DEPLOYED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Staging deployment completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **Staging URL** | \`${{ env.STAGING_URL }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Apps Script URL** | \`${{ steps.deploy.outputs.web_app_url }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Deployment ID** | \`${{ steps.deploy.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Cloudflare Worker** | $CF_STATUS |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifact:** \`stg-base-url\` created for Stage-2 consumption" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$CF_STATUS" = "Skipped (secrets not configured)" ]; then
              echo "### ⚠️ Warning: Cloudflare Worker Not Deployed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Stage-2 smoke tests will likely fail because the Cloudflare Worker for" >> $GITHUB_STEP_SUMMARY
              echo "\`stg.eventangle.com\` was not updated with the new deployment ID." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "To fix this, configure the following secrets in GitHub:" >> $GITHUB_STEP_SUMMARY
              echo "- \`CLOUDFLARE_API_TOKEN\`: API token with Worker deployment permissions" >> $GITHUB_STEP_SUMMARY
              echo "- \`CLOUDFLARE_ACCOUNT_ID\`: Your Cloudflare account ID" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Stage-2 will consume the \`stg-base-url\` artifact and run:" >> $GITHUB_STEP_SUMMARY
            echo "- API smoke tests against staging" >> $GITHUB_STEP_SUMMARY
            echo "- UI smoke tests against staging" >> $GITHUB_STEP_SUMMARY
          else
            echo "### FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Staging deployment failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** Stage-2 will NOT run because staging deploy failed." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # PRODUCTION DEPLOY (Tag push only - vX.Y.Z)
  # ============================================================================
  # Deploys to production environment after validation passes.
  #
  # This job:
  #   - Only runs on tag push matching v*.*.* pattern
  #   - Depends on validation passing (aborts if validation fails)
  #   - Deploys to Google Apps Script production environment
  #   - Runs minimal production smoke tests (read-only health checks)
  #   - Runs QR verification test (critical invariant)
  #   - Emits prod-base-url artifact for downstream consumption
  #
  # Contract:
  #   - Tagged releases become the sole path to production
  #   - Prod deploy uses stable API contract only (no dev-only endpoints)
  #   - Produces artifact: prod-base-url containing https://www.eventangle.com
  # ============================================================================
  production-deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate]
    # Only deploy on tag push matching vX.Y.Z pattern
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    outputs:
      base_url: ${{ steps.emit-url.outputs.base_url }}
      tag_version: ${{ steps.extract-version.outputs.version }}

    steps:
      - name: Extract version from tag
        id: extract-version
        run: |
          TAG_REF="${{ github.ref }}"
          VERSION="${TAG_REF#refs/tags/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install clasp
        run: npm install -g @google/clasp@2.4.2

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "Setting up clasp credentials for PRODUCTION..."

          if [ -z "$CLASPRC_JSON" ]; then
            echo "ERROR: OAUTH_CREDENTIALS secret not set"
            exit 1
          fi

          # Validate JSON structure
          if ! echo "$CLASPRC_JSON" | jq -e '.' > /dev/null 2>&1; then
            echo "ERROR: OAUTH_CREDENTIALS is not valid JSON"
            exit 1
          fi

          # Support both legacy and new clasp credential formats
          HAS_LEGACY=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY" = "false" ] && [ "$HAS_NEW" = "false" ]; then
            echo "ERROR: Missing access_token in OAUTH_CREDENTIALS"
            exit 1
          fi

          # Convert new format to legacy for clasp 2.4.2 compatibility
          if [ "$HAS_NEW" = "true" ]; then
            echo "Converting new clasp format to legacy..."
            CONVERTED_JSON=$(echo "$CLASPRC_JSON" | jq '{token: .tokens.default}')
            echo "$CONVERTED_JSON" > ~/.clasprc.json
          else
            echo "$CLASPRC_JSON" > ~/.clasprc.json
          fi

          chmod 600 ~/.clasprc.json
          echo "Credentials configured for PRODUCTION deployment"

      - name: Configure production Script ID
        run: |
          echo "=============================================="
          echo "PRODUCTION DEPLOYMENT"
          echo "=============================================="
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Script ID: ${{ env.PRODUCTION_SCRIPT_ID }}"
          echo "=============================================="

          # Update .clasp.json with production Script ID
          jq --arg scriptId "${{ env.PRODUCTION_SCRIPT_ID }}" '.scriptId = $scriptId' .clasp.json > .clasp.json.tmp
          mv .clasp.json.tmp .clasp.json

          echo "Updated .clasp.json:"
          cat .clasp.json

      - name: Push code to production
        run: |
          echo "Pushing code to production Apps Script..."

          # Function to clean up old versions when hitting the 200 version limit
          cleanup_old_versions() {
            echo ""
            echo "=============================================="
            echo "VERSION LIMIT REACHED - Cleaning up old versions"
            echo "=============================================="

            SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
            if [ -z "$SCRIPT_ID" ] || [ "$SCRIPT_ID" == "null" ]; then
              echo "ERROR: Could not read scriptId from .clasp.json"
              return 1
            fi

            # Get OAuth token from ~/.clasprc.json
            ACCESS_TOKEN=$(jq -r '.token.access_token // .tokens.default.access_token' ~/.clasprc.json)
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
              echo "ERROR: Could not get access token"
              return 1
            fi

            echo "Script ID: $SCRIPT_ID"
            echo "Fetching all versions..."

            # List all versions
            VERSIONS_RESPONSE=$(curl -s -X GET \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

            # Check for API errors
            if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$VERSIONS_RESPONSE" | jq -r '.error.message')
              echo "API error: $ERROR_MSG"
              return 1
            fi

            VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
            echo "Found $VERSION_COUNT versions"

            # Keep 50 most recent versions, delete the rest
            KEEP_VERSIONS=50
            DELETE_COUNT=$((VERSION_COUNT - KEEP_VERSIONS))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Version count ($VERSION_COUNT) is within limit, no cleanup needed"
              return 1
            fi

            echo "Will delete $DELETE_COUNT old versions, keeping $KEEP_VERSIONS most recent"

            # Get version numbers to delete (oldest first)
            VERSIONS_TO_DELETE=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | .[0:'$DELETE_COUNT'] | .[].versionNumber')

            DELETED=0
            for VERSION_NUM in $VERSIONS_TO_DELETE; do
              echo -n "Deleting version $VERSION_NUM... "

              DELETE_RESPONSE=$(curl -s -X DELETE \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -w "\n%{http_code}" \
                "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions/${VERSION_NUM}")

              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)

              if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "404" ]; then
                echo "OK"
                ((DELETED++))
              else
                echo "FAILED (HTTP $HTTP_CODE)"
              fi

              # Small delay to avoid rate limiting
              sleep 0.2
            done

            echo ""
            echo "Cleanup complete: deleted $DELETED versions"
            echo "=============================================="
            echo ""

            if [ "$DELETED" -gt 0 ]; then
              return 0
            else
              return 1
            fi
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION_CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "Exit code: $PUSH_EXIT_CODE"
            echo "$PUSH_OUTPUT"

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              if ! echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT"; then
                echo "Push successful!"
                exit 0
              fi
            fi

            # Check for 200 version limit error
            if echo "$PUSH_OUTPUT" | grep -qiE "version.*limit|200.*version|too many versions"; then
              if [ "$VERSION_CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 200-version limit error - attempting cleanup..."
                VERSION_CLEANUP_ATTEMPTED=true

                if cleanup_old_versions; then
                  echo "Cleanup successful - retrying push immediately..."
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Version cleanup already attempted"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp push failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy to production
        id: deploy
        run: |
          echo "Creating production deployment..."

          # Function to clean up old deployments when hitting the 20-deployment limit
          cleanup_old_deployments() {
            echo ""
            echo "=============================================="
            echo "DEPLOYMENT LIMIT REACHED - Cleaning up old deployments"
            echo "=============================================="

            DEPLOYMENTS=$(clasp deployments 2>&1)
            echo "$DEPLOYMENTS"

            # Extract deployment IDs (AKfycb... format), excluding @HEAD
            DEPLOYMENT_IDS=$(echo "$DEPLOYMENTS" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' || true)

            if [ -z "$DEPLOYMENT_IDS" ]; then
              echo "WARNING: Could not extract deployment IDs for cleanup"
              return 1
            fi

            # Convert to array
            readarray -t DEPLOYMENT_ARRAY <<< "$DEPLOYMENT_IDS"
            TOTAL_COUNT=${#DEPLOYMENT_ARRAY[@]}

            echo "Found $TOTAL_COUNT deployments"

            # Keep the 5 most recent deployments, delete the rest
            KEEP_COUNT=5
            DELETE_COUNT=$((TOTAL_COUNT - KEEP_COUNT))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Not enough deployments to clean up (keeping $KEEP_COUNT)"
              return 1
            fi

            echo "Will remove $DELETE_COUNT old deployments, keeping $KEEP_COUNT most recent"
            echo ""

            # Remove oldest deployments (first in list = oldest)
            REMOVED=0
            for (( i=0; i<DELETE_COUNT; i++ )); do
              DEPLOY_ID="${DEPLOYMENT_ARRAY[$i]}"
              echo -n "Removing deployment $DEPLOY_ID... "

              set +e
              UNDEPLOY_OUTPUT=$(clasp undeploy "$DEPLOY_ID" 2>&1)
              UNDEPLOY_EXIT=$?
              set -e

              if [ $UNDEPLOY_EXIT -eq 0 ]; then
                echo "OK"
                ((REMOVED++))
              else
                echo "FAILED (may already be removed)"
                echo "  $UNDEPLOY_OUTPUT"
              fi

              # Small delay to avoid rate limiting
              sleep 1
            done

            echo ""
            echo "Cleanup complete: removed $REMOVED deployments"
            echo "=============================================="
            echo ""
            return 0
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION="${{ steps.extract-version.outputs.version }}"
          DEPLOY_DESCRIPTION="Production release ${VERSION} $(date -Iseconds)"
          CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            DEPLOY_OUTPUT=$(clasp deploy -d "$DEPLOY_DESCRIPTION" 2>&1)
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "Exit code: $DEPLOY_EXIT_CODE"
            echo "$DEPLOY_OUTPUT"

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              # Extract deployment ID
              DEPLOYMENT_ID=$(echo "$DEPLOY_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)

              if [ -n "$DEPLOYMENT_ID" ]; then
                WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"
                echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "web_app_url=$WEB_APP_URL" >> $GITHUB_OUTPUT
                echo "Deployment successful!"
                echo "Deployment ID: $DEPLOYMENT_ID"
                echo "Web App URL: $WEB_APP_URL"
                exit 0
              fi
            fi

            # Check for deployment limit error
            if echo "$DEPLOY_OUTPUT" | grep -q "20 versioned deployments"; then
              if [ "$CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 20-deployment limit error - attempting cleanup..."
                CLEANUP_ATTEMPTED=true

                if cleanup_old_deployments; then
                  echo "Cleanup successful - retrying deployment immediately..."
                  # Don't count this as a retry attempt, continue loop
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Cleanup already attempted - deployment limit still in effect"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp deploy failed after $MAX_RETRIES attempts"
          exit 1

      # ========================================================================
      # PRODUCTION SMOKE TESTS (Minimal, Read-Only)
      # ========================================================================
      # These are the MINIMAL tests required before declaring production ready:
      # 1. Status API health check
      # 2. QR verification test (critical invariant)
      # ========================================================================
      - name: Install Playwright browsers
        run: npx playwright install chromium --with-deps

      - name: Run production smoke tests (minimal)
        id: smoke-tests
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "PRODUCTION SMOKE TESTS (Minimal)"
          echo "=============================================="
          echo "Target: ${{ env.PRODUCTION_URL }}"
          echo ""
          echo "Running minimal read-only health checks..."
          echo "=============================================="

          # Run minimal production smoke tests
          npx playwright test tests/smoke/prod.smoke.test.js --project=chromium --reporter=list

      - name: Run QR verification test (critical invariant)
        id: qr-verify
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "QR VERIFICATION TEST (Critical Invariant)"
          echo "=============================================="
          echo "Verifying QR code generation on Poster surface..."
          echo "=============================================="

          # Run Poster smoke test which includes QR verification
          npx playwright test tests/e2e/1-smoke/Poster.spec.js --project=chromium --reporter=list

      - name: Emit production URL artifact
        id: emit-url
        run: |
          # Create the prod-base-url artifact
          mkdir -p artifact
          echo "${{ env.PRODUCTION_URL }}" > artifact/prod-base-url.txt

          echo "=============================================="
          echo "PRODUCTION DEPLOYMENT COMPLETE"
          echo "=============================================="
          echo ""
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Production URL: ${{ env.PRODUCTION_URL }}"
          echo "Apps Script URL: ${{ steps.deploy.outputs.web_app_url }}"
          echo "Deployment ID: ${{ steps.deploy.outputs.deployment_id }}"
          echo ""
          echo "Artifact prod-base-url created for downstream consumption"
          echo "=============================================="

          echo "base_url=${{ env.PRODUCTION_URL }}" >> $GITHUB_OUTPUT

      - name: Upload prod-base-url artifact
        uses: actions/upload-artifact@v4
        with:
          name: prod-base-url
          path: artifact/prod-base-url.txt
          retention-days: 7

      - name: Create deployment summary
        if: always()
        run: |
          echo "## Stage-1 Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ job.status }}" == "success" ]; then
            echo "### DEPLOYED TO PRODUCTION" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Production deployment completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **Version** | \`${{ steps.extract-version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Production URL** | \`${{ env.PRODUCTION_URL }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Apps Script URL** | \`${{ steps.deploy.outputs.web_app_url }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Deployment ID** | \`${{ steps.deploy.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Smoke Tests Passed:**" >> $GITHUB_STEP_SUMMARY
            echo "- Production health check (status API)" >> $GITHUB_STEP_SUMMARY
            echo "- QR verification (critical invariant)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifact:** \`prod-base-url\` created for downstream consumption" >> $GITHUB_STEP_SUMMARY
          else
            echo "### PRODUCTION DEPLOYMENT FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Production deployment failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Possible causes:**" >> $GITHUB_STEP_SUMMARY
            echo "- Stage-1 validation failed" >> $GITHUB_STEP_SUMMARY
            echo "- clasp push/deploy error" >> $GITHUB_STEP_SUMMARY
            echo "- Production smoke tests failed" >> $GITHUB_STEP_SUMMARY
            echo "- QR verification test failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action:** Do NOT retry. Investigate and fix the issue first." >> $GITHUB_STEP_SUMMARY
          fi
