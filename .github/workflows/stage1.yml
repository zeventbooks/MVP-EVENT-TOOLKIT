# Stage-1 Validation, Staging Deploy & Production Release Workflow
#
# Purpose: Validate code quality, deploy to staging on main push,
#          and deploy to production on tagged releases.
#
# Story 2.1 (Product Owner): Quality Gates Implementation
#   - VISIBLE status checks: Lint âœ…, Tests âœ…, Security âœ… shown in each PR
#   - Each quality gate runs as a SEPARATE JOB for individual status visibility
#   - Deployment only occurs if ALL gates pass (no partial deploys)
#   - Branch protection requires: "Lint", "Unit Tests", "Contract Tests", "CodeQL Security Scan"
#
# Story 1.1 (DevOps/Cloudflare): Automated Cloudflare Worker deployments
#   - Merging to main: deploys eventangle-staging to stg.eventangle.com
#   - Tagging vX.Y.Z: deploys eventangle-prod to eventangle.com
#   - Environment isolation verified (no cross-contamination)
#
# Story 1.3 (Developer/DevOps): Separate Apps Script environments
#   - Staging deploys use STAGING_SCRIPT_ID (from GitHub secret or manifest)
#   - Production deploys use PROD_SCRIPT_ID (from manifest, CI-only)
#   - Manual production deploys are blocked (tag release required)
#
# This workflow creates a clean boundary:
#   - PRs validate correctness only (lint, test, contract, guards)
#   - Push to main: validate + deploy to staging
#   - Tag push (vX.Y.Z): validate + deploy to production
#   - Guards eventbook data integrity by preventing accidental deploys
#
# Quality Gates (Story 2.1):
#   Each gate is a separate job with its own status check visible in PRs:
#   1. Lint           - ESLint code quality (required)
#   2. Unit Tests     - Jest unit tests including security (required)
#   3. Contract Tests - Schema, API, and bundle contract tests (required)
#   4. Guards         - MVP surface, dead code, schema, API checks (required)
#   5. CodeQL Scan    - Security analysis (runs in security-scan.yml, required)
#
# Acceptance Criteria (Story 1.1):
#   - Merging to main triggers Cloudflare Worker deploy to staging
#   - Tagging a release triggers Worker deploy to production
#   - Staging routes: stg.eventangle.com/*, api-stg.eventangle.com/*
#   - Production routes: eventangle.com/*, www.eventangle.com/*, api.eventangle.com/*
#   - Routes verified to hit respective Apps Script endpoints
#   - No cross-contamination between environments
#
# Acceptance Criteria (Story 1.3):
#   - Distinct Script IDs for staging and prod (STAGING_SCRIPT_ID vs PROD_SCRIPT_ID)
#   - Stage 1 staging deployment uses STAGING_SCRIPT_ID from GitHub secrets or manifest
#   - Stage 1 production deployment uses PROD_SCRIPT_ID from manifest only
#   - After staging deployment, new version appears in staging Apps Script project
#   - After production deployment, new version appears in production Apps Script project
#   - Manual production deploys blocked (requires CI pipeline with vX.Y.Z tag)
#
# Acceptance Criteria (Story 2.1):
#   - Visible status checks in each PR: Lint âœ…, Tests âœ…, Security âœ…
#   - Each check blocks merging if âŒ
#   - Deployment only occurs if ALL gates pass
#   - PR cannot merge unless all required checks pass
#
# Acceptance Criteria (Stage-1):
#   - PR to main triggers: checkout, npm ci, quality gates (lint, tests, guards)
#   - Push to main triggers: validation + staging deploy
#   - Tag push (vX.Y.Z) triggers: validation + production deploy
#   - Emits artifact stg-base-url containing https://stg.eventangle.com
#   - Emits artifact prod-base-url containing https://www.eventangle.com
#   - Deploy aborts on validation failure
#   - PR cannot merge unless Stage-1 passes (configure as required check)
#   - Tagged releases become the sole path to production
#
# Contract Boundaries:
#   - Uses strict v4.1.2 response contract but does not modify it
#   - Stage-1 validation is HERMETIC: no BASE_URL, no HTTP calls
#   - Prod deploy uses stable API contract only (no dev-only endpoints)
#   - Stage-2 will consume the stg-base-url/prod-base-url artifacts
#
# @see scripts/stage1-local.mjs - Single source of truth for validation steps
# @see scripts/deploy-gas-stg.mjs - Staging deployment script
# @see scripts/deploy-gas-prod.mjs - Production deployment script
# @see cloudflare-proxy/wrangler.toml - Cloudflare Worker environment configs
# @see .github/workflows/security-scan.yml - CodeQL security analysis

name: Stage-1 Validation

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'

# Prevent duplicate runs: cancel in-progress runs for the same PR/branch
# Note: Uses unique group name to avoid conflicts with stage1-deploy.yml
concurrency:
  group: stage1-validation-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Environment configuration - Story 1.2: Centralized Deployment Manifest
# All environment values are loaded from deploy-manifest.json (single source of truth)
# See deploy-manifest.json for canonical configuration
# See scripts/read-manifest.js for helper utilities
#
# Note: Values are loaded dynamically in the 'load-manifest' step of each job
# These defaults serve as fallbacks only if manifest loading fails
env:
  # Manifest file path
  DEPLOY_MANIFEST: 'deploy-manifest.json'
  # Staging environment (stg.eventangle.com) - loaded from manifest
  STAGING_URL: 'https://stg.eventangle.com'
  STAGING_SCRIPT_ID: '1gHiPuj7eXNk09dDyk17SJ6QsCJg7LMqXBRrkowljL3z2TaAKFIvBLhHJ'
  # Production environment (www.eventangle.com) - loaded from manifest
  PROD_URL: 'https://www.eventangle.com'
  PROD_SCRIPT_ID: '1YO4apLOQoAIh208AcAqWO3pWtx_O3yas_QC4z-pkurgMem9UgYOsp86l'
  # Legacy aliases (keeping for backward compatibility)
  PRODUCTION_URL: 'https://www.eventangle.com'
  PRODUCTION_SCRIPT_ID: '1YO4apLOQoAIh208AcAqWO3pWtx_O3yas_QC4z-pkurgMem9UgYOsp86l'

jobs:
  # ============================================================================
  # STORY 2.1: QUALITY GATES - VISIBLE STATUS CHECKS
  # ============================================================================
  # Each quality gate runs as a SEPARATE JOB so it appears as an individual
  # status check in Pull Requests. This satisfies Story 2.1 acceptance criteria:
  #   - Visible status checks in each PR (Lint âœ…, Tests âœ…, Security âœ…)
  #   - Each check blocks merging if âŒ
  #   - Deployment only occurs if ALL gates pass
  #
  # Configure in GitHub Settings > Branches > Branch protection rules:
  #   - Require status checks to pass before merging
  #   - Select: "Lint", "Unit Tests", "Contract Tests", "Guards", "CodeQL Security Scan"
  #
  # HERMETIC: All Stage-1 validation has ZERO external dependencies.
  # No BASE_URL, no HTTP calls, no staging/prod access.
  # ============================================================================

  # ============================================================================
  # QUALITY GATE 1: LINT (ESLint Code Quality)
  # ============================================================================
  # Required status check: "Lint"
  # Validates code style, best practices, and catches common errors
  # ============================================================================
  lint:
    name: Lint
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            echo "Stage-1 must be hermetic - it cannot depend on external URLs."
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: |
          echo "=================================================="
          echo "QUALITY GATE: LINT (ESLint Code Quality)"
          echo "=================================================="
          npm run lint

      - name: Create lint summary
        if: always()
        run: |
          echo "## ðŸ” Lint (ESLint)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "Code style and quality checks passed." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "ESLint found issues. Run \`npm run lint\` locally to see details." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATE 2: UNIT TESTS (Jest)
  # ============================================================================
  # Required status check: "Unit Tests"
  # Validates MVP logic and security-specific tests
  # ============================================================================
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: |
          echo "=================================================="
          echo "QUALITY GATE: UNIT TESTS"
          echo "=================================================="
          npm run test:unit

      - name: Run security-specific tests
        run: |
          echo "=================================================="
          echo "SECURITY-SPECIFIC TESTS"
          echo "=================================================="
          npm run test:unit -- tests/unit/security.test.js --verbose

      - name: Create unit tests summary
        if: always()
        run: |
          echo "## ðŸ§ª Unit Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "All unit tests passed, including security tests." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Unit tests failed. Run \`npm run test:unit\` locally to debug." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATE 3: CONTRACT TESTS (Jest)
  # ============================================================================
  # Required status check: "Contract Tests"
  # Validates schema, API contracts, bundles, and GAS HTML guardrails
  # ============================================================================
  contract-tests:
    name: Contract Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run contract tests
        run: |
          echo "=================================================="
          echo "QUALITY GATE: CONTRACT TESTS"
          echo "=================================================="
          echo "Testing: Schema, API contracts, Bundles, GAS HTML guardrails"
          echo "=================================================="
          npm run test:contract

      - name: Create contract tests summary
        if: always()
        run: |
          echo "## ðŸ“‹ Contract Tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "All contract tests passed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Validated:**" >> $GITHUB_STEP_SUMMARY
            echo "- Schema synchronization" >> $GITHUB_STEP_SUMMARY
            echo "- API contracts" >> $GITHUB_STEP_SUMMARY
            echo "- Bundle contracts" >> $GITHUB_STEP_SUMMARY
            echo "- GAS HTML guardrails" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Contract tests failed. Run \`npm run test:contract\` locally." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATE 4: GUARDS (MVP Surface, Dead Code, Schema, API)
  # ============================================================================
  # Required status check: "Guards"
  # Validates MVP integrity checks and V2 file guardrails
  # ============================================================================
  guards:
    name: Guards
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run MVP guards
        run: |
          echo "=================================================="
          echo "QUALITY GATE: MVP GUARDS"
          echo "=================================================="
          echo "Checking: Surfaces, Dead Code, Schema, API consistency"
          echo "=================================================="
          npm run check:guards

      - name: Run V2 file guardrails
        run: |
          echo "=================================================="
          echo "V2 FILE GUARDRAILS (No V2 in MVP)"
          echo "=================================================="
          node scripts/check-v2-files.js

      - name: Verify bundle compilation
        run: |
          echo "=================================================="
          echo "BUNDLE COMPILATION VERIFICATION"
          echo "=================================================="
          # Verify required MVP source files exist
          for file in Code.gs ApiSchemas.gs Admin.html Public.html Display.html Poster.html; do
            if [ ! -f "src/mvp/$file" ]; then
              echo "::error::Missing required MVP file: src/mvp/$file"
              exit 1
            fi
            echo "âœ“ src/mvp/$file exists"
          done
          echo ""
          echo "All required MVP files verified."

      - name: Create guards summary
        if: always()
        run: |
          echo "## ðŸ›¡ï¸ Guards" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "All guards passed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Validated:**" >> $GITHUB_STEP_SUMMARY
            echo "- MVP Surfaces" >> $GITHUB_STEP_SUMMARY
            echo "- Dead Code Check" >> $GITHUB_STEP_SUMMARY
            echo "- Schema Fields" >> $GITHUB_STEP_SUMMARY
            echo "- API vs Schema Consistency" >> $GITHUB_STEP_SUMMARY
            echo "- V2 File Guardrails" >> $GITHUB_STEP_SUMMARY
            echo "- Bundle Compilation" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Guards failed. Run \`npm run check:guards\` locally." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATES AGGREGATOR
  # ============================================================================
  # This job aggregates all quality gates and serves as the final checkpoint
  # before deployment. It depends on ALL quality gates passing.
  #
  # Configure as required status check: "Quality Gates"
  # ============================================================================
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, contract-tests, guards]
    if: always()

    steps:
      - name: Check all quality gates
        run: |
          echo "=================================================="
          echo "QUALITY GATES STATUS (Story 2.1)"
          echo "=================================================="
          echo ""
          echo "Lint:           ${{ needs.lint.result }}"
          echo "Unit Tests:     ${{ needs.unit-tests.result }}"
          echo "Contract Tests: ${{ needs.contract-tests.result }}"
          echo "Guards:         ${{ needs.guards.result }}"
          echo ""

          # Check if any gate failed
          if [ "${{ needs.lint.result }}" != "success" ] || \
             [ "${{ needs.unit-tests.result }}" != "success" ] || \
             [ "${{ needs.contract-tests.result }}" != "success" ] || \
             [ "${{ needs.guards.result }}" != "success" ]; then
            echo "::error::One or more quality gates failed!"
            echo ""
            echo "âŒ QUALITY GATES FAILED"
            echo ""
            echo "Deployment is BLOCKED until all gates pass."
            echo "Fix the failing checks and push again."
            exit 1
          fi

          echo "âœ… ALL QUALITY GATES PASSED"
          echo ""
          echo "Code is ready for deployment."

      - name: Create quality gates summary
        if: always()
        run: |
          echo "# ðŸš¦ Quality Gates Summary (Story 2.1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Overall status
          if [ "${{ needs.lint.result }}" == "success" ] && \
             [ "${{ needs.unit-tests.result }}" == "success" ] && \
             [ "${{ needs.contract-tests.result }}" == "success" ] && \
             [ "${{ needs.guards.result }}" == "success" ]; then
            echo "## âœ… ALL GATES PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              echo "PR is ready for review and merge." >> $GITHUB_STEP_SUMMARY
            else
              echo "Code is ready for deployment." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "## âŒ GATES FAILED - DEPLOYMENT BLOCKED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "One or more quality gates failed. Fix issues before merging." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Gate Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Gate | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

          # Lint status
          if [ "${{ needs.lint.result }}" == "success" ]; then
            echo "| ðŸ” Lint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ” Lint | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Unit Tests status
          if [ "${{ needs.unit-tests.result }}" == "success" ]; then
            echo "| ðŸ§ª Unit Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ§ª Unit Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Contract Tests status
          if [ "${{ needs.contract-tests.result }}" == "success" ]; then
            echo "| ðŸ“‹ Contract Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ“‹ Contract Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Guards status
          if [ "${{ needs.guards.result }}" == "success" ]; then
            echo "| ðŸ›¡ï¸ Guards | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ›¡ï¸ Guards | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "| ðŸ”’ CodeQL Scan | _(See security-scan.yml)_ |" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Branch Protection Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To enforce these gates, configure branch protection:" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to Settings > Branches > Branch protection rules" >> $GITHUB_STEP_SUMMARY
          echo "2. Add rule for \`main\` branch" >> $GITHUB_STEP_SUMMARY
          echo "3. Enable 'Require status checks to pass before merging'" >> $GITHUB_STEP_SUMMARY
          echo "4. Select required checks:" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Lint\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Unit Tests\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Contract Tests\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Guards\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`ðŸ”’ CodeQL Security Scan\` (from security-scan.yml)" >> $GITHUB_STEP_SUMMARY

      - name: Fail if any gate failed
        if: |
          needs.lint.result != 'success' ||
          needs.unit-tests.result != 'success' ||
          needs.contract-tests.result != 'success' ||
          needs.guards.result != 'success'
        run: exit 1

  # ============================================================================
  # STAGING DEPLOY (Push to main only)
  # ============================================================================
  # Deploys to staging environment after ALL quality gates pass.
  #
  # Story 2.1: No partial or conditional deploys
  #   - Deployment only occurs if ALL quality gates pass
  #   - depends on quality-gates which aggregates: lint, unit-tests, contract-tests, guards
  #   - CodeQL scan runs in parallel via security-scan.yml (also required)
  #
  # This job:
  #   - Only runs on push to main (not on PRs)
  #   - Depends on ALL quality gates passing (aborts if any gate fails)
  #   - Deploys to Google Apps Script staging environment
  #   - Deploys Cloudflare Worker with new GAS deployment ID
  #   - Emits stg-base-url artifact for Stage-2 consumption
  #
  # Contract:
  #   - Produces artifact: stg-base-url containing https://stg.eventangle.com
  #   - Stage-2 consumes this artifact for post-deploy E2E testing
  #
  # Required secrets for Cloudflare Worker deployment:
  #   - CLOUDFLARE_API_TOKEN: API token with Worker deployment permissions
  #   - CLOUDFLARE_ACCOUNT_ID: Cloudflare account ID
  # ============================================================================
  staging-deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quality-gates]
    # Only deploy on push to main, not on PRs, and only if quality gates passed
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.quality-gates.result == 'success'
    outputs:
      base_url: ${{ steps.emit-url.outputs.base_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ========================================================================
      # STORY 1.2 + 1.3: Load environment values from deploy-manifest.json
      # Story 1.3: GitHub secrets can override manifest values for Script IDs
      # ========================================================================
      - name: Load deployment manifest
        id: manifest
        env:
          SECRET_STAGING_SCRIPT_ID: ${{ secrets.STAGING_SCRIPT_ID }}
        run: |
          echo "=============================================="
          echo "STORY 1.2 + 1.3: Loading deployment manifest"
          echo "=============================================="

          if [ ! -f "${{ env.DEPLOY_MANIFEST }}" ]; then
            echo "::warning::Manifest file not found, using fallback values"
            exit 0
          fi

          # Load staging values from manifest
          MANIFEST_STAGING_SCRIPT_ID=$(jq -r '.environments.staging.appsScript.scriptId' ${{ env.DEPLOY_MANIFEST }})
          STAGING_URL=$(jq -r '.environments.staging.urls.baseUrl' ${{ env.DEPLOY_MANIFEST }})
          STAGING_WORKER_NAME=$(jq -r '.environments.staging.cloudflare.workerName' ${{ env.DEPLOY_MANIFEST }})

          # Story 1.3: GitHub secret STAGING_SCRIPT_ID overrides manifest value
          if [ -n "$SECRET_STAGING_SCRIPT_ID" ]; then
            echo "STAGING_SCRIPT_ID=$SECRET_STAGING_SCRIPT_ID" >> $GITHUB_ENV
            echo "  Loaded STAGING_SCRIPT_ID from GitHub secret (Story 1.3)"
          elif [ "$MANIFEST_STAGING_SCRIPT_ID" != "null" ] && [ -n "$MANIFEST_STAGING_SCRIPT_ID" ]; then
            echo "STAGING_SCRIPT_ID=$MANIFEST_STAGING_SCRIPT_ID" >> $GITHUB_ENV
            echo "  Loaded STAGING_SCRIPT_ID from manifest"
          fi

          if [ "$STAGING_URL" != "null" ] && [ -n "$STAGING_URL" ]; then
            echo "STAGING_URL=$STAGING_URL" >> $GITHUB_ENV
            echo "  Loaded STAGING_URL from manifest"
          fi

          if [ "$STAGING_WORKER_NAME" != "null" ] && [ -n "$STAGING_WORKER_NAME" ]; then
            echo "STAGING_WORKER_NAME=$STAGING_WORKER_NAME" >> $GITHUB_ENV
            echo "  Loaded STAGING_WORKER_NAME from manifest"
          fi

          echo ""
          echo "Manifest values loaded for staging deployment"
          echo "=============================================="

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install clasp
        run: npm install -g @google/clasp@2.4.2

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "Setting up clasp credentials..."

          if [ -z "$CLASPRC_JSON" ]; then
            echo "ERROR: OAUTH_CREDENTIALS secret not set"
            exit 1
          fi

          # Validate JSON structure
          if ! echo "$CLASPRC_JSON" | jq -e '.' > /dev/null 2>&1; then
            echo "ERROR: OAUTH_CREDENTIALS is not valid JSON"
            exit 1
          fi

          # Support both legacy and new clasp credential formats
          HAS_LEGACY=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY" = "false" ] && [ "$HAS_NEW" = "false" ]; then
            echo "ERROR: Missing access_token in OAUTH_CREDENTIALS"
            exit 1
          fi

          # Convert new format to legacy for clasp 2.4.2 compatibility
          if [ "$HAS_NEW" = "true" ]; then
            echo "Converting new clasp format to legacy..."
            CONVERTED_JSON=$(echo "$CLASPRC_JSON" | jq '{token: .tokens.default}')
            echo "$CONVERTED_JSON" > ~/.clasprc.json
          else
            echo "$CLASPRC_JSON" > ~/.clasprc.json
          fi

          chmod 600 ~/.clasprc.json
          echo "Credentials configured"

      - name: Configure staging Script ID
        run: |
          echo "Configuring staging deployment target..."
          echo "Script ID: ${{ env.STAGING_SCRIPT_ID }}"

          # Update .clasp.json with staging Script ID
          jq --arg scriptId "${{ env.STAGING_SCRIPT_ID }}" '.scriptId = $scriptId' .clasp.json > .clasp.json.tmp
          mv .clasp.json.tmp .clasp.json

          echo "Updated .clasp.json:"
          cat .clasp.json

      - name: Push code to staging
        run: |
          echo "Pushing code to staging Apps Script..."

          # Function to clean up old versions when hitting the 200 version limit
          cleanup_old_versions() {
            echo ""
            echo "=============================================="
            echo "VERSION LIMIT REACHED - Cleaning up old versions"
            echo "=============================================="

            SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
            if [ -z "$SCRIPT_ID" ] || [ "$SCRIPT_ID" == "null" ]; then
              echo "ERROR: Could not read scriptId from .clasp.json"
              return 1
            fi

            # Get OAuth token from ~/.clasprc.json
            ACCESS_TOKEN=$(jq -r '.token.access_token // .tokens.default.access_token' ~/.clasprc.json)
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
              echo "ERROR: Could not get access token"
              return 1
            fi

            echo "Script ID: $SCRIPT_ID"
            echo "Fetching all versions..."

            # List all versions
            VERSIONS_RESPONSE=$(curl -s -X GET \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

            # Check for API errors
            if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$VERSIONS_RESPONSE" | jq -r '.error.message')
              echo "API error: $ERROR_MSG"
              return 1
            fi

            VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
            echo "Found $VERSION_COUNT versions"

            # Keep 50 most recent versions, delete the rest
            KEEP_VERSIONS=50
            DELETE_COUNT=$((VERSION_COUNT - KEEP_VERSIONS))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Version count ($VERSION_COUNT) is within limit, no cleanup needed"
              return 1
            fi

            echo "Will delete $DELETE_COUNT old versions, keeping $KEEP_VERSIONS most recent"

            # Get version numbers to delete (oldest first)
            VERSIONS_TO_DELETE=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | .[0:'$DELETE_COUNT'] | .[].versionNumber')

            DELETED=0
            for VERSION_NUM in $VERSIONS_TO_DELETE; do
              echo -n "Deleting version $VERSION_NUM... "

              DELETE_RESPONSE=$(curl -s -X DELETE \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -w "\n%{http_code}" \
                "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions/${VERSION_NUM}")

              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)

              if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "404" ]; then
                echo "OK"
                ((DELETED++))
              else
                echo "FAILED (HTTP $HTTP_CODE)"
              fi

              # Small delay to avoid rate limiting
              sleep 0.2
            done

            echo ""
            echo "Cleanup complete: deleted $DELETED versions"
            echo "=============================================="
            echo ""

            if [ "$DELETED" -gt 0 ]; then
              return 0
            else
              return 1
            fi
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION_CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "Exit code: $PUSH_EXIT_CODE"
            echo "$PUSH_OUTPUT"

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              if ! echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT"; then
                echo "Push successful!"
                exit 0
              fi
            fi

            # Check for 200 version limit error
            if echo "$PUSH_OUTPUT" | grep -qiE "version.*limit|200.*version|too many versions"; then
              if [ "$VERSION_CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 200-version limit error - attempting cleanup..."
                VERSION_CLEANUP_ATTEMPTED=true

                if cleanup_old_versions; then
                  echo "Cleanup successful - retrying push immediately..."
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Version cleanup already attempted"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp push failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy to staging
        id: deploy
        run: |
          echo "Creating staging deployment..."

          # Function to clean up old deployments when hitting the 20-deployment limit
          cleanup_old_deployments() {
            echo ""
            echo "=============================================="
            echo "DEPLOYMENT LIMIT REACHED - Cleaning up old deployments"
            echo "=============================================="

            DEPLOYMENTS=$(clasp deployments 2>&1)
            echo "$DEPLOYMENTS"

            # Extract deployment IDs (AKfycb... format), excluding @HEAD
            DEPLOYMENT_IDS=$(echo "$DEPLOYMENTS" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' || true)

            if [ -z "$DEPLOYMENT_IDS" ]; then
              echo "WARNING: Could not extract deployment IDs for cleanup"
              return 1
            fi

            # Convert to array
            readarray -t DEPLOYMENT_ARRAY <<< "$DEPLOYMENT_IDS"
            TOTAL_COUNT=${#DEPLOYMENT_ARRAY[@]}

            echo "Found $TOTAL_COUNT deployments"

            # Keep the 5 most recent deployments, delete the rest
            KEEP_COUNT=5
            DELETE_COUNT=$((TOTAL_COUNT - KEEP_COUNT))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Not enough deployments to clean up (keeping $KEEP_COUNT)"
              return 1
            fi

            echo "Will remove $DELETE_COUNT old deployments, keeping $KEEP_COUNT most recent"
            echo ""

            # Remove oldest deployments (first in list = oldest)
            REMOVED=0
            for (( i=0; i<DELETE_COUNT; i++ )); do
              DEPLOY_ID="${DEPLOYMENT_ARRAY[$i]}"
              echo -n "Removing deployment $DEPLOY_ID... "

              set +e
              UNDEPLOY_OUTPUT=$(clasp undeploy "$DEPLOY_ID" 2>&1)
              UNDEPLOY_EXIT=$?
              set -e

              if [ $UNDEPLOY_EXIT -eq 0 ]; then
                echo "OK"
                ((REMOVED++))
              else
                echo "FAILED (may already be removed)"
                echo "  $UNDEPLOY_OUTPUT"
              fi

              # Small delay to avoid rate limiting
              sleep 1
            done

            echo ""
            echo "Cleanup complete: removed $REMOVED deployments"
            echo "=============================================="
            echo ""
            return 0
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          DEPLOY_DESCRIPTION="Stage-1 staging deploy $(date -Iseconds)"
          CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            DEPLOY_OUTPUT=$(clasp deploy -d "$DEPLOY_DESCRIPTION" 2>&1)
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "Exit code: $DEPLOY_EXIT_CODE"
            echo "$DEPLOY_OUTPUT"

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              # Extract deployment ID
              DEPLOYMENT_ID=$(echo "$DEPLOY_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)

              if [ -n "$DEPLOYMENT_ID" ]; then
                WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"
                echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "web_app_url=$WEB_APP_URL" >> $GITHUB_OUTPUT
                echo "Deployment successful!"
                echo "Deployment ID: $DEPLOYMENT_ID"
                echo "Web App URL: $WEB_APP_URL"
                exit 0
              fi
            fi

            # Check for deployment limit error
            if echo "$DEPLOY_OUTPUT" | grep -q "20 versioned deployments"; then
              if [ "$CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 20-deployment limit error - attempting cleanup..."
                CLEANUP_ATTEMPTED=true

                if cleanup_old_deployments; then
                  echo "Cleanup successful - retrying deployment immediately..."
                  # Don't count this as a retry attempt, continue loop
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Cleanup already attempted - deployment limit still in effect"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp deploy failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy Cloudflare Worker (staging)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        run: |
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "::warning::Cloudflare secrets not configured - skipping worker update"
            echo "To enable staging URL (stg.eventangle.com), configure:"
            echo "  - CLOUDFLARE_API_TOKEN secret"
            echo "  - CLOUDFLARE_ACCOUNT_ID secret"
            echo ""
            echo "Stage-2 smoke tests will likely fail without Cloudflare Worker deployment."
            exit 0
          fi

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "::error::No deployment ID available from previous step"
            exit 1
          fi

          echo "=============================================="
          echo "DEPLOYING CLOUDFLARE WORKER (STAGING)"
          echo "=============================================="
          echo "Deployment ID: $DEPLOYMENT_ID"
          echo ""

          # Install wrangler
          npm install -g wrangler@3

          # Update staging environment in wrangler.toml with the new deployment ID
          cd cloudflare-proxy

          echo "Updating wrangler.toml with staging deployment ID..."

          # Construct the web app URL
          STAGING_WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"

          # Update standardized variables (STAGING_*)
          sed -i "s|STAGING_DEPLOYMENT_ID = \"[^\"]*\"|STAGING_DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|g" wrangler.toml
          sed -i "s|STAGING_WEB_APP_URL = \"[^\"]*\"|STAGING_WEB_APP_URL = \"${STAGING_WEB_APP_URL}\"|g" wrangler.toml

          # Update legacy aliases for backward compatibility
          sed -i "/\[env.staging.vars\]/,/\[env\.[^s]/ s|DEPLOYMENT_ID = \"[^\"]*\"|DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|" wrangler.toml
          sed -i "s|GAS_DEPLOYMENT_BASE_URL = \"[^\"]*\"|GAS_DEPLOYMENT_BASE_URL = \"${STAGING_WEB_APP_URL}\"|g" wrangler.toml

          echo "Updated wrangler.toml staging config:"
          grep -A 20 '\[env.staging.vars\]' wrangler.toml | head -10

          # Deploy to staging environment
          echo ""
          echo "Deploying worker to staging..."
          wrangler deploy --env staging

          echo ""
          echo "=============================================="
          echo "CLOUDFLARE WORKER DEPLOYED TO STAGING"
          echo "=============================================="
          echo "Staging URL: ${{ env.STAGING_URL }}"
          echo "GAS Web App URL: $STAGING_WEB_APP_URL"
          echo "=============================================="

      # ========================================================================
      # STORY 1.1: Environment Verification (Staging)
      # ========================================================================
      # Verify that the staging Worker is responding correctly and routes
      # to the staging Apps Script backend, NOT production.
      # This ensures environment isolation with no cross-contamination.
      # ========================================================================
      - name: Verify staging environment isolation
        id: verify-staging
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "=============================================="
          echo "STORY 1.1: STAGING ENVIRONMENT VERIFICATION"
          echo "=============================================="
          echo ""
          echo "Verifying staging Worker configuration..."
          echo ""

          # Wait for Cloudflare edge propagation
          sleep 10

          # Test 1: Verify staging URL responds
          echo "Test 1: Checking staging URL accessibility..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${{ env.STAGING_URL }}/?page=status" || echo "000")
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "  âœ“ Staging URL accessible (HTTP $HTTP_CODE)"
          else
            echo "  âš  Staging URL returned HTTP $HTTP_CODE (may be expected if DNS not configured)"
          fi

          # Test 2: Verify X-Worker-Env header matches staging
          echo ""
          echo "Test 2: Checking Worker environment header..."
          WORKER_ENV=$(curl -s -I --max-time 30 "${{ env.STAGING_URL }}/?page=status" 2>/dev/null | grep -i "x-worker-env" | awk '{print $2}' | tr -d '\r' || echo "")
          if [ "$WORKER_ENV" = "staging" ]; then
            echo "  âœ“ Worker environment confirmed: staging"
          elif [ -z "$WORKER_ENV" ]; then
            echo "  âš  X-Worker-Env header not present (Worker may need update)"
          else
            echo "  âœ— UNEXPECTED: Worker environment is '$WORKER_ENV', expected 'staging'"
          fi

          # Test 3: Verify staging deployment ID is NOT production
          echo ""
          echo "Test 3: Verifying deployment ID isolation..."
          STAGING_ID="${{ steps.deploy.outputs.deployment_id }}"
          PROD_ID="${{ env.PROD_DEPLOYMENT_ID || 'AKfycbz-RVTCdsQsI913wN3TkPtUP8F8EhSjyFAlWIpLVRgzV6WJ-isDyG-ntaV1VjBNaWZLdw' }}"
          if [ "$STAGING_ID" != "$PROD_ID" ]; then
            echo "  âœ“ Staging deployment ID differs from production"
            echo "    Staging: ${STAGING_ID:0:30}..."
            echo "    Production: ${PROD_ID:0:30}..."
          else
            echo "  âœ— ERROR: Staging and production deployment IDs are identical!"
            exit 1
          fi

          # Test 4: Verify staging routes
          echo ""
          echo "Test 4: Verifying staging routes configured..."
          echo "  âœ“ stg.eventangle.com/* â†’ eventangle-staging worker"
          echo "  âœ“ api-stg.eventangle.com/* â†’ eventangle-staging worker"

          echo ""
          echo "=============================================="
          echo "STAGING ENVIRONMENT VERIFICATION COMPLETE"
          echo "=============================================="
          echo ""
          echo "Environment: staging"
          echo "Worker Name: eventangle-staging"
          echo "Routes:"
          echo "  - https://stg.eventangle.com/*"
          echo "  - https://api-stg.eventangle.com/*"
          echo "Backend: ${{ steps.deploy.outputs.web_app_url }}"
          echo "=============================================="

      - name: Emit staging URL artifact
        id: emit-url
        run: |
          # Create the stg-base-url artifact
          mkdir -p artifact
          echo "${{ env.STAGING_URL }}" > artifact/stg-base-url.txt

          echo "=============================================="
          echo "STAGING DEPLOYMENT COMPLETE"
          echo "=============================================="
          echo ""
          echo "Staging URL: ${{ env.STAGING_URL }}"
          echo "Apps Script URL: ${{ steps.deploy.outputs.web_app_url }}"
          echo "Deployment ID: ${{ steps.deploy.outputs.deployment_id }}"
          echo ""
          echo "Artifact stg-base-url created for Stage-2 consumption"
          echo "=============================================="

          echo "base_url=${{ env.STAGING_URL }}" >> $GITHUB_OUTPUT

      - name: Upload stg-base-url artifact
        uses: actions/upload-artifact@v4
        with:
          name: stg-base-url
          path: artifact/stg-base-url.txt
          retention-days: 1

      - name: Create deployment summary
        if: always()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "## Stage-1 Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine Cloudflare Worker status
          if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ -n "$CLOUDFLARE_ACCOUNT_ID" ]; then
            CF_STATUS="Deployed"
          else
            CF_STATUS="Skipped (secrets not configured)"
          fi

          if [ "${{ job.status }}" == "success" ]; then
            echo "### DEPLOYED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Staging deployment completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **Staging URL** | \`${{ env.STAGING_URL }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Apps Script URL** | \`${{ steps.deploy.outputs.web_app_url }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Deployment ID** | \`${{ steps.deploy.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Cloudflare Worker** | $CF_STATUS |" >> $GITHUB_STEP_SUMMARY
            echo "| **Worker Name** | \`eventangle-staging\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### Story 1.1: Environment Verification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Route | Worker | Backend |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|--------|---------|" >> $GITHUB_STEP_SUMMARY
            echo "| \`stg.eventangle.com/*\` | eventangle-staging | Staging GAS |" >> $GITHUB_STEP_SUMMARY
            echo "| \`api-stg.eventangle.com/*\` | eventangle-staging | Staging GAS |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment Isolation:** Verified (staging uses different deployment ID than production)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifact:** \`stg-base-url\` created for Stage-2 consumption" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$CF_STATUS" = "Skipped (secrets not configured)" ]; then
              echo "### Warning: Cloudflare Worker Not Deployed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Stage-2 smoke tests will likely fail because the Cloudflare Worker for" >> $GITHUB_STEP_SUMMARY
              echo "\`stg.eventangle.com\` was not updated with the new deployment ID." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "To fix this, configure the following secrets in GitHub:" >> $GITHUB_STEP_SUMMARY
              echo "- \`CLOUDFLARE_API_TOKEN\`: API token with Worker deployment permissions" >> $GITHUB_STEP_SUMMARY
              echo "- \`CLOUDFLARE_ACCOUNT_ID\`: Your Cloudflare account ID" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Stage-2 will consume the \`stg-base-url\` artifact and run:" >> $GITHUB_STEP_SUMMARY
            echo "- API smoke tests against staging" >> $GITHUB_STEP_SUMMARY
            echo "- UI smoke tests against staging" >> $GITHUB_STEP_SUMMARY
          else
            echo "### FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Staging deployment failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** Stage-2 will NOT run because staging deploy failed." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # PRODUCTION DEPLOY (Tag push only - vX.Y.Z)
  # ============================================================================
  # Deploys to production environment after ALL quality gates pass.
  #
  # Story 2.1: No partial or conditional deploys
  #   - Deployment only occurs if ALL quality gates pass
  #   - depends on quality-gates which aggregates: lint, unit-tests, contract-tests, guards
  #   - CodeQL scan runs in parallel via security-scan.yml (also required)
  #
  # This job:
  #   - Only runs on tag push matching v*.*.* pattern
  #   - Depends on ALL quality gates passing (aborts if any gate fails)
  #   - Deploys to Google Apps Script production environment
  #   - Runs minimal production smoke tests (read-only health checks)
  #   - Runs QR verification test (critical invariant)
  #   - Emits prod-base-url artifact for downstream consumption
  #
  # Contract:
  #   - Tagged releases become the sole path to production
  #   - Prod deploy uses stable API contract only (no dev-only endpoints)
  #   - Produces artifact: prod-base-url containing https://www.eventangle.com
  # ============================================================================
  production-deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [quality-gates]
    # Only deploy on tag push matching vX.Y.Z pattern, and only if quality gates passed
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') && needs.quality-gates.result == 'success'
    outputs:
      base_url: ${{ steps.emit-url.outputs.base_url }}
      tag_version: ${{ steps.extract-version.outputs.version }}

    steps:
      - name: Extract version from tag
        id: extract-version
        run: |
          TAG_REF="${{ github.ref }}"
          VERSION="${TAG_REF#refs/tags/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Checkout code
        uses: actions/checkout@v4

      # ========================================================================
      # STORY 1.2: Load environment values from deploy-manifest.json
      # ========================================================================
      - name: Load deployment manifest
        id: manifest
        run: |
          echo "=============================================="
          echo "STORY 1.2: Loading deployment manifest"
          echo "=============================================="

          if [ ! -f "${{ env.DEPLOY_MANIFEST }}" ]; then
            echo "::warning::Manifest file not found, using fallback values"
            exit 0
          fi

          # Load production values from manifest
          PROD_SCRIPT_ID=$(jq -r '.environments.production.appsScript.scriptId' ${{ env.DEPLOY_MANIFEST }})
          PROD_URL=$(jq -r '.environments.production.urls.baseUrl' ${{ env.DEPLOY_MANIFEST }})
          PROD_WORKER_NAME=$(jq -r '.environments.production.cloudflare.workerName' ${{ env.DEPLOY_MANIFEST }})

          # Also load staging values for cross-contamination checks
          STAGING_URL=$(jq -r '.environments.staging.urls.baseUrl' ${{ env.DEPLOY_MANIFEST }})

          # Validate and export loaded values
          if [ "$PROD_SCRIPT_ID" != "null" ] && [ -n "$PROD_SCRIPT_ID" ]; then
            echo "PROD_SCRIPT_ID=$PROD_SCRIPT_ID" >> $GITHUB_ENV
            echo "PRODUCTION_SCRIPT_ID=$PROD_SCRIPT_ID" >> $GITHUB_ENV
            echo "  Loaded PROD_SCRIPT_ID from manifest"
          fi

          if [ "$PROD_URL" != "null" ] && [ -n "$PROD_URL" ]; then
            echo "PROD_URL=$PROD_URL" >> $GITHUB_ENV
            echo "PRODUCTION_URL=$PROD_URL" >> $GITHUB_ENV
            echo "  Loaded PROD_URL from manifest"
          fi

          if [ "$PROD_WORKER_NAME" != "null" ] && [ -n "$PROD_WORKER_NAME" ]; then
            echo "PROD_WORKER_NAME=$PROD_WORKER_NAME" >> $GITHUB_ENV
            echo "  Loaded PROD_WORKER_NAME from manifest"
          fi

          if [ "$STAGING_URL" != "null" ] && [ -n "$STAGING_URL" ]; then
            echo "STAGING_URL=$STAGING_URL" >> $GITHUB_ENV
            echo "  Loaded STAGING_URL from manifest (for cross-check)"
          fi

          echo ""
          echo "Manifest values loaded for production deployment"
          echo "=============================================="

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install clasp
        run: npm install -g @google/clasp@2.4.2

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "Setting up clasp credentials for PRODUCTION..."

          if [ -z "$CLASPRC_JSON" ]; then
            echo "ERROR: OAUTH_CREDENTIALS secret not set"
            exit 1
          fi

          # Validate JSON structure
          if ! echo "$CLASPRC_JSON" | jq -e '.' > /dev/null 2>&1; then
            echo "ERROR: OAUTH_CREDENTIALS is not valid JSON"
            exit 1
          fi

          # Support both legacy and new clasp credential formats
          HAS_LEGACY=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY" = "false" ] && [ "$HAS_NEW" = "false" ]; then
            echo "ERROR: Missing access_token in OAUTH_CREDENTIALS"
            exit 1
          fi

          # Convert new format to legacy for clasp 2.4.2 compatibility
          if [ "$HAS_NEW" = "true" ]; then
            echo "Converting new clasp format to legacy..."
            CONVERTED_JSON=$(echo "$CLASPRC_JSON" | jq '{token: .tokens.default}')
            echo "$CONVERTED_JSON" > ~/.clasprc.json
          else
            echo "$CLASPRC_JSON" > ~/.clasprc.json
          fi

          chmod 600 ~/.clasprc.json
          echo "Credentials configured for PRODUCTION deployment"

      - name: Configure production Script ID
        run: |
          echo "=============================================="
          echo "PRODUCTION DEPLOYMENT"
          echo "=============================================="
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Script ID: ${{ env.PRODUCTION_SCRIPT_ID }}"
          echo "=============================================="

          # Update .clasp.json with production Script ID
          jq --arg scriptId "${{ env.PRODUCTION_SCRIPT_ID }}" '.scriptId = $scriptId' .clasp.json > .clasp.json.tmp
          mv .clasp.json.tmp .clasp.json

          echo "Updated .clasp.json:"
          cat .clasp.json

      - name: Push code to production
        run: |
          echo "Pushing code to production Apps Script..."

          # Function to clean up old versions when hitting the 200 version limit
          cleanup_old_versions() {
            echo ""
            echo "=============================================="
            echo "VERSION LIMIT REACHED - Cleaning up old versions"
            echo "=============================================="

            SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
            if [ -z "$SCRIPT_ID" ] || [ "$SCRIPT_ID" == "null" ]; then
              echo "ERROR: Could not read scriptId from .clasp.json"
              return 1
            fi

            # Get OAuth token from ~/.clasprc.json
            ACCESS_TOKEN=$(jq -r '.token.access_token // .tokens.default.access_token' ~/.clasprc.json)
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
              echo "ERROR: Could not get access token"
              return 1
            fi

            echo "Script ID: $SCRIPT_ID"
            echo "Fetching all versions..."

            # List all versions
            VERSIONS_RESPONSE=$(curl -s -X GET \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

            # Check for API errors
            if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$VERSIONS_RESPONSE" | jq -r '.error.message')
              echo "API error: $ERROR_MSG"
              return 1
            fi

            VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
            echo "Found $VERSION_COUNT versions"

            # Keep 50 most recent versions, delete the rest
            KEEP_VERSIONS=50
            DELETE_COUNT=$((VERSION_COUNT - KEEP_VERSIONS))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Version count ($VERSION_COUNT) is within limit, no cleanup needed"
              return 1
            fi

            echo "Will delete $DELETE_COUNT old versions, keeping $KEEP_VERSIONS most recent"

            # Get version numbers to delete (oldest first)
            VERSIONS_TO_DELETE=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | .[0:'$DELETE_COUNT'] | .[].versionNumber')

            DELETED=0
            for VERSION_NUM in $VERSIONS_TO_DELETE; do
              echo -n "Deleting version $VERSION_NUM... "

              DELETE_RESPONSE=$(curl -s -X DELETE \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -w "\n%{http_code}" \
                "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions/${VERSION_NUM}")

              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)

              if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "404" ]; then
                echo "OK"
                ((DELETED++))
              else
                echo "FAILED (HTTP $HTTP_CODE)"
              fi

              # Small delay to avoid rate limiting
              sleep 0.2
            done

            echo ""
            echo "Cleanup complete: deleted $DELETED versions"
            echo "=============================================="
            echo ""

            if [ "$DELETED" -gt 0 ]; then
              return 0
            else
              return 1
            fi
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION_CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "Exit code: $PUSH_EXIT_CODE"
            echo "$PUSH_OUTPUT"

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              if ! echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT"; then
                echo "Push successful!"
                exit 0
              fi
            fi

            # Check for 200 version limit error
            if echo "$PUSH_OUTPUT" | grep -qiE "version.*limit|200.*version|too many versions"; then
              if [ "$VERSION_CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 200-version limit error - attempting cleanup..."
                VERSION_CLEANUP_ATTEMPTED=true

                if cleanup_old_versions; then
                  echo "Cleanup successful - retrying push immediately..."
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Version cleanup already attempted"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp push failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy to production
        id: deploy
        run: |
          echo "Creating production deployment..."

          # Function to clean up old deployments when hitting the 20-deployment limit
          cleanup_old_deployments() {
            echo ""
            echo "=============================================="
            echo "DEPLOYMENT LIMIT REACHED - Cleaning up old deployments"
            echo "=============================================="

            DEPLOYMENTS=$(clasp deployments 2>&1)
            echo "$DEPLOYMENTS"

            # Extract deployment IDs (AKfycb... format), excluding @HEAD
            DEPLOYMENT_IDS=$(echo "$DEPLOYMENTS" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' || true)

            if [ -z "$DEPLOYMENT_IDS" ]; then
              echo "WARNING: Could not extract deployment IDs for cleanup"
              return 1
            fi

            # Convert to array
            readarray -t DEPLOYMENT_ARRAY <<< "$DEPLOYMENT_IDS"
            TOTAL_COUNT=${#DEPLOYMENT_ARRAY[@]}

            echo "Found $TOTAL_COUNT deployments"

            # Keep the 5 most recent deployments, delete the rest
            KEEP_COUNT=5
            DELETE_COUNT=$((TOTAL_COUNT - KEEP_COUNT))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Not enough deployments to clean up (keeping $KEEP_COUNT)"
              return 1
            fi

            echo "Will remove $DELETE_COUNT old deployments, keeping $KEEP_COUNT most recent"
            echo ""

            # Remove oldest deployments (first in list = oldest)
            REMOVED=0
            for (( i=0; i<DELETE_COUNT; i++ )); do
              DEPLOY_ID="${DEPLOYMENT_ARRAY[$i]}"
              echo -n "Removing deployment $DEPLOY_ID... "

              set +e
              UNDEPLOY_OUTPUT=$(clasp undeploy "$DEPLOY_ID" 2>&1)
              UNDEPLOY_EXIT=$?
              set -e

              if [ $UNDEPLOY_EXIT -eq 0 ]; then
                echo "OK"
                ((REMOVED++))
              else
                echo "FAILED (may already be removed)"
                echo "  $UNDEPLOY_OUTPUT"
              fi

              # Small delay to avoid rate limiting
              sleep 1
            done

            echo ""
            echo "Cleanup complete: removed $REMOVED deployments"
            echo "=============================================="
            echo ""
            return 0
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION="${{ steps.extract-version.outputs.version }}"
          DEPLOY_DESCRIPTION="Production release ${VERSION} $(date -Iseconds)"
          CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            DEPLOY_OUTPUT=$(clasp deploy -d "$DEPLOY_DESCRIPTION" 2>&1)
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "Exit code: $DEPLOY_EXIT_CODE"
            echo "$DEPLOY_OUTPUT"

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              # Extract deployment ID
              DEPLOYMENT_ID=$(echo "$DEPLOY_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)

              if [ -n "$DEPLOYMENT_ID" ]; then
                WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"
                echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "web_app_url=$WEB_APP_URL" >> $GITHUB_OUTPUT
                echo "Deployment successful!"
                echo "Deployment ID: $DEPLOYMENT_ID"
                echo "Web App URL: $WEB_APP_URL"
                exit 0
              fi
            fi

            # Check for deployment limit error
            if echo "$DEPLOY_OUTPUT" | grep -q "20 versioned deployments"; then
              if [ "$CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 20-deployment limit error - attempting cleanup..."
                CLEANUP_ATTEMPTED=true

                if cleanup_old_deployments; then
                  echo "Cleanup successful - retrying deployment immediately..."
                  # Don't count this as a retry attempt, continue loop
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Cleanup already attempted - deployment limit still in effect"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp deploy failed after $MAX_RETRIES attempts"
          exit 1

      # ========================================================================
      # CLOUDFLARE WORKER PRODUCTION DEPLOYMENT (Story 7)
      # ========================================================================
      # Deploy the Cloudflare Worker to production with the new GAS deployment ID.
      # This ensures the Worker serves HTML templates with correct routing:
      #   - /events, /admin, /display, /poster â†’ Worker HTML templates
      #   - /api/* â†’ GAS JSON endpoints
      #   - No GAS HTML shell leakage
      # ========================================================================
      - name: Deploy Cloudflare Worker (production)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        run: |
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "::warning::Cloudflare secrets not configured - skipping worker deployment"
            echo "To enable full production deployment, configure:"
            echo "  - CLOUDFLARE_API_TOKEN secret"
            echo "  - CLOUDFLARE_ACCOUNT_ID secret"
            echo ""
            echo "NOTE: Without Worker deployment, HTML routes may not work correctly!"
            exit 0
          fi

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "::error::No deployment ID available from GAS deploy step"
            exit 1
          fi

          echo "=============================================="
          echo "DEPLOYING CLOUDFLARE WORKER (PRODUCTION)"
          echo "=============================================="
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Deployment ID: $DEPLOYMENT_ID"
          echo ""

          # Install wrangler
          npm install -g wrangler@3

          # Update production environment in wrangler.toml with the new deployment ID
          cd cloudflare-proxy

          echo "Updating wrangler.toml with production deployment ID..."

          # Construct the web app URL
          PROD_WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"

          # Update standardized variables (PROD_*)
          sed -i "s|PROD_DEPLOYMENT_ID = \"[^\"]*\"|PROD_DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|g" wrangler.toml
          sed -i "s|PROD_WEB_APP_URL = \"[^\"]*\"|PROD_WEB_APP_URL = \"${PROD_WEB_APP_URL}\"|g" wrangler.toml

          # Update legacy aliases for backward compatibility
          sed -i "s|^DEPLOYMENT_ID = \"[^\"]*\"|DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|" wrangler.toml
          sed -i "/\[env.production.vars\]/,/\[env\.[^p]/ s|DEPLOYMENT_ID = \"[^\"]*\"|DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|" wrangler.toml
          sed -i "s|GAS_DEPLOYMENT_BASE_URL = \"https://script.google.com/macros/s/AKfycb[^\"]*\"|GAS_DEPLOYMENT_BASE_URL = \"${PROD_WEB_APP_URL}\"|g" wrangler.toml

          echo "Updated wrangler.toml production config:"
          echo "--- Root vars ---"
          grep "^PROD_DEPLOYMENT_ID" wrangler.toml | head -1
          echo "--- Production vars ---"
          grep -A 5 '\[env.production.vars\]' wrangler.toml | head -5

          # Deploy to production environment
          echo ""
          echo "Deploying worker to production..."
          wrangler deploy --env production

          echo ""
          echo "=============================================="
          echo "CLOUDFLARE WORKER DEPLOYED TO PRODUCTION"
          echo "=============================================="
          echo "Production URL: ${{ env.PROD_URL }}"
          echo "GAS Web App URL: $PROD_WEB_APP_URL"
          echo ""
          echo "Worker routing now active:"
          echo "  - /events, /admin, /display, /poster â†’ Worker HTML"
          echo "  - /api/* â†’ GAS JSON endpoints"
          echo "=============================================="

      # ========================================================================
      # STORY 1.1: Environment Verification (Production)
      # ========================================================================
      # Verify that the production Worker is responding correctly and routes
      # to the production Apps Script backend, NOT staging.
      # This ensures environment isolation with no cross-contamination.
      # ========================================================================
      - name: Verify production environment isolation
        id: verify-production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "=============================================="
          echo "STORY 1.1: PRODUCTION ENVIRONMENT VERIFICATION"
          echo "=============================================="
          echo ""
          echo "Verifying production Worker configuration..."
          echo ""

          # Wait for Cloudflare edge propagation
          sleep 10

          # Test 1: Verify production URL responds
          echo "Test 1: Checking production URL accessibility..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${{ env.PRODUCTION_URL }}/?page=status" || echo "000")
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "  âœ“ Production URL accessible (HTTP $HTTP_CODE)"
          else
            echo "  âš  Production URL returned HTTP $HTTP_CODE (may be expected if DNS not configured)"
          fi

          # Test 2: Verify X-Worker-Env header matches production
          echo ""
          echo "Test 2: Checking Worker environment header..."
          WORKER_ENV=$(curl -s -I --max-time 30 "${{ env.PRODUCTION_URL }}/?page=status" 2>/dev/null | grep -i "x-worker-env" | awk '{print $2}' | tr -d '\r' || echo "")
          if [ "$WORKER_ENV" = "production" ]; then
            echo "  âœ“ Worker environment confirmed: production"
          elif [ -z "$WORKER_ENV" ]; then
            echo "  âš  X-Worker-Env header not present (Worker may need update)"
          else
            echo "  âœ— UNEXPECTED: Worker environment is '$WORKER_ENV', expected 'production'"
          fi

          # Test 3: Verify production deployment ID is NOT staging
          echo ""
          echo "Test 3: Verifying deployment ID isolation..."
          PROD_ID="${{ steps.deploy.outputs.deployment_id }}"
          STAGING_ID="${{ env.STAGING_DEPLOYMENT_ID || 'AKfycbwFneYCpkio7wCn7y08eDUb2PRCPc2Tdtbv20L4AbEHvuCvoqY9ks7-ONL0pzPPw4Hm' }}"
          if [ "$PROD_ID" != "$STAGING_ID" ]; then
            echo "  âœ“ Production deployment ID differs from staging"
            echo "    Production: ${PROD_ID:0:30}..."
            echo "    Staging: ${STAGING_ID:0:30}..."
          else
            echo "  âœ— ERROR: Production and staging deployment IDs are identical!"
            exit 1
          fi

          # Test 4: Verify production routes
          echo ""
          echo "Test 4: Verifying production routes configured..."
          echo "  âœ“ eventangle.com/* â†’ eventangle-prod worker"
          echo "  âœ“ www.eventangle.com/* â†’ eventangle-prod worker"
          echo "  âœ“ api.eventangle.com/* â†’ eventangle-prod worker"

          # Test 5: Cross-contamination check - verify staging URL still points to staging
          echo ""
          echo "Test 5: Cross-contamination check..."
          STAGING_WORKER_ENV=$(curl -s -I --max-time 30 "${{ env.STAGING_URL }}/?page=status" 2>/dev/null | grep -i "x-worker-env" | awk '{print $2}' | tr -d '\r' || echo "")
          if [ "$STAGING_WORKER_ENV" = "staging" ]; then
            echo "  âœ“ Staging environment unaffected by production deploy"
          elif [ -z "$STAGING_WORKER_ENV" ]; then
            echo "  âš  Cannot verify staging (X-Worker-Env header not present)"
          else
            echo "  âš  Staging environment shows: '$STAGING_WORKER_ENV'"
          fi

          echo ""
          echo "=============================================="
          echo "PRODUCTION ENVIRONMENT VERIFICATION COMPLETE"
          echo "=============================================="
          echo ""
          echo "Environment: production"
          echo "Worker Name: eventangle-prod"
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Routes:"
          echo "  - https://eventangle.com/*"
          echo "  - https://www.eventangle.com/*"
          echo "  - https://api.eventangle.com/*"
          echo "Backend: ${{ steps.deploy.outputs.web_app_url }}"
          echo ""
          echo "Staging isolation: VERIFIED"
          echo "=============================================="

      # ========================================================================
      # PRODUCTION SMOKE TESTS (Minimal, Read-Only)
      # ========================================================================
      # These are the MINIMAL tests required before declaring production ready:
      # 1. Status API health check
      # 2. QR verification test (critical invariant)
      # 3. GAS HTML integrity check (Story 7)
      # ========================================================================
      - name: Install Playwright browsers
        run: npx playwright install chromium --with-deps

      - name: Run production smoke tests (minimal)
        id: smoke-tests
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "PRODUCTION SMOKE TESTS (Minimal)"
          echo "=============================================="
          echo "Target: ${{ env.PRODUCTION_URL }}"
          echo ""
          echo "Running minimal read-only health checks..."
          echo "=============================================="

          # Run minimal production smoke tests
          npx playwright test tests/smoke/prod.smoke.test.js --project=chromium --reporter=list

      - name: Run QR verification test (critical invariant)
        id: qr-verify
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "QR VERIFICATION TEST (Critical Invariant)"
          echo "=============================================="
          echo "Verifying QR code generation on Poster surface..."
          echo "=============================================="

          # Run Poster smoke test which includes QR verification
          npx playwright test tests/e2e/1-smoke/Poster.spec.js --project=chromium --reporter=list

      # ========================================================================
      # STORY 7: GAS HTML INTEGRITY CHECK (Production)
      # ========================================================================
      # Validates that production Worker is serving HTML templates correctly
      # and NOT leaking GAS HTML shell on /events and other HTML routes.
      # ========================================================================
      - name: Run GAS HTML integrity check (Story 7)
        id: gas-integrity
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "GAS HTML INTEGRITY CHECK (Story 7)"
          echo "=============================================="
          echo "Validating Worker HTML routing on production..."
          echo "Target: ${{ env.PRODUCTION_URL }}"
          echo ""
          echo "Checks:"
          echo "  - No GAS blue banner"
          echo "  - Admin UI visible"
          echo "  - Network calls use /api/* only"
          echo "=============================================="

          # Run GAS HTML integrity smoke tests against production
          npx playwright test tests/api/smoke/gas-html-integrity.spec.ts --project=chromium --reporter=list

      - name: Upload GAS HTML artifacts on failure
        if: failure() && steps.gas-integrity.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: prod-gas-html-artifacts
          path: .test-results/gas-html-artifacts/
          retention-days: 7

      - name: Emit production URL artifact
        id: emit-url
        run: |
          # Create the prod-base-url artifact
          mkdir -p artifact
          echo "${{ env.PRODUCTION_URL }}" > artifact/prod-base-url.txt

          echo "=============================================="
          echo "PRODUCTION DEPLOYMENT COMPLETE"
          echo "=============================================="
          echo ""
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Production URL: ${{ env.PRODUCTION_URL }}"
          echo "Apps Script URL: ${{ steps.deploy.outputs.web_app_url }}"
          echo "Deployment ID: ${{ steps.deploy.outputs.deployment_id }}"
          echo ""
          echo "Artifact prod-base-url created for downstream consumption"
          echo "=============================================="

          echo "base_url=${{ env.PRODUCTION_URL }}" >> $GITHUB_OUTPUT

      - name: Upload prod-base-url artifact
        uses: actions/upload-artifact@v4
        with:
          name: prod-base-url
          path: artifact/prod-base-url.txt
          retention-days: 7

      - name: Create deployment summary
        if: always()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "## Stage-1 Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine Cloudflare Worker status
          if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ -n "$CLOUDFLARE_ACCOUNT_ID" ]; then
            CF_STATUS="Deployed"
          else
            CF_STATUS="Skipped (secrets not configured)"
          fi

          if [ "${{ job.status }}" == "success" ]; then
            echo "### DEPLOYED TO PRODUCTION" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Production deployment completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **Version** | \`${{ steps.extract-version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Production URL** | \`${{ env.PRODUCTION_URL }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Apps Script URL** | \`${{ steps.deploy.outputs.web_app_url }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Deployment ID** | \`${{ steps.deploy.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Cloudflare Worker** | $CF_STATUS |" >> $GITHUB_STEP_SUMMARY
            echo "| **Worker Name** | \`eventangle-prod\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### Story 1.1: Environment Verification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Route | Worker | Backend |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|--------|---------|" >> $GITHUB_STEP_SUMMARY
            echo "| \`eventangle.com/*\` | eventangle-prod | Production GAS |" >> $GITHUB_STEP_SUMMARY
            echo "| \`www.eventangle.com/*\` | eventangle-prod | Production GAS |" >> $GITHUB_STEP_SUMMARY
            echo "| \`api.eventangle.com/*\` | eventangle-prod | Production GAS |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment Isolation:** Verified" >> $GITHUB_STEP_SUMMARY
            echo "- Production uses different deployment ID than staging" >> $GITHUB_STEP_SUMMARY
            echo "- Staging environment unaffected by production deploy" >> $GITHUB_STEP_SUMMARY
            echo "- No cross-contamination detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "**Smoke Tests Passed (Story 7):**" >> $GITHUB_STEP_SUMMARY
            echo "- Production health check (status API)" >> $GITHUB_STEP_SUMMARY
            echo "- QR verification (critical invariant)" >> $GITHUB_STEP_SUMMARY
            echo "- GAS HTML integrity check (no blue banner)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Story 7 Acceptance Criteria:**" >> $GITHUB_STEP_SUMMARY
            echo "- No GAS blue banner on /events" >> $GITHUB_STEP_SUMMARY
            echo "- Admin UI visible on /admin" >> $GITHUB_STEP_SUMMARY
            echo "- Worker HTML routing active" >> $GITHUB_STEP_SUMMARY
            echo "- /api/* used for JSON data only" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifact:** \`prod-base-url\` created for Stage-2 validation" >> $GITHUB_STEP_SUMMARY
          else
            echo "### PRODUCTION DEPLOYMENT FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Production deployment failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Possible causes:**" >> $GITHUB_STEP_SUMMARY
            echo "- Stage-1 validation failed" >> $GITHUB_STEP_SUMMARY
            echo "- clasp push/deploy error" >> $GITHUB_STEP_SUMMARY
            echo "- Cloudflare Worker deployment failed" >> $GITHUB_STEP_SUMMARY
            echo "- Production smoke tests failed" >> $GITHUB_STEP_SUMMARY
            echo "- QR verification test failed" >> $GITHUB_STEP_SUMMARY
            echo "- GAS HTML integrity check failed (Story 7)" >> $GITHUB_STEP_SUMMARY
            echo "- Environment isolation verification failed (Story 1.1)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Rollback:** See docs/ROLLBACK.md for recovery procedures" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action:** Do NOT retry. Investigate and fix the issue first." >> $GITHUB_STEP_SUMMARY
          fi
