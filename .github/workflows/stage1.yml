# Stage-1 Validation, Staging Deploy & Production Release Workflow
#
# DEPRECATED FOR PR/PUSH TO MAIN - Use stage1-ci.yml instead
#
# This workflow now ONLY handles PRODUCTION RELEASES (tagged versions).
# For PR validation and staging deployment, see stage1-ci.yml.
#
# Purpose: Deploy to production on tagged releases (vX.Y.Z)
#
# Story 5.2 Update:
#   - PR validation moved to stage1-ci.yml (security-first pipeline)
#   - Staging deployment moved to stage1-ci.yml
#   - This workflow now only handles production releases
#
# Story 1.1 (DevOps/Cloudflare): Automated Cloudflare Worker deployments
#   - Tagging vX.Y.Z: deploys eventangle-prod to eventangle.com
#
# @see stage1-ci.yml - Primary CI pipeline (PR validation + staging deploy)
# @see stage2-smoke.yml - Post-deploy smoke tests

name: Production Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      confirm_production:
        description: 'Type "PRODUCTION" to confirm manual production deploy'
        required: true
        type: string

# Prevent duplicate runs: cancel in-progress runs for the same PR/branch
# Note: Uses unique group name to avoid conflicts with stage1-deploy.yml
concurrency:
  group: stage1-validation-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Environment configuration - Story 1.2: Centralized Deployment Manifest
# All environment values are loaded from deploy-manifest.json (single source of truth)
# See deploy-manifest.json for canonical configuration
# See scripts/read-manifest.js for helper utilities
#
# Story 6 - CI Environment Configuration:
#   STG_BASE_URL: Used by Stage-2 tests against staging
#   PROD_BASE_URL: Used by Stage-2 tests against production
#
# Note: Values are loaded dynamically in the 'load-manifest' step of each job
# These defaults serve as fallbacks only if manifest loading fails
env:
  # Manifest file path
  DEPLOY_MANIFEST: 'deploy-manifest.json'
  # Story 6 CI config - Base URLs for tests
  STG_BASE_URL: 'https://stg.eventangle.com'
  PROD_BASE_URL: 'https://www.eventangle.com'
  # Staging environment (stg.eventangle.com) - loaded from manifest
  STAGING_URL: 'https://stg.eventangle.com'
  STAGING_SCRIPT_ID: '1gHiPuj7eXNk09dDyk17SJ6QsCJg7LMqXBRrkowljL3z2TaAKFIvBLhHJ'
  # Production environment (www.eventangle.com) - loaded from manifest
  PROD_URL: 'https://www.eventangle.com'
  PROD_SCRIPT_ID: '1YO4apLOQoAIh208AcAqWO3pWtx_O3yas_QC4z-pkurgMem9UgYOsp86l'
  # Legacy aliases (keeping for backward compatibility)
  PRODUCTION_URL: 'https://www.eventangle.com'
  PRODUCTION_SCRIPT_ID: '1YO4apLOQoAIh208AcAqWO3pWtx_O3yas_QC4z-pkurgMem9UgYOsp86l'

jobs:
  # ============================================================================
  # STORY 2.1: QUALITY GATES - VISIBLE STATUS CHECKS
  # ============================================================================
  # Each quality gate runs as a SEPARATE JOB so it appears as an individual
  # status check in Pull Requests. This satisfies Story 2.1 acceptance criteria:
  #   - Visible status checks in each PR (Lint âœ…, Tests âœ…, Security âœ…)
  #   - Each check blocks merging if âŒ
  #   - Deployment only occurs if ALL gates pass
  #
  # Configure in GitHub Settings > Branches > Branch protection rules:
  #   - Require status checks to pass before merging
  #   - Select: "Lint", "Unit Tests", "Contract Tests", "Guards", "CodeQL Security Scan"
  #
  # HERMETIC: All Stage-1 validation has ZERO external dependencies.
  # No BASE_URL, no HTTP calls, no staging/prod access.
  # ============================================================================

  # ============================================================================
  # QUALITY GATE 1: LINT (ESLint Code Quality)
  # ============================================================================
  # Required status check: "Lint"
  # Validates code style, best practices, and catches common errors
  # ============================================================================
  lint:
    name: Lint
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            echo "Stage-1 must be hermetic - it cannot depend on external URLs."
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: |
          echo "=================================================="
          echo "QUALITY GATE: LINT (ESLint Code Quality)"
          echo "=================================================="
          npm run lint

      - name: Create lint summary
        if: always()
        run: |
          echo "## ðŸ” Lint (ESLint)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "Code style and quality checks passed." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "ESLint found issues. Run \`npm run lint\` locally to see details." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATE 2: UNIT TESTS (Jest) with Coverage Enforcement
  # ============================================================================
  # Required status check: "Unit Tests"
  # Validates MVP logic and security-specific tests
  #
  # Story 2.3: Coverage Threshold Enforcement
  #   - Runs full unit test suite with coverage collection
  #   - Enforces >= 80% coverage threshold (branches, functions, lines, statements)
  #   - Pipeline fails if coverage drops below threshold
  #   - Coverage reports uploaded as artifacts
  #
  # Story 2.5: Fail-Fast
  #   - DEPENDS ON LINT: If linting fails, unit tests are SKIPPED
  #   - Provides immediate feedback without wasting resources
  # ============================================================================
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: [lint]  # Story 2.5: Fail-fast - unit tests skip if lint fails

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests with coverage (Story 2.3)
        id: unit-tests
        run: |
          echo "=================================================="
          echo "QUALITY GATE: UNIT TESTS WITH COVERAGE"
          echo "Story 2.3: Coverage threshold >= 80%"
          echo "=================================================="
          npm run test:unit -- --coverage --coverageThreshold='{"global":{"branches":80,"functions":80,"lines":80,"statements":80}}'

      - name: Run security-specific tests
        run: |
          echo "=================================================="
          echo "SECURITY-SPECIFIC TESTS"
          echo "=================================================="
          npm run test:unit -- tests/unit/security.test.js --verbose

      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage/
            coverage/lcov-report/
          retention-days: 7

      - name: Create unit tests summary
        if: always()
        run: |
          echo "## ðŸ§ª Unit Tests (Story 2.3)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "All unit tests passed, including security tests." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Coverage Threshold Enforced:** >= 80%" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Metric | Threshold |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-----------|" >> $GITHUB_STEP_SUMMARY
            echo "| Branches | >= 80% |" >> $GITHUB_STEP_SUMMARY
            echo "| Functions | >= 80% |" >> $GITHUB_STEP_SUMMARY
            echo "| Lines | >= 80% |" >> $GITHUB_STEP_SUMMARY
            echo "| Statements | >= 80% |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifact:** \`coverage-report\` available for download" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Unit tests failed or coverage below 80% threshold." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Run \`npm run test:coverage\` locally to see coverage details." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATE 3: CONTRACT TESTS (Jest)
  # ============================================================================
  # Required status check: "Contract Tests"
  # Validates schema, API contracts, bundles, and GAS HTML guardrails
  #
  # Story 2.3: API Contract Enforcement
  #   - Validates response formats match expected schemas
  #   - Verifies required fields and envelope structure
  #   - Any schema mismatch or missing field causes test failure
  #   - Prevents deployment of breaking API changes
  #
  # Story 2.5: Fail-Fast
  #   - DEPENDS ON LINT: If linting fails, contract tests are SKIPPED
  #   - Runs in parallel with unit tests after lint passes
  # ============================================================================
  contract-tests:
    name: Contract Tests
    runs-on: ubuntu-latest
    needs: [lint]  # Story 2.5: Fail-fast - skip if lint fails

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run contract tests (Story 2.3)
        id: contract-tests
        run: |
          echo "=================================================="
          echo "QUALITY GATE: CONTRACT TESTS"
          echo "Story 2.3: API schema/response validation"
          echo "=================================================="
          echo "Testing: Schema, API contracts, Bundles, GAS HTML guardrails"
          echo "Note: tests/contract/* are hermetic (no network)"
          echo "Note: Live API contracts run in Stage-2 after deployment"
          echo "=================================================="
          npm run test:contract -- --verbose

      - name: Run schema synchronization tests
        run: |
          echo "=================================================="
          echo "SCHEMA SYNCHRONIZATION TESTS"
          echo "=================================================="
          npm run test:schemas

      - name: Generate contract test report
        if: always()
        run: |
          mkdir -p .test-results
          echo "{\"timestamp\":\"$(date -Iseconds)\",\"contracts\":\"validated\",\"story\":\"2.3\"}" > .test-results/contract-test-report.json

      - name: Upload contract test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: contract-test-results
          path: .test-results/
          retention-days: 7

      - name: Create contract tests summary
        if: always()
        run: |
          echo "## ðŸ“‹ Contract Tests (Story 2.3)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "All contract tests passed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Story 2.3 Acceptance Criteria Met:**" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… API response formats match expected schemas" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Required fields verified in all endpoints" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Response envelope structure validated" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Schema mismatch detection active" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Validated Contracts:**" >> $GITHUB_STEP_SUMMARY
            echo "- Schema synchronization (EVENT_CONTRACT.md v2.0)" >> $GITHUB_STEP_SUMMARY
            echo "- API response contracts (Ok/Err envelopes)" >> $GITHUB_STEP_SUMMARY
            echo "- Bundle contracts (public, display, poster)" >> $GITHUB_STEP_SUMMARY
            echo "- GAS HTML guardrails (no shell leakage)" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Contract tests failed - API schema violation detected!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Possible Issues:**" >> $GITHUB_STEP_SUMMARY
            echo "- Missing required field in response" >> $GITHUB_STEP_SUMMARY
            echo "- Envelope structure mismatch (ok/code/message)" >> $GITHUB_STEP_SUMMARY
            echo "- Schema field type violation" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Run \`npm run test:contract\` locally to debug." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATE 4: GUARDS (MVP Surface, Dead Code, Schema, API)
  # ============================================================================
  # Required status check: "Guards"
  # Validates MVP integrity checks and V2 file guardrails
  #
  # Story 2.5: Fail-Fast
  #   - DEPENDS ON LINT: If linting fails, guards are SKIPPED
  #   - Runs in parallel with unit tests and contract tests after lint passes
  # ============================================================================
  guards:
    name: Guards
    runs-on: ubuntu-latest
    needs: [lint]  # Story 2.5: Fail-fast - skip if lint fails

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run MVP guards
        run: |
          echo "=================================================="
          echo "QUALITY GATE: MVP GUARDS"
          echo "=================================================="
          echo "Checking: Surfaces, Dead Code, Schema, API consistency"
          echo "=================================================="
          npm run check:guards

      - name: Run V2 file guardrails
        run: |
          echo "=================================================="
          echo "V2 FILE GUARDRAILS (No V2 in MVP)"
          echo "=================================================="
          node scripts/check-v2-files.js

      - name: Verify bundle compilation
        run: |
          echo "=================================================="
          echo "BUNDLE COMPILATION VERIFICATION"
          echo "=================================================="
          # Verify required MVP source files exist
          for file in Code.gs ApiSchemas.gs Admin.html Public.html Display.html Poster.html; do
            if [ ! -f "src/mvp/$file" ]; then
              echo "::error::Missing required MVP file: src/mvp/$file"
              exit 1
            fi
            echo "âœ“ src/mvp/$file exists"
          done
          echo ""
          echo "All required MVP files verified."

      - name: Create guards summary
        if: always()
        run: |
          echo "## ðŸ›¡ï¸ Guards" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "All guards passed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Validated:**" >> $GITHUB_STEP_SUMMARY
            echo "- MVP Surfaces" >> $GITHUB_STEP_SUMMARY
            echo "- Dead Code Check" >> $GITHUB_STEP_SUMMARY
            echo "- Schema Fields" >> $GITHUB_STEP_SUMMARY
            echo "- API vs Schema Consistency" >> $GITHUB_STEP_SUMMARY
            echo "- V2 File Guardrails" >> $GITHUB_STEP_SUMMARY
            echo "- Bundle Compilation" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Guards failed. Run \`npm run check:guards\` locally." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATE 5: BACKEND ROUTER TESTS (Story 0.1)
  # ============================================================================
  # Required status check: "Backend Router Tests"
  # Validates versioned backend routing configuration and parity
  #
  # Story 0.1: Versioned Backend Routing
  #   - Unit tests for router selection logic (BACKEND_MODE, route mapping)
  #   - Contract tests for /api/status response shape parity
  #   - Ensures GAS and Worker backends return compatible responses
  #
  # Story 2.5: Fail-Fast
  #   - DEPENDS ON LINT: If linting fails, router tests are SKIPPED
  # ============================================================================
  backend-router-tests:
    name: Backend Router Tests
    runs-on: ubuntu-latest
    needs: [lint]  # Story 2.5: Fail-fast - skip if lint fails

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify hermetic environment (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "::error::BASE_URL is set in Stage-1 validation!"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run backend router tests (Story 0.1)
        id: backend-router-tests
        run: |
          echo "=================================================="
          echo "QUALITY GATE: BACKEND ROUTER TESTS (Story 0.1)"
          echo "=================================================="
          echo "Testing: Versioned backend routing configuration"
          echo "Testing: Backend selection logic (gas, worker, mixed)"
          echo "Testing: Response shape parity between backends"
          echo "=================================================="
          npm run test:story0.1

      - name: Create backend router tests summary
        if: always()
        run: |
          echo "## ðŸ”€ Backend Router Tests (Story 0.1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "Versioned backend routing tests passed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Story 0.1 Acceptance Criteria Met:**" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… BACKEND_MODE config (gas|worker|mixed)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Per-route backend mapping" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Query param override (?backend=gas|worker)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Backend error handling (BACKEND_ERROR)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Response shape parity for /api/status" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Backend router tests failed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Run \`npm run test:story0.1\` locally to debug." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # QUALITY GATES AGGREGATOR
  # ============================================================================
  # This job aggregates all quality gates and serves as the final checkpoint
  # before deployment. It depends on ALL quality gates passing.
  #
  # Configure as required status check: "Quality Gates"
  # ============================================================================
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, contract-tests, guards, backend-router-tests]
    if: always()

    steps:
      - name: Check all quality gates
        run: |
          echo "=================================================="
          echo "QUALITY GATES STATUS (Story 2.1)"
          echo "=================================================="
          echo ""
          echo "Lint:                ${{ needs.lint.result }}"
          echo "Unit Tests:          ${{ needs.unit-tests.result }}"
          echo "Contract Tests:      ${{ needs.contract-tests.result }}"
          echo "Guards:              ${{ needs.guards.result }}"
          echo "Backend Router:      ${{ needs.backend-router-tests.result }}"
          echo ""

          # Check if any gate failed
          if [ "${{ needs.lint.result }}" != "success" ] || \
             [ "${{ needs.unit-tests.result }}" != "success" ] || \
             [ "${{ needs.contract-tests.result }}" != "success" ] || \
             [ "${{ needs.guards.result }}" != "success" ] || \
             [ "${{ needs.backend-router-tests.result }}" != "success" ]; then
            echo "::error::One or more quality gates failed!"
            echo ""
            echo "âŒ QUALITY GATES FAILED"
            echo ""
            echo "Deployment is BLOCKED until all gates pass."
            echo "Fix the failing checks and push again."
            exit 1
          fi

          echo "âœ… ALL QUALITY GATES PASSED"
          echo ""
          echo "Code is ready for deployment."

      - name: Create quality gates summary
        if: always()
        run: |
          echo "# ðŸš¦ Quality Gates Summary (Story 2.1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Overall status
          if [ "${{ needs.lint.result }}" == "success" ] && \
             [ "${{ needs.unit-tests.result }}" == "success" ] && \
             [ "${{ needs.contract-tests.result }}" == "success" ] && \
             [ "${{ needs.guards.result }}" == "success" ] && \
             [ "${{ needs.backend-router-tests.result }}" == "success" ]; then
            echo "## âœ… ALL GATES PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" == "pull_request" ]; then
              echo "PR is ready for review and merge." >> $GITHUB_STEP_SUMMARY
            else
              echo "Code is ready for deployment." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "## âŒ GATES FAILED - DEPLOYMENT BLOCKED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "One or more quality gates failed. Fix issues before merging." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Gate Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Gate | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

          # Lint status
          if [ "${{ needs.lint.result }}" == "success" ]; then
            echo "| ðŸ” Lint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ” Lint | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Unit Tests status
          if [ "${{ needs.unit-tests.result }}" == "success" ]; then
            echo "| ðŸ§ª Unit Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ§ª Unit Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Contract Tests status
          if [ "${{ needs.contract-tests.result }}" == "success" ]; then
            echo "| ðŸ“‹ Contract Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ“‹ Contract Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Guards status
          if [ "${{ needs.guards.result }}" == "success" ]; then
            echo "| ðŸ›¡ï¸ Guards | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ›¡ï¸ Guards | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Backend Router Tests status (Story 0.1)
          if [ "${{ needs.backend-router-tests.result }}" == "success" ]; then
            echo "| ðŸ”€ Backend Router | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ”€ Backend Router | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "| ðŸ”’ CodeQL Scan | _(See security-scan.yml)_ |" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Branch Protection Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To enforce these gates, configure branch protection:" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to Settings > Branches > Branch protection rules" >> $GITHUB_STEP_SUMMARY
          echo "2. Add rule for \`main\` branch" >> $GITHUB_STEP_SUMMARY
          echo "3. Enable 'Require status checks to pass before merging'" >> $GITHUB_STEP_SUMMARY
          echo "4. Select required checks:" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Lint\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Unit Tests\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Contract Tests\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Guards\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`Backend Router Tests\` (Story 0.1)" >> $GITHUB_STEP_SUMMARY
          echo "   - \`ðŸ”’ CodeQL Security Scan\` (from security-scan.yml)" >> $GITHUB_STEP_SUMMARY

      - name: Fail if any gate failed
        if: |
          needs.lint.result != 'success' ||
          needs.unit-tests.result != 'success' ||
          needs.contract-tests.result != 'success' ||
          needs.guards.result != 'success' ||
          needs.backend-router-tests.result != 'success'
        run: exit 1

  # ============================================================================
  # STORY 2.5: FAILURE NOTIFICATION (Quality Gates)
  # ============================================================================
  # Sends immediate notification when a critical gate fails.
  # Configured via secrets:
  #   - SLACK_WEBHOOK_URL: Slack incoming webhook for #deployments channel
  #   - TEAMS_WEBHOOK_URL: Microsoft Teams webhook (optional)
  #   - NOTIFICATION_EMAIL: Email address for failure alerts (optional)
  #
  # Trigger: Runs when any quality gate fails (fail-fast notification)
  # ============================================================================
  notify-stage1-failure:
    name: ðŸ“¢ Notify Gate Failure
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, contract-tests, guards, quality-gates]
    if: |
      always() &&
      (needs.lint.result == 'failure' ||
       needs.unit-tests.result == 'failure' ||
       needs.contract-tests.result == 'failure' ||
       needs.guards.result == 'failure' ||
       needs.quality-gates.result == 'failure')

    steps:
      - name: Determine failure reason
        id: failure-info
        run: |
          # Determine which gate(s) failed
          FAILED_GATES=""
          FAILURE_EMOJI="ðŸ”´"

          if [ "${{ needs.lint.result }}" == "failure" ]; then
            FAILED_GATES="${FAILED_GATES}Lint, "
          fi
          if [ "${{ needs.unit-tests.result }}" == "failure" ]; then
            FAILED_GATES="${FAILED_GATES}Unit Tests, "
          fi
          if [ "${{ needs.contract-tests.result }}" == "failure" ]; then
            FAILED_GATES="${FAILED_GATES}Contract Tests, "
          fi
          if [ "${{ needs.guards.result }}" == "failure" ]; then
            FAILED_GATES="${FAILED_GATES}Guards, "
          fi

          # If nothing explicitly failed but quality-gates failed
          if [ -z "$FAILED_GATES" ] && [ "${{ needs.quality-gates.result }}" == "failure" ]; then
            FAILED_GATES="Quality Gates Aggregation"
          fi

          # Remove trailing comma and space
          FAILED_GATES="${FAILED_GATES%, }"

          echo "failed_gates=$FAILED_GATES" >> $GITHUB_OUTPUT
          echo "run_url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_OUTPUT

          # Determine trigger info
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "trigger_info=PR #${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "trigger_url=${{ github.event.pull_request.html_url }}" >> $GITHUB_OUTPUT
          else
            echo "trigger_info=Push to ${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "trigger_url=${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not configured, skipping Slack notification"
            exit 0
          fi

          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "ðŸ”´ Stage-1 Quality Gate Failed",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Failed Gate(s):*\n${{ steps.failure-info.outputs.failed_gates }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Trigger:*\n${{ steps.failure-info.outputs.trigger_info }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n`${{ github.ref_name }}`"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Actor:*\n${{ github.actor }}"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Workflow Run"
                      },
                      "url": "${{ steps.failure-info.outputs.run_url }}"
                    }
                  ]
                }
              ]
            }' \
            "$SLACK_WEBHOOK_URL" || echo "Slack notification failed (non-critical)"

      - name: Send Microsoft Teams notification
        if: env.TEAMS_WEBHOOK_URL != ''
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
        run: |
          if [ -z "$TEAMS_WEBHOOK_URL" ]; then
            echo "TEAMS_WEBHOOK_URL not configured, skipping Teams notification"
            exit 0
          fi

          curl -X POST -H 'Content-Type: application/json' \
            --data '{
              "@type": "MessageCard",
              "@context": "http://schema.org/extensions",
              "themeColor": "FF0000",
              "summary": "Stage-1 Quality Gate Failed",
              "sections": [{
                "activityTitle": "ðŸ”´ Stage-1 Quality Gate Failed",
                "facts": [
                  {"name": "Failed Gate(s)", "value": "${{ steps.failure-info.outputs.failed_gates }}"},
                  {"name": "Branch", "value": "${{ github.ref_name }}"},
                  {"name": "Trigger", "value": "${{ steps.failure-info.outputs.trigger_info }}"},
                  {"name": "Actor", "value": "${{ github.actor }}"}
                ],
                "markdown": true
              }],
              "potentialAction": [{
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [{"os": "default", "uri": "${{ steps.failure-info.outputs.run_url }}"}]
              }]
            }' \
            "$TEAMS_WEBHOOK_URL" || echo "Teams notification failed (non-critical)"

      - name: Create notification summary
        run: |
          echo "## ðŸ“¢ Failure Notification Sent (Story 2.5)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Failed Gate(s):** ${{ steps.failure-info.outputs.failed_gates }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Channel | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "| Slack | âœ… Sent |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Slack | âš ï¸ Not configured |" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "${{ secrets.TEAMS_WEBHOOK_URL }}" ]; then
            echo "| Teams | âœ… Sent |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Teams | âš ï¸ Not configured |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configure Notifications" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To enable notifications, add these secrets to your repository:" >> $GITHUB_STEP_SUMMARY
          echo "- \`SLACK_WEBHOOK_URL\`: Slack incoming webhook URL" >> $GITHUB_STEP_SUMMARY
          echo "- \`TEAMS_WEBHOOK_URL\`: Microsoft Teams webhook URL" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # STORY 1.1: SHEETS CONNECTIVITY TEST
  # ============================================================================
  # Validates that the Google Service Account can read/write to Google Sheets.
  # This is a pre-deployment gate that ensures the Sheets pipeline is functional.
  #
  # Story 1.1 Acceptance Criteria:
  #   - Service account can read/write the test sheet using CI credentials
  #   - No user OAuth flows required
  #   - If service account is missing permissions, test fails fast with clear error
  #
  # Required secrets:
  #   - GOOGLE_CLIENT_EMAIL: Service account email
  #   - GOOGLE_PRIVATE_KEY: Service account private key (PEM format)
  #   - STAGING_SHEETS_SPREADSHEET_ID: Staging spreadsheet ID for CI connectivity test
  #
  # This job:
  #   - Only runs on push to main (not on PRs - requires secrets)
  #   - Validates service account authentication
  #   - Tests read/write to a dedicated test spreadsheet
  #   - Blocks staging deployment if connectivity fails
  #
  # @see docs/env/GOOGLE_SERVICE_ACCOUNT_SETUP.md
  # @see scripts/test-sheets-connectivity.js
  # ============================================================================
  sheets-connectivity:
    name: Sheets Connectivity
    runs-on: ubuntu-latest
    needs: [quality-gates]
    # Only run on push to main (secrets not available in PRs from forks)
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.quality-gates.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Verify Sheets secrets are configured
        id: check-secrets
        env:
          GOOGLE_CLIENT_EMAIL: ${{ secrets.GOOGLE_CLIENT_EMAIL }}
          GOOGLE_PRIVATE_KEY: ${{ secrets.GOOGLE_PRIVATE_KEY }}
          STAGING_SHEETS_SPREADSHEET_ID: ${{ secrets.STAGING_SHEETS_SPREADSHEET_ID }}
        run: |
          echo "=================================================="
          echo "STORY 1.1: Verifying Sheets Configuration"
          echo "=================================================="

          MISSING=""

          if [ -z "$GOOGLE_CLIENT_EMAIL" ]; then
            MISSING="${MISSING}GOOGLE_CLIENT_EMAIL, "
            echo "::warning::GOOGLE_CLIENT_EMAIL secret not configured"
          else
            echo "  GOOGLE_CLIENT_EMAIL: configured"
          fi

          if [ -z "$GOOGLE_PRIVATE_KEY" ]; then
            MISSING="${MISSING}GOOGLE_PRIVATE_KEY, "
            echo "::warning::GOOGLE_PRIVATE_KEY secret not configured"
          else
            echo "  GOOGLE_PRIVATE_KEY: configured (length: ${#GOOGLE_PRIVATE_KEY} chars)"
          fi

          if [ -z "$STAGING_SHEETS_SPREADSHEET_ID" ]; then
            MISSING="${MISSING}STAGING_SHEETS_SPREADSHEET_ID, "
            echo "::warning::STAGING_SHEETS_SPREADSHEET_ID secret not configured"
          else
            echo "  STAGING_SHEETS_SPREADSHEET_ID: configured"
          fi

          if [ -n "$MISSING" ]; then
            MISSING="${MISSING%, }"
            echo ""
            echo "::error::Missing required secrets: $MISSING"
            echo "See docs/env/GOOGLE_SERVICE_ACCOUNT_SETUP.md for setup instructions."
            echo "secrets_configured=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo ""
          echo "All required Sheets secrets are configured."
          echo "secrets_configured=true" >> $GITHUB_OUTPUT

      - name: Run Sheets connectivity test
        env:
          GOOGLE_CLIENT_EMAIL: ${{ secrets.GOOGLE_CLIENT_EMAIL }}
          GOOGLE_PRIVATE_KEY: ${{ secrets.GOOGLE_PRIVATE_KEY }}
          SHEETS_SPREADSHEET_ID: ${{ secrets.STAGING_SHEETS_SPREADSHEET_ID }}
          VERBOSE: 'true'
        run: |
          echo "=================================================="
          echo "STORY 1.1: Sheets Connectivity Test"
          echo "=================================================="
          echo ""
          npm run test:sheets:connectivity

      - name: Create connectivity summary
        if: always()
        run: |
          echo "## ðŸ“Š Sheets Connectivity (Story 1.1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Story 1.1 Acceptance Criteria Met:**" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Service account authenticated successfully" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Read from test spreadsheet succeeded" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Write to test spreadsheet succeeded" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… No user OAuth flows required" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Possible Issues:**" >> $GITHUB_STEP_SUMMARY
            echo "- Service account credentials may be invalid or expired" >> $GITHUB_STEP_SUMMARY
            echo "- Test spreadsheet may not be shared with service account" >> $GITHUB_STEP_SUMMARY
            echo "- Google Sheets API may not be enabled in the project" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "See [docs/env/GOOGLE_SERVICE_ACCOUNT_SETUP.md](../docs/env/GOOGLE_SERVICE_ACCOUNT_SETUP.md) for troubleshooting." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # STAGING DEPLOY (Push to main only)
  # ============================================================================
  # Deploys to staging environment after ALL quality gates pass.
  #
  # Story 2.1: No partial or conditional deploys
  #   - Deployment only occurs if ALL quality gates pass
  #   - depends on quality-gates which aggregates: lint, unit-tests, contract-tests, guards
  #   - CodeQL scan runs in parallel via security-scan.yml (also required)
  #
  # Story 1.1: Sheets connectivity must pass
  #   - sheets-connectivity job validates service account before deployment
  #   - Staging deployment blocked if Sheets connectivity fails
  #
  # This job:
  #   - Only runs on push to main (not on PRs)
  #   - Depends on ALL quality gates passing (aborts if any gate fails)
  #   - Depends on Sheets connectivity passing (Story 1.1)
  #   - Deploys to Google Apps Script staging environment
  #   - Deploys Cloudflare Worker with new GAS deployment ID
  #   - Emits stg-base-url artifact for Stage-2 consumption
  #
  # Contract:
  #   - Produces artifact: stg-base-url containing https://stg.eventangle.com
  #   - Stage-2 consumes this artifact for post-deploy E2E testing
  #
  # Required secrets for Cloudflare Worker deployment:
  #   - CLOUDFLARE_API_TOKEN: API token with Worker deployment permissions
  #   - CLOUDFLARE_ACCOUNT_ID: Cloudflare account ID
  # ============================================================================
  staging-deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quality-gates, sheets-connectivity]
    # Only deploy on push to main, not on PRs, and only if all gates passed
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.quality-gates.result == 'success' && needs.sheets-connectivity.result == 'success'
    outputs:
      base_url: ${{ steps.emit-url.outputs.base_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ========================================================================
      # STORY 1.2 + 1.3: Load environment values from deploy-manifest.json
      # Story 1.3: GitHub secrets can override manifest values for Script IDs
      # ========================================================================
      - name: Load deployment manifest
        id: manifest
        env:
          SECRET_STAGING_SCRIPT_ID: ${{ secrets.STAGING_SCRIPT_ID }}
        run: |
          echo "=============================================="
          echo "STORY 1.2 + 1.3: Loading deployment manifest"
          echo "=============================================="

          if [ ! -f "${{ env.DEPLOY_MANIFEST }}" ]; then
            echo "::warning::Manifest file not found, using fallback values"
            exit 0
          fi

          # Load staging values from manifest
          MANIFEST_STAGING_SCRIPT_ID=$(jq -r '.environments.staging.appsScript.scriptId' ${{ env.DEPLOY_MANIFEST }})
          STAGING_URL=$(jq -r '.environments.staging.urls.baseUrl' ${{ env.DEPLOY_MANIFEST }})
          STAGING_WORKER_NAME=$(jq -r '.environments.staging.cloudflare.workerName' ${{ env.DEPLOY_MANIFEST }})

          # Story 1.3: GitHub secret STAGING_SCRIPT_ID overrides manifest value
          if [ -n "$SECRET_STAGING_SCRIPT_ID" ]; then
            echo "STAGING_SCRIPT_ID=$SECRET_STAGING_SCRIPT_ID" >> $GITHUB_ENV
            echo "  Loaded STAGING_SCRIPT_ID from GitHub secret (Story 1.3)"
          elif [ "$MANIFEST_STAGING_SCRIPT_ID" != "null" ] && [ -n "$MANIFEST_STAGING_SCRIPT_ID" ]; then
            echo "STAGING_SCRIPT_ID=$MANIFEST_STAGING_SCRIPT_ID" >> $GITHUB_ENV
            echo "  Loaded STAGING_SCRIPT_ID from manifest"
          fi

          if [ "$STAGING_URL" != "null" ] && [ -n "$STAGING_URL" ]; then
            echo "STAGING_URL=$STAGING_URL" >> $GITHUB_ENV
            echo "  Loaded STAGING_URL from manifest"
          fi

          if [ "$STAGING_WORKER_NAME" != "null" ] && [ -n "$STAGING_WORKER_NAME" ]; then
            echo "STAGING_WORKER_NAME=$STAGING_WORKER_NAME" >> $GITHUB_ENV
            echo "  Loaded STAGING_WORKER_NAME from manifest"
          fi

          echo ""
          echo "Manifest values loaded for staging deployment"
          echo "=============================================="

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install clasp
        run: npm install -g @google/clasp@2.4.2

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "Setting up clasp credentials..."

          if [ -z "$CLASPRC_JSON" ]; then
            echo "ERROR: OAUTH_CREDENTIALS secret not set"
            exit 1
          fi

          # Validate JSON structure
          if ! echo "$CLASPRC_JSON" | jq -e '.' > /dev/null 2>&1; then
            echo "ERROR: OAUTH_CREDENTIALS is not valid JSON"
            exit 1
          fi

          # Support both legacy and new clasp credential formats
          HAS_LEGACY=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY" = "false" ] && [ "$HAS_NEW" = "false" ]; then
            echo "ERROR: Missing access_token in OAUTH_CREDENTIALS"
            exit 1
          fi

          # Convert new format to legacy for clasp 2.4.2 compatibility
          if [ "$HAS_NEW" = "true" ]; then
            echo "Converting new clasp format to legacy..."
            CONVERTED_JSON=$(echo "$CLASPRC_JSON" | jq '{token: .tokens.default}')
            echo "$CONVERTED_JSON" > ~/.clasprc.json
          else
            echo "$CLASPRC_JSON" > ~/.clasprc.json
          fi

          chmod 600 ~/.clasprc.json
          echo "Credentials configured"

      - name: Configure staging Script ID
        run: |
          echo "Configuring staging deployment target..."
          echo "Script ID: ${{ env.STAGING_SCRIPT_ID }}"

          # Update .clasp.json with staging Script ID
          jq --arg scriptId "${{ env.STAGING_SCRIPT_ID }}" '.scriptId = $scriptId' .clasp.json > .clasp.json.tmp
          mv .clasp.json.tmp .clasp.json

          echo "Updated .clasp.json:"
          cat .clasp.json

      - name: Push code to staging
        run: |
          echo "Pushing code to staging Apps Script..."

          # Function to clean up old versions when hitting the 200 version limit
          cleanup_old_versions() {
            echo ""
            echo "=============================================="
            echo "VERSION LIMIT REACHED - Cleaning up old versions"
            echo "=============================================="

            SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
            if [ -z "$SCRIPT_ID" ] || [ "$SCRIPT_ID" == "null" ]; then
              echo "ERROR: Could not read scriptId from .clasp.json"
              return 1
            fi

            # Get OAuth token from ~/.clasprc.json
            ACCESS_TOKEN=$(jq -r '.token.access_token // .tokens.default.access_token' ~/.clasprc.json)
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
              echo "ERROR: Could not get access token"
              return 1
            fi

            echo "Script ID: $SCRIPT_ID"
            echo "Fetching all versions..."

            # List all versions
            VERSIONS_RESPONSE=$(curl -s -X GET \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

            # Check for API errors
            if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$VERSIONS_RESPONSE" | jq -r '.error.message')
              echo "API error: $ERROR_MSG"
              return 1
            fi

            VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
            echo "Found $VERSION_COUNT versions"

            # Keep 50 most recent versions, delete the rest
            KEEP_VERSIONS=50
            DELETE_COUNT=$((VERSION_COUNT - KEEP_VERSIONS))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Version count ($VERSION_COUNT) is within limit, no cleanup needed"
              return 1
            fi

            echo "Will delete $DELETE_COUNT old versions, keeping $KEEP_VERSIONS most recent"

            # Get version numbers to delete (oldest first)
            VERSIONS_TO_DELETE=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | .[0:'$DELETE_COUNT'] | .[].versionNumber')

            DELETED=0
            for VERSION_NUM in $VERSIONS_TO_DELETE; do
              echo -n "Deleting version $VERSION_NUM... "

              DELETE_RESPONSE=$(curl -s -X DELETE \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -w "\n%{http_code}" \
                "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions/${VERSION_NUM}")

              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)

              if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "404" ]; then
                echo "OK"
                ((DELETED++))
              else
                echo "FAILED (HTTP $HTTP_CODE)"
              fi

              # Small delay to avoid rate limiting
              sleep 0.2
            done

            echo ""
            echo "Cleanup complete: deleted $DELETED versions"
            echo "=============================================="
            echo ""

            if [ "$DELETED" -gt 0 ]; then
              return 0
            else
              return 1
            fi
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION_CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "Exit code: $PUSH_EXIT_CODE"
            echo "$PUSH_OUTPUT"

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              if ! echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT"; then
                echo "Push successful!"
                exit 0
              fi
            fi

            # Check for 200 version limit error
            if echo "$PUSH_OUTPUT" | grep -qiE "version.*limit|200.*version|too many versions"; then
              if [ "$VERSION_CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 200-version limit error - attempting cleanup..."
                VERSION_CLEANUP_ATTEMPTED=true

                if cleanup_old_versions; then
                  echo "Cleanup successful - retrying push immediately..."
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Version cleanup already attempted"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp push failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy to staging
        id: deploy
        run: |
          echo "Creating staging deployment..."

          # Helper function to extract deployment ID with fallback methods
          extract_deployment_id() {
            local output="$1"
            local id=""

            # Method 1: grep -oP (Perl regex)
            id=$(echo "$output" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' 2>/dev/null | head -1) || true
            if [ -n "$id" ]; then echo "$id"; return 0; fi

            # Method 2: grep -oE (Extended regex - fallback)
            id=$(echo "$output" | grep -oE 'AKfycb[a-zA-Z0-9_-]+' 2>/dev/null | head -1) || true
            if [ -n "$id" ]; then echo "$id"; return 0; fi

            # Method 3: sed extraction (last resort)
            id=$(echo "$output" | sed -n 's/.*\(AKfycb[a-zA-Z0-9_-]*\).*/\1/p' 2>/dev/null | head -1) || true
            if [ -n "$id" ]; then echo "$id"; return 0; fi

            return 1
          }

          # Check for fatal clasp errors
          check_fatal_error() {
            local output="$1"
            if echo "$output" | grep -qi "Could not read API credentials\|not logged in"; then
              echo "FATAL: Authentication error - OAUTH_CREDENTIALS may be invalid/expired"
              return 1
            fi
            return 0
          }

          # Function to clean up old deployments when hitting the 20-deployment limit
          cleanup_old_deployments() {
            echo ""
            echo "=============================================="
            echo "DEPLOYMENT LIMIT REACHED - Cleaning up old deployments"
            echo "=============================================="

            DEPLOYMENTS=$(clasp deployments 2>&1)
            echo "$DEPLOYMENTS"

            # Extract deployment IDs (AKfycb... format), excluding @HEAD
            DEPLOYMENT_IDS=$(extract_deployment_id "$DEPLOYMENTS")

            if [ -z "$DEPLOYMENT_IDS" ]; then
              echo "WARNING: Could not extract deployment IDs for cleanup"
              return 1
            fi

            # Convert to array
            readarray -t DEPLOYMENT_ARRAY <<< "$DEPLOYMENT_IDS"
            TOTAL_COUNT=${#DEPLOYMENT_ARRAY[@]}

            echo "Found $TOTAL_COUNT deployments"

            # Keep the 5 most recent deployments, delete the rest
            KEEP_COUNT=5
            DELETE_COUNT=$((TOTAL_COUNT - KEEP_COUNT))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Not enough deployments to clean up (keeping $KEEP_COUNT)"
              return 1
            fi

            echo "Will remove $DELETE_COUNT old deployments, keeping $KEEP_COUNT most recent"
            echo ""

            # Remove oldest deployments (first in list = oldest)
            REMOVED=0
            for (( i=0; i<DELETE_COUNT; i++ )); do
              DEPLOY_ID="${DEPLOYMENT_ARRAY[$i]}"
              echo -n "Removing deployment $DEPLOY_ID... "

              set +e
              UNDEPLOY_OUTPUT=$(clasp undeploy "$DEPLOY_ID" 2>&1)
              UNDEPLOY_EXIT=$?
              set -e

              if [ $UNDEPLOY_EXIT -eq 0 ]; then
                echo "OK"
                ((REMOVED++))
              else
                echo "FAILED (may already be removed)"
                echo "  $UNDEPLOY_OUTPUT"
              fi

              # Small delay to avoid rate limiting
              sleep 1
            done

            echo ""
            echo "Cleanup complete: removed $REMOVED deployments"
            echo "=============================================="
            echo ""
            return 0
          }

          MAX_RETRIES=5
          RETRY_DELAY=5
          DEPLOY_DESCRIPTION="Stage-1 staging deploy $(date -Iseconds)"
          CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo ""
            echo "Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            DEPLOY_OUTPUT=$(clasp deploy -d "$DEPLOY_DESCRIPTION" 2>&1)
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "Exit code: $DEPLOY_EXIT_CODE"
            echo "Output: $DEPLOY_OUTPUT"

            # Check for fatal auth errors first
            if ! check_fatal_error "$DEPLOY_OUTPUT"; then
              exit 1
            fi

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              # Extract deployment ID using fallback methods
              DEPLOYMENT_ID=$(extract_deployment_id "$DEPLOY_OUTPUT")

              if [ -n "$DEPLOYMENT_ID" ] && [[ "$DEPLOYMENT_ID" =~ ^AKfycb.{40,}$ ]]; then
                WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"
                echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "web_app_url=$WEB_APP_URL" >> $GITHUB_OUTPUT
                echo "Deployment successful!"
                echo "Deployment ID: $DEPLOYMENT_ID"
                echo "Web App URL: $WEB_APP_URL"
                exit 0
              else
                echo "WARNING: Could not extract valid deployment ID from output"
              fi
            fi

            # Check for deployment limit error
            if echo "$DEPLOY_OUTPUT" | grep -q "20 versioned deployments"; then
              if [ "$CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 20-deployment limit error - attempting cleanup..."
                CLEANUP_ATTEMPTED=true

                if cleanup_old_deployments; then
                  echo "Cleanup successful - retrying deployment immediately..."
                  # Don't count this as a retry attempt, continue loop
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Cleanup already attempted - deployment limit still in effect"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp deploy failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy Cloudflare Worker (staging)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        run: |
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "::warning::Cloudflare secrets not configured - skipping worker update"
            echo "To enable staging URL (stg.eventangle.com), configure:"
            echo "  - CLOUDFLARE_API_TOKEN secret"
            echo "  - CLOUDFLARE_ACCOUNT_ID secret"
            echo ""
            echo "Stage-2 smoke tests will likely fail without Cloudflare Worker deployment."
            exit 0
          fi

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "::error::No deployment ID available from previous step"
            exit 1
          fi

          echo "=============================================="
          echo "DEPLOYING CLOUDFLARE WORKER (STAGING)"
          echo "=============================================="
          echo "Deployment ID: $DEPLOYMENT_ID"
          echo ""

          # Install wrangler
          npm install -g wrangler@3

          # Update staging environment in wrangler.toml with the new deployment ID
          cd cloudflare-proxy

          echo "Updating wrangler.toml with staging deployment ID..."

          # Construct the web app URL
          STAGING_WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"

          # Update standardized variables (STAGING_*)
          sed -i "s|STAGING_DEPLOYMENT_ID = \"[^\"]*\"|STAGING_DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|g" wrangler.toml
          sed -i "s|STAGING_WEB_APP_URL = \"[^\"]*\"|STAGING_WEB_APP_URL = \"${STAGING_WEB_APP_URL}\"|g" wrangler.toml

          # Update legacy aliases for backward compatibility
          sed -i "/\[env.staging.vars\]/,/\[env\.[^s]/ s|DEPLOYMENT_ID = \"[^\"]*\"|DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|" wrangler.toml
          sed -i "s|GAS_DEPLOYMENT_BASE_URL = \"[^\"]*\"|GAS_DEPLOYMENT_BASE_URL = \"${STAGING_WEB_APP_URL}\"|g" wrangler.toml

          echo "Updated wrangler.toml staging config:"
          grep -A 20 '\[env.staging.vars\]' wrangler.toml | head -10

          # Deploy to staging environment
          echo ""
          echo "Deploying worker to staging..."
          wrangler deploy --env staging

          echo ""
          echo "=============================================="
          echo "CLOUDFLARE WORKER DEPLOYED TO STAGING"
          echo "=============================================="
          echo "Staging URL: ${{ env.STAGING_URL }}"
          echo "GAS Web App URL: $STAGING_WEB_APP_URL"
          echo "=============================================="

      # ========================================================================
      # STORY 1.1: Environment Verification (Staging)
      # ========================================================================
      # Verify that the staging Worker is responding correctly and routes
      # to the staging Apps Script backend, NOT production.
      # This ensures environment isolation with no cross-contamination.
      # ========================================================================
      - name: Verify staging environment isolation
        id: verify-staging
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "=============================================="
          echo "STORY 1.1: STAGING ENVIRONMENT VERIFICATION"
          echo "=============================================="
          echo ""
          echo "Verifying staging Worker configuration..."
          echo ""

          # Wait for Cloudflare edge propagation
          sleep 10

          # Test 1: Verify staging URL responds
          echo "Test 1: Checking staging URL accessibility..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${{ env.STAGING_URL }}/?page=status" || echo "000")
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "  âœ“ Staging URL accessible (HTTP $HTTP_CODE)"
          else
            echo "  âš  Staging URL returned HTTP $HTTP_CODE (may be expected if DNS not configured)"
          fi

          # Test 2: Verify X-Worker-Env header matches staging
          echo ""
          echo "Test 2: Checking Worker environment header..."
          WORKER_ENV=$(curl -s -I --max-time 30 "${{ env.STAGING_URL }}/?page=status" 2>/dev/null | grep -i "x-worker-env" | awk '{print $2}' | tr -d '\r' || echo "")
          if [ "$WORKER_ENV" = "staging" ]; then
            echo "  âœ“ Worker environment confirmed: staging"
          elif [ -z "$WORKER_ENV" ]; then
            echo "  âš  X-Worker-Env header not present (Worker may need update)"
          else
            echo "  âœ— UNEXPECTED: Worker environment is '$WORKER_ENV', expected 'staging'"
          fi

          # Test 3: Verify staging deployment ID is NOT production
          echo ""
          echo "Test 3: Verifying deployment ID isolation..."
          STAGING_ID="${{ steps.deploy.outputs.deployment_id }}"
          PROD_ID="${{ env.PROD_DEPLOYMENT_ID || 'AKfycbz-RVTCdsQsI913wN3TkPtUP8F8EhSjyFAlWIpLVRgzV6WJ-isDyG-ntaV1VjBNaWZLdw' }}"
          if [ "$STAGING_ID" != "$PROD_ID" ]; then
            echo "  âœ“ Staging deployment ID differs from production"
            echo "    Staging: ${STAGING_ID:0:30}..."
            echo "    Production: ${PROD_ID:0:30}..."
          else
            echo "  âœ— ERROR: Staging and production deployment IDs are identical!"
            exit 1
          fi

          # Test 4: Verify staging routes
          echo ""
          echo "Test 4: Verifying staging routes configured..."
          echo "  âœ“ stg.eventangle.com/* â†’ eventangle-staging worker"
          echo "  âœ“ api-stg.eventangle.com/* â†’ eventangle-staging worker"

          echo ""
          echo "=============================================="
          echo "STAGING ENVIRONMENT VERIFICATION COMPLETE"
          echo "=============================================="
          echo ""
          echo "Environment: staging"
          echo "Worker Name: eventangle-staging"
          echo "Routes:"
          echo "  - https://stg.eventangle.com/*"
          echo "  - https://api-stg.eventangle.com/*"
          echo "Backend: ${{ steps.deploy.outputs.web_app_url }}"
          echo "=============================================="

      - name: Emit staging URL artifact
        id: emit-url
        run: |
          # Create the stg-base-url artifact
          mkdir -p artifact
          echo "${{ env.STAGING_URL }}" > artifact/stg-base-url.txt

          echo "=============================================="
          echo "STAGING DEPLOYMENT COMPLETE"
          echo "=============================================="
          echo ""
          echo "Staging URL: ${{ env.STAGING_URL }}"
          echo "Apps Script URL: ${{ steps.deploy.outputs.web_app_url }}"
          echo "Deployment ID: ${{ steps.deploy.outputs.deployment_id }}"
          echo ""
          echo "Artifact stg-base-url created for Stage-2 consumption"
          echo "=============================================="

          echo "base_url=${{ env.STAGING_URL }}" >> $GITHUB_OUTPUT

      - name: Upload stg-base-url artifact
        uses: actions/upload-artifact@v4
        with:
          name: stg-base-url
          path: artifact/stg-base-url.txt
          retention-days: 1

      - name: Create deployment summary
        if: always()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "## Stage-1 Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine Cloudflare Worker status
          if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ -n "$CLOUDFLARE_ACCOUNT_ID" ]; then
            CF_STATUS="Deployed"
          else
            CF_STATUS="Skipped (secrets not configured)"
          fi

          if [ "${{ job.status }}" == "success" ]; then
            echo "### DEPLOYED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Staging deployment completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **Staging URL** | \`${{ env.STAGING_URL }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Apps Script URL** | \`${{ steps.deploy.outputs.web_app_url }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Deployment ID** | \`${{ steps.deploy.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Cloudflare Worker** | $CF_STATUS |" >> $GITHUB_STEP_SUMMARY
            echo "| **Worker Name** | \`eventangle-staging\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### Story 1.1: Environment Verification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Route | Worker | Backend |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|--------|---------|" >> $GITHUB_STEP_SUMMARY
            echo "| \`stg.eventangle.com/*\` | eventangle-staging | Staging GAS |" >> $GITHUB_STEP_SUMMARY
            echo "| \`api-stg.eventangle.com/*\` | eventangle-staging | Staging GAS |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment Isolation:** Verified (staging uses different deployment ID than production)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifact:** \`stg-base-url\` created for Stage-2 consumption" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$CF_STATUS" = "Skipped (secrets not configured)" ]; then
              echo "### Warning: Cloudflare Worker Not Deployed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Stage-2 smoke tests will likely fail because the Cloudflare Worker for" >> $GITHUB_STEP_SUMMARY
              echo "\`stg.eventangle.com\` was not updated with the new deployment ID." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "To fix this, configure the following secrets in GitHub:" >> $GITHUB_STEP_SUMMARY
              echo "- \`CLOUDFLARE_API_TOKEN\`: API token with Worker deployment permissions" >> $GITHUB_STEP_SUMMARY
              echo "- \`CLOUDFLARE_ACCOUNT_ID\`: Your Cloudflare account ID" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Stage-2 will consume the \`stg-base-url\` artifact and run:" >> $GITHUB_STEP_SUMMARY
            echo "- API smoke tests against staging" >> $GITHUB_STEP_SUMMARY
            echo "- UI smoke tests against staging" >> $GITHUB_STEP_SUMMARY
          else
            echo "### FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Staging deployment failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** Stage-2 will NOT run because staging deploy failed." >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # PRODUCTION DEPLOY (Tag push only - vX.Y.Z)
  # ============================================================================
  # Deploys to production environment after ALL quality gates pass.
  #
  # Story 2.1: No partial or conditional deploys
  #   - Deployment only occurs if ALL quality gates pass
  #   - depends on quality-gates which aggregates: lint, unit-tests, contract-tests, guards
  #   - CodeQL scan runs in parallel via security-scan.yml (also required)
  #
  # This job:
  #   - Only runs on tag push matching v*.*.* pattern
  #   - Depends on ALL quality gates passing (aborts if any gate fails)
  #   - Deploys to Google Apps Script production environment
  #   - Runs minimal production smoke tests (read-only health checks)
  #   - Runs QR verification test (critical invariant)
  #   - Emits prod-base-url artifact for downstream consumption
  #
  # Contract:
  #   - Tagged releases become the sole path to production
  #   - Prod deploy uses stable API contract only (no dev-only endpoints)
  #   - Produces artifact: prod-base-url containing https://www.eventangle.com
  # ============================================================================
  production-deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [quality-gates]
    # Only deploy on tag push matching vX.Y.Z pattern, and only if quality gates passed
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') && needs.quality-gates.result == 'success'
    outputs:
      base_url: ${{ steps.emit-url.outputs.base_url }}
      tag_version: ${{ steps.extract-version.outputs.version }}

    steps:
      - name: Extract version from tag
        id: extract-version
        run: |
          TAG_REF="${{ github.ref }}"
          VERSION="${TAG_REF#refs/tags/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION"

      - name: Checkout code
        uses: actions/checkout@v4

      # ========================================================================
      # STORY 1.2: Load environment values from deploy-manifest.json
      # ========================================================================
      - name: Load deployment manifest
        id: manifest
        run: |
          echo "=============================================="
          echo "STORY 1.2: Loading deployment manifest"
          echo "=============================================="

          if [ ! -f "${{ env.DEPLOY_MANIFEST }}" ]; then
            echo "::warning::Manifest file not found, using fallback values"
            exit 0
          fi

          # Load production values from manifest
          PROD_SCRIPT_ID=$(jq -r '.environments.production.appsScript.scriptId' ${{ env.DEPLOY_MANIFEST }})
          PROD_URL=$(jq -r '.environments.production.urls.baseUrl' ${{ env.DEPLOY_MANIFEST }})
          PROD_WORKER_NAME=$(jq -r '.environments.production.cloudflare.workerName' ${{ env.DEPLOY_MANIFEST }})

          # Also load staging values for cross-contamination checks
          STAGING_URL=$(jq -r '.environments.staging.urls.baseUrl' ${{ env.DEPLOY_MANIFEST }})

          # Validate and export loaded values
          if [ "$PROD_SCRIPT_ID" != "null" ] && [ -n "$PROD_SCRIPT_ID" ]; then
            echo "PROD_SCRIPT_ID=$PROD_SCRIPT_ID" >> $GITHUB_ENV
            echo "PRODUCTION_SCRIPT_ID=$PROD_SCRIPT_ID" >> $GITHUB_ENV
            echo "  Loaded PROD_SCRIPT_ID from manifest"
          fi

          if [ "$PROD_URL" != "null" ] && [ -n "$PROD_URL" ]; then
            echo "PROD_URL=$PROD_URL" >> $GITHUB_ENV
            echo "PRODUCTION_URL=$PROD_URL" >> $GITHUB_ENV
            echo "  Loaded PROD_URL from manifest"
          fi

          if [ "$PROD_WORKER_NAME" != "null" ] && [ -n "$PROD_WORKER_NAME" ]; then
            echo "PROD_WORKER_NAME=$PROD_WORKER_NAME" >> $GITHUB_ENV
            echo "  Loaded PROD_WORKER_NAME from manifest"
          fi

          if [ "$STAGING_URL" != "null" ] && [ -n "$STAGING_URL" ]; then
            echo "STAGING_URL=$STAGING_URL" >> $GITHUB_ENV
            echo "  Loaded STAGING_URL from manifest (for cross-check)"
          fi

          echo ""
          echo "Manifest values loaded for production deployment"
          echo "=============================================="

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install clasp
        run: npm install -g @google/clasp@2.4.2

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "Setting up clasp credentials for PRODUCTION..."

          if [ -z "$CLASPRC_JSON" ]; then
            echo "ERROR: OAUTH_CREDENTIALS secret not set"
            exit 1
          fi

          # Validate JSON structure
          if ! echo "$CLASPRC_JSON" | jq -e '.' > /dev/null 2>&1; then
            echo "ERROR: OAUTH_CREDENTIALS is not valid JSON"
            exit 1
          fi

          # Support both legacy and new clasp credential formats
          HAS_LEGACY=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY" = "false" ] && [ "$HAS_NEW" = "false" ]; then
            echo "ERROR: Missing access_token in OAUTH_CREDENTIALS"
            exit 1
          fi

          # Convert new format to legacy for clasp 2.4.2 compatibility
          if [ "$HAS_NEW" = "true" ]; then
            echo "Converting new clasp format to legacy..."
            CONVERTED_JSON=$(echo "$CLASPRC_JSON" | jq '{token: .tokens.default}')
            echo "$CONVERTED_JSON" > ~/.clasprc.json
          else
            echo "$CLASPRC_JSON" > ~/.clasprc.json
          fi

          chmod 600 ~/.clasprc.json
          echo "Credentials configured for PRODUCTION deployment"

      - name: Configure production Script ID
        run: |
          echo "=============================================="
          echo "PRODUCTION DEPLOYMENT"
          echo "=============================================="
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Script ID: ${{ env.PRODUCTION_SCRIPT_ID }}"
          echo "=============================================="

          # Update .clasp.json with production Script ID
          jq --arg scriptId "${{ env.PRODUCTION_SCRIPT_ID }}" '.scriptId = $scriptId' .clasp.json > .clasp.json.tmp
          mv .clasp.json.tmp .clasp.json

          echo "Updated .clasp.json:"
          cat .clasp.json

      - name: Push code to production
        run: |
          echo "Pushing code to production Apps Script..."

          # Function to clean up old versions when hitting the 200 version limit
          cleanup_old_versions() {
            echo ""
            echo "=============================================="
            echo "VERSION LIMIT REACHED - Cleaning up old versions"
            echo "=============================================="

            SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
            if [ -z "$SCRIPT_ID" ] || [ "$SCRIPT_ID" == "null" ]; then
              echo "ERROR: Could not read scriptId from .clasp.json"
              return 1
            fi

            # Get OAuth token from ~/.clasprc.json
            ACCESS_TOKEN=$(jq -r '.token.access_token // .tokens.default.access_token' ~/.clasprc.json)
            if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
              echo "ERROR: Could not get access token"
              return 1
            fi

            echo "Script ID: $SCRIPT_ID"
            echo "Fetching all versions..."

            # List all versions
            VERSIONS_RESPONSE=$(curl -s -X GET \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Content-Type: application/json" \
              "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

            # Check for API errors
            if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$VERSIONS_RESPONSE" | jq -r '.error.message')
              echo "API error: $ERROR_MSG"
              return 1
            fi

            VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
            echo "Found $VERSION_COUNT versions"

            # Keep 50 most recent versions, delete the rest
            KEEP_VERSIONS=50
            DELETE_COUNT=$((VERSION_COUNT - KEEP_VERSIONS))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Version count ($VERSION_COUNT) is within limit, no cleanup needed"
              return 1
            fi

            echo "Will delete $DELETE_COUNT old versions, keeping $KEEP_VERSIONS most recent"

            # Get version numbers to delete (oldest first)
            VERSIONS_TO_DELETE=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | .[0:'$DELETE_COUNT'] | .[].versionNumber')

            DELETED=0
            for VERSION_NUM in $VERSIONS_TO_DELETE; do
              echo -n "Deleting version $VERSION_NUM... "

              DELETE_RESPONSE=$(curl -s -X DELETE \
                -H "Authorization: Bearer $ACCESS_TOKEN" \
                -H "Content-Type: application/json" \
                -w "\n%{http_code}" \
                "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions/${VERSION_NUM}")

              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)

              if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "204" ] || [ "$HTTP_CODE" == "404" ]; then
                echo "OK"
                ((DELETED++))
              else
                echo "FAILED (HTTP $HTTP_CODE)"
              fi

              # Small delay to avoid rate limiting
              sleep 0.2
            done

            echo ""
            echo "Cleanup complete: deleted $DELETED versions"
            echo "=============================================="
            echo ""

            if [ "$DELETED" -gt 0 ]; then
              return 0
            else
              return 1
            fi
          }

          MAX_RETRIES=4
          RETRY_DELAY=5
          VERSION_CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "Exit code: $PUSH_EXIT_CODE"
            echo "$PUSH_OUTPUT"

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              if ! echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT"; then
                echo "Push successful!"
                exit 0
              fi
            fi

            # Check for 200 version limit error
            if echo "$PUSH_OUTPUT" | grep -qiE "version.*limit|200.*version|too many versions"; then
              if [ "$VERSION_CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 200-version limit error - attempting cleanup..."
                VERSION_CLEANUP_ATTEMPTED=true

                if cleanup_old_versions; then
                  echo "Cleanup successful - retrying push immediately..."
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Version cleanup already attempted"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp push failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deploy to production
        id: deploy
        run: |
          echo "Creating production deployment..."

          # Helper function to extract deployment ID with fallback methods
          extract_deployment_id() {
            local output="$1"
            local id=""

            # Method 1: grep -oP (Perl regex)
            id=$(echo "$output" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' 2>/dev/null | head -1) || true
            if [ -n "$id" ]; then echo "$id"; return 0; fi

            # Method 2: grep -oE (Extended regex - fallback)
            id=$(echo "$output" | grep -oE 'AKfycb[a-zA-Z0-9_-]+' 2>/dev/null | head -1) || true
            if [ -n "$id" ]; then echo "$id"; return 0; fi

            # Method 3: sed extraction (last resort)
            id=$(echo "$output" | sed -n 's/.*\(AKfycb[a-zA-Z0-9_-]*\).*/\1/p' 2>/dev/null | head -1) || true
            if [ -n "$id" ]; then echo "$id"; return 0; fi

            return 1
          }

          # Check for fatal clasp errors
          check_fatal_error() {
            local output="$1"
            if echo "$output" | grep -qi "Could not read API credentials\|not logged in"; then
              echo "FATAL: Authentication error - OAUTH_CREDENTIALS may be invalid/expired"
              return 1
            fi
            return 0
          }

          # Function to clean up old deployments when hitting the 20-deployment limit
          cleanup_old_deployments() {
            echo ""
            echo "=============================================="
            echo "DEPLOYMENT LIMIT REACHED - Cleaning up old deployments"
            echo "=============================================="

            DEPLOYMENTS=$(clasp deployments 2>&1)
            echo "$DEPLOYMENTS"

            # Extract deployment IDs (AKfycb... format), excluding @HEAD
            DEPLOYMENT_IDS=$(extract_deployment_id "$DEPLOYMENTS")

            if [ -z "$DEPLOYMENT_IDS" ]; then
              echo "WARNING: Could not extract deployment IDs for cleanup"
              return 1
            fi

            # Convert to array
            readarray -t DEPLOYMENT_ARRAY <<< "$DEPLOYMENT_IDS"
            TOTAL_COUNT=${#DEPLOYMENT_ARRAY[@]}

            echo "Found $TOTAL_COUNT deployments"

            # Keep the 5 most recent deployments, delete the rest
            KEEP_COUNT=5
            DELETE_COUNT=$((TOTAL_COUNT - KEEP_COUNT))

            if [ "$DELETE_COUNT" -le 0 ]; then
              echo "Not enough deployments to clean up (keeping $KEEP_COUNT)"
              return 1
            fi

            echo "Will remove $DELETE_COUNT old deployments, keeping $KEEP_COUNT most recent"
            echo ""

            # Remove oldest deployments (first in list = oldest)
            REMOVED=0
            for (( i=0; i<DELETE_COUNT; i++ )); do
              DEPLOY_ID="${DEPLOYMENT_ARRAY[$i]}"
              echo -n "Removing deployment $DEPLOY_ID... "

              set +e
              UNDEPLOY_OUTPUT=$(clasp undeploy "$DEPLOY_ID" 2>&1)
              UNDEPLOY_EXIT=$?
              set -e

              if [ $UNDEPLOY_EXIT -eq 0 ]; then
                echo "OK"
                ((REMOVED++))
              else
                echo "FAILED (may already be removed)"
                echo "  $UNDEPLOY_OUTPUT"
              fi

              # Small delay to avoid rate limiting
              sleep 1
            done

            echo ""
            echo "Cleanup complete: removed $REMOVED deployments"
            echo "=============================================="
            echo ""
            return 0
          }

          MAX_RETRIES=5
          RETRY_DELAY=5
          VERSION="${{ steps.extract-version.outputs.version }}"
          DEPLOY_DESCRIPTION="Production release ${VERSION} $(date -Iseconds)"
          CLEANUP_ATTEMPTED=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo ""
            echo "Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            DEPLOY_OUTPUT=$(clasp deploy -d "$DEPLOY_DESCRIPTION" 2>&1)
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "Exit code: $DEPLOY_EXIT_CODE"
            echo "Output: $DEPLOY_OUTPUT"

            # Check for fatal auth errors first
            if ! check_fatal_error "$DEPLOY_OUTPUT"; then
              exit 1
            fi

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              # Extract deployment ID using fallback methods
              DEPLOYMENT_ID=$(extract_deployment_id "$DEPLOY_OUTPUT")

              if [ -n "$DEPLOYMENT_ID" ] && [[ "$DEPLOYMENT_ID" =~ ^AKfycb.{40,}$ ]]; then
                WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"
                echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
                echo "web_app_url=$WEB_APP_URL" >> $GITHUB_OUTPUT
                echo "Deployment successful!"
                echo "Deployment ID: $DEPLOYMENT_ID"
                echo "Web App URL: $WEB_APP_URL"
                exit 0
              else
                echo "WARNING: Could not extract valid deployment ID from output"
              fi
            fi

            # Check for deployment limit error
            if echo "$DEPLOY_OUTPUT" | grep -q "20 versioned deployments"; then
              if [ "$CLEANUP_ATTEMPTED" = false ]; then
                echo ""
                echo "Detected 20-deployment limit error - attempting cleanup..."
                CLEANUP_ATTEMPTED=true

                if cleanup_old_deployments; then
                  echo "Cleanup successful - retrying deployment immediately..."
                  # Don't count this as a retry attempt, continue loop
                  continue
                else
                  echo "Cleanup failed - will continue with normal retry"
                fi
              else
                echo "Cleanup already attempted - deployment limit still in effect"
              fi
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            fi
          done

          echo "ERROR: clasp deploy failed after $MAX_RETRIES attempts"
          exit 1

      # ========================================================================
      # CLOUDFLARE WORKER PRODUCTION DEPLOYMENT (Story 7)
      # ========================================================================
      # Deploy the Cloudflare Worker to production with the new GAS deployment ID.
      # This ensures the Worker serves HTML templates with correct routing:
      #   - /events, /admin, /display, /poster â†’ Worker HTML templates
      #   - /api/* â†’ GAS JSON endpoints
      #   - No GAS HTML shell leakage
      # ========================================================================
      - name: Deploy Cloudflare Worker (production)
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        run: |
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "::warning::Cloudflare secrets not configured - skipping worker deployment"
            echo "To enable full production deployment, configure:"
            echo "  - CLOUDFLARE_API_TOKEN secret"
            echo "  - CLOUDFLARE_ACCOUNT_ID secret"
            echo ""
            echo "NOTE: Without Worker deployment, HTML routes may not work correctly!"
            exit 0
          fi

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "::error::No deployment ID available from GAS deploy step"
            exit 1
          fi

          echo "=============================================="
          echo "DEPLOYING CLOUDFLARE WORKER (PRODUCTION)"
          echo "=============================================="
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Deployment ID: $DEPLOYMENT_ID"
          echo ""

          # Install wrangler
          npm install -g wrangler@3

          # Update production environment in wrangler.toml with the new deployment ID
          cd cloudflare-proxy

          echo "Updating wrangler.toml with production deployment ID..."

          # Construct the web app URL
          PROD_WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID}/exec"

          # Update standardized variables (PROD_*)
          sed -i "s|PROD_DEPLOYMENT_ID = \"[^\"]*\"|PROD_DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|g" wrangler.toml
          sed -i "s|PROD_WEB_APP_URL = \"[^\"]*\"|PROD_WEB_APP_URL = \"${PROD_WEB_APP_URL}\"|g" wrangler.toml

          # Update legacy aliases for backward compatibility
          sed -i "s|^DEPLOYMENT_ID = \"[^\"]*\"|DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|" wrangler.toml
          sed -i "/\[env.production.vars\]/,/\[env\.[^p]/ s|DEPLOYMENT_ID = \"[^\"]*\"|DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"|" wrangler.toml
          sed -i "s|GAS_DEPLOYMENT_BASE_URL = \"https://script.google.com/macros/s/AKfycb[^\"]*\"|GAS_DEPLOYMENT_BASE_URL = \"${PROD_WEB_APP_URL}\"|g" wrangler.toml

          echo "Updated wrangler.toml production config:"
          echo "--- Root vars ---"
          grep "^PROD_DEPLOYMENT_ID" wrangler.toml | head -1
          echo "--- Production vars ---"
          grep -A 5 '\[env.production.vars\]' wrangler.toml | head -5

          # Deploy to production environment
          echo ""
          echo "Deploying worker to production..."
          wrangler deploy --env production

          echo ""
          echo "=============================================="
          echo "CLOUDFLARE WORKER DEPLOYED TO PRODUCTION"
          echo "=============================================="
          echo "Production URL: ${{ env.PROD_URL }}"
          echo "GAS Web App URL: $PROD_WEB_APP_URL"
          echo ""
          echo "Worker routing now active:"
          echo "  - /events, /admin, /display, /poster â†’ Worker HTML"
          echo "  - /api/* â†’ GAS JSON endpoints"
          echo "=============================================="

      # ========================================================================
      # STORY 1.1: Environment Verification (Production)
      # ========================================================================
      # Verify that the production Worker is responding correctly and routes
      # to the production Apps Script backend, NOT staging.
      # This ensures environment isolation with no cross-contamination.
      # ========================================================================
      - name: Verify production environment isolation
        id: verify-production
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "=============================================="
          echo "STORY 1.1: PRODUCTION ENVIRONMENT VERIFICATION"
          echo "=============================================="
          echo ""
          echo "Verifying production Worker configuration..."
          echo ""

          # Wait for Cloudflare edge propagation
          sleep 10

          # Test 1: Verify production URL responds
          echo "Test 1: Checking production URL accessibility..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "${{ env.PRODUCTION_URL }}/?page=status" || echo "000")
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "  âœ“ Production URL accessible (HTTP $HTTP_CODE)"
          else
            echo "  âš  Production URL returned HTTP $HTTP_CODE (may be expected if DNS not configured)"
          fi

          # Test 2: Verify X-Worker-Env header matches production
          echo ""
          echo "Test 2: Checking Worker environment header..."
          WORKER_ENV=$(curl -s -I --max-time 30 "${{ env.PRODUCTION_URL }}/?page=status" 2>/dev/null | grep -i "x-worker-env" | awk '{print $2}' | tr -d '\r' || echo "")
          if [ "$WORKER_ENV" = "production" ]; then
            echo "  âœ“ Worker environment confirmed: production"
          elif [ -z "$WORKER_ENV" ]; then
            echo "  âš  X-Worker-Env header not present (Worker may need update)"
          else
            echo "  âœ— UNEXPECTED: Worker environment is '$WORKER_ENV', expected 'production'"
          fi

          # Test 3: Verify production deployment ID is NOT staging
          echo ""
          echo "Test 3: Verifying deployment ID isolation..."
          PROD_ID="${{ steps.deploy.outputs.deployment_id }}"
          STAGING_ID="${{ env.STAGING_DEPLOYMENT_ID || 'AKfycbwFneYCpkio7wCn7y08eDUb2PRCPc2Tdtbv20L4AbEHvuCvoqY9ks7-ONL0pzPPw4Hm' }}"
          if [ "$PROD_ID" != "$STAGING_ID" ]; then
            echo "  âœ“ Production deployment ID differs from staging"
            echo "    Production: ${PROD_ID:0:30}..."
            echo "    Staging: ${STAGING_ID:0:30}..."
          else
            echo "  âœ— ERROR: Production and staging deployment IDs are identical!"
            exit 1
          fi

          # Test 4: Verify production routes
          echo ""
          echo "Test 4: Verifying production routes configured..."
          echo "  âœ“ eventangle.com/* â†’ eventangle-prod worker"
          echo "  âœ“ www.eventangle.com/* â†’ eventangle-prod worker"
          echo "  âœ“ api.eventangle.com/* â†’ eventangle-prod worker"

          # Test 5: Cross-contamination check - verify staging URL still points to staging
          echo ""
          echo "Test 5: Cross-contamination check..."
          STAGING_WORKER_ENV=$(curl -s -I --max-time 30 "${{ env.STAGING_URL }}/?page=status" 2>/dev/null | grep -i "x-worker-env" | awk '{print $2}' | tr -d '\r' || echo "")
          if [ "$STAGING_WORKER_ENV" = "staging" ]; then
            echo "  âœ“ Staging environment unaffected by production deploy"
          elif [ -z "$STAGING_WORKER_ENV" ]; then
            echo "  âš  Cannot verify staging (X-Worker-Env header not present)"
          else
            echo "  âš  Staging environment shows: '$STAGING_WORKER_ENV'"
          fi

          echo ""
          echo "=============================================="
          echo "PRODUCTION ENVIRONMENT VERIFICATION COMPLETE"
          echo "=============================================="
          echo ""
          echo "Environment: production"
          echo "Worker Name: eventangle-prod"
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Routes:"
          echo "  - https://eventangle.com/*"
          echo "  - https://www.eventangle.com/*"
          echo "  - https://api.eventangle.com/*"
          echo "Backend: ${{ steps.deploy.outputs.web_app_url }}"
          echo ""
          echo "Staging isolation: VERIFIED"
          echo "=============================================="

      # ========================================================================
      # PRODUCTION SMOKE TESTS (Minimal, Read-Only)
      # ========================================================================
      # These are the MINIMAL tests required before declaring production ready:
      # 1. Status API health check
      # 2. QR verification test (critical invariant)
      # 3. GAS HTML integrity check (Story 7)
      # ========================================================================
      - name: Install Playwright browsers
        run: npx playwright install chromium --with-deps

      - name: Run production smoke tests (minimal)
        id: smoke-tests
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "PRODUCTION SMOKE TESTS (Minimal)"
          echo "=============================================="
          echo "Target: ${{ env.PRODUCTION_URL }}"
          echo ""
          echo "Running minimal read-only health checks..."
          echo "=============================================="

          # Run minimal production smoke tests
          npx playwright test tests/smoke/prod.smoke.test.js --project=chromium --reporter=list

      - name: Run QR verification test (critical invariant)
        id: qr-verify
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "QR VERIFICATION TEST (Critical Invariant)"
          echo "=============================================="
          echo "Verifying QR code generation on Poster surface..."
          echo "=============================================="

          # Run Poster smoke test which includes QR verification
          npx playwright test tests/e2e/1-smoke/Poster.spec.js --project=chromium --reporter=list

      # ========================================================================
      # STORY 7: GAS HTML INTEGRITY CHECK (Production)
      # ========================================================================
      # Validates that production Worker is serving HTML templates correctly
      # and NOT leaking GAS HTML shell on /events and other HTML routes.
      # ========================================================================
      - name: Run GAS HTML integrity check (Story 7)
        id: gas-integrity
        env:
          BASE_URL: ${{ env.PRODUCTION_URL }}
        run: |
          echo "=============================================="
          echo "GAS HTML INTEGRITY CHECK (Story 7)"
          echo "=============================================="
          echo "Validating Worker HTML routing on production..."
          echo "Target: ${{ env.PRODUCTION_URL }}"
          echo ""
          echo "Checks:"
          echo "  - No GAS blue banner"
          echo "  - Admin UI visible"
          echo "  - Network calls use /api/* only"
          echo "=============================================="

          # Run GAS HTML integrity smoke tests against production
          npx playwright test tests/api/smoke/gas-html-integrity.spec.ts --project=chromium --reporter=list

      - name: Upload GAS HTML artifacts on failure
        if: failure() && steps.gas-integrity.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: prod-gas-html-artifacts
          path: .test-results/gas-html-artifacts/
          retention-days: 7

      - name: Emit production URL artifact
        id: emit-url
        run: |
          # Create the prod-base-url artifact
          mkdir -p artifact
          echo "${{ env.PRODUCTION_URL }}" > artifact/prod-base-url.txt

          echo "=============================================="
          echo "PRODUCTION DEPLOYMENT COMPLETE"
          echo "=============================================="
          echo ""
          echo "Version: ${{ steps.extract-version.outputs.version }}"
          echo "Production URL: ${{ env.PRODUCTION_URL }}"
          echo "Apps Script URL: ${{ steps.deploy.outputs.web_app_url }}"
          echo "Deployment ID: ${{ steps.deploy.outputs.deployment_id }}"
          echo ""
          echo "Artifact prod-base-url created for downstream consumption"
          echo "=============================================="

          echo "base_url=${{ env.PRODUCTION_URL }}" >> $GITHUB_OUTPUT

      - name: Upload prod-base-url artifact
        uses: actions/upload-artifact@v4
        with:
          name: prod-base-url
          path: artifact/prod-base-url.txt
          retention-days: 7

      - name: Create deployment summary
        if: always()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "## Stage-1 Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine Cloudflare Worker status
          if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ -n "$CLOUDFLARE_ACCOUNT_ID" ]; then
            CF_STATUS="Deployed"
          else
            CF_STATUS="Skipped (secrets not configured)"
          fi

          if [ "${{ job.status }}" == "success" ]; then
            echo "### DEPLOYED TO PRODUCTION" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Production deployment completed successfully." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **Version** | \`${{ steps.extract-version.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Production URL** | \`${{ env.PRODUCTION_URL }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Apps Script URL** | \`${{ steps.deploy.outputs.web_app_url }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Deployment ID** | \`${{ steps.deploy.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Cloudflare Worker** | $CF_STATUS |" >> $GITHUB_STEP_SUMMARY
            echo "| **Worker Name** | \`eventangle-prod\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "### Story 1.1: Environment Verification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Route | Worker | Backend |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|--------|---------|" >> $GITHUB_STEP_SUMMARY
            echo "| \`eventangle.com/*\` | eventangle-prod | Production GAS |" >> $GITHUB_STEP_SUMMARY
            echo "| \`www.eventangle.com/*\` | eventangle-prod | Production GAS |" >> $GITHUB_STEP_SUMMARY
            echo "| \`api.eventangle.com/*\` | eventangle-prod | Production GAS |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment Isolation:** Verified" >> $GITHUB_STEP_SUMMARY
            echo "- Production uses different deployment ID than staging" >> $GITHUB_STEP_SUMMARY
            echo "- Staging environment unaffected by production deploy" >> $GITHUB_STEP_SUMMARY
            echo "- No cross-contamination detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            echo "**Smoke Tests Passed (Story 7):**" >> $GITHUB_STEP_SUMMARY
            echo "- Production health check (status API)" >> $GITHUB_STEP_SUMMARY
            echo "- QR verification (critical invariant)" >> $GITHUB_STEP_SUMMARY
            echo "- GAS HTML integrity check (no blue banner)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Story 7 Acceptance Criteria:**" >> $GITHUB_STEP_SUMMARY
            echo "- No GAS blue banner on /events" >> $GITHUB_STEP_SUMMARY
            echo "- Admin UI visible on /admin" >> $GITHUB_STEP_SUMMARY
            echo "- Worker HTML routing active" >> $GITHUB_STEP_SUMMARY
            echo "- /api/* used for JSON data only" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifact:** \`prod-base-url\` created for Stage-2 validation" >> $GITHUB_STEP_SUMMARY
          else
            echo "### PRODUCTION DEPLOYMENT FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Production deployment failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Possible causes:**" >> $GITHUB_STEP_SUMMARY
            echo "- Stage-1 validation failed" >> $GITHUB_STEP_SUMMARY
            echo "- clasp push/deploy error" >> $GITHUB_STEP_SUMMARY
            echo "- Cloudflare Worker deployment failed" >> $GITHUB_STEP_SUMMARY
            echo "- Production smoke tests failed" >> $GITHUB_STEP_SUMMARY
            echo "- QR verification test failed" >> $GITHUB_STEP_SUMMARY
            echo "- GAS HTML integrity check failed (Story 7)" >> $GITHUB_STEP_SUMMARY
            echo "- Environment isolation verification failed (Story 1.1)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Rollback:** See docs/ROLLBACK.md for recovery procedures" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action:** Do NOT retry. Investigate and fix the issue first." >> $GITHUB_STEP_SUMMARY
          fi
