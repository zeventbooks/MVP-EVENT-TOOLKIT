name: Stage 1 - Build & Deploy

on:
  push:
    branches:
      - main           # Deploy on main push (after PR merge)
      - 'release/**'   # Deploy on release branches
      - 'release/*'
  pull_request:
    branches: [ main ]  # Validate PRs before merge

# Prevent duplicate runs: cancel in-progress runs for the same PR/branch
concurrency:
  group: stage1-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # STAGE 1: BUILD, TEST & DEPLOY
  # ============================================================================
  # Local equivalent: npm run test:ci:stage1
  # Runs: lint && test:unit && test:contract
  # Stage 1 red â†’ DO NOT DEPLOY
  # ============================================================================

  lint:
    name: ðŸ” Code Quality (ESLint)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: |
          echo "ðŸ” Running ESLint to check code quality..."
          npm run lint
          echo "âœ… Linting passed! Code quality verified."

  unit-tests:
    name: âœ… Unit Tests (MVP Gate)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: |
          echo "â„¹ï¸ Running Jest unit tests (MVP Gate)"
          echo "ðŸ“‹ MVP Unit Test Coverage:"
          echo "   - template-service.test.js (applyTemplateToEvent_, sections, CTAs)"
          echo "   - validation.test.js (event data validation)"
          echo "   - forms.test.js (form template management)"
          echo "   - sponsor-utils.test.js (sponsor utilities)"
          echo "   - shared-reporting.test.js (analytics)"
          echo "   - security.test.js (auth, XSS, CSRF)"
          echo "   - multi-brand.test.js (brand isolation)"
          npm run test:unit

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  mvp-guards:
    name: ðŸ›¡ï¸ MVP Guards (Surface + Dead Export + V2 Files)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run MVP Surface Check
        run: |
          echo "ðŸ” Checking MVP surfaces..."
          echo "   Only 5 MVP surfaces allowed: admin, public, display, poster, report"
          echo ""
          node scripts/check-surfaces.js

      - name: Run Dead Export Check
        run: |
          echo "ðŸ” Checking for dead/zombie exports in Code.gs..."
          echo "   Unused api_* functions will fail the build"
          echo ""
          node scripts/check-dead-code.js --fail-on-dead

      - name: Run V2 File Check
        run: |
          echo "ðŸ” Checking for V2 files in src/mvp..."
          echo "   No V2 files allowed in MVP directory"
          echo ""
          node scripts/check-v2-files.js

  contract-tests:
    name: ðŸ“‹ Contract Tests (Schema Gate)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run contract tests
        run: |
          echo "â„¹ï¸ Running contract tests (validates API response structure & schema consistency)"
          echo ""
          echo "ðŸ“‹ Contract Test Coverage:"
          echo "   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "   ðŸ”’ SCHEMA CONSISTENCY (MVP Gate):"
          echo "      - schema-consistency.contract.test.js"
          echo "        â†’ Validates JSON schemas match ApiSchemas.gs"
          echo "        â†’ Validates Settings includes all template toggles"
          echo "        â†’ Cross-schema consistency (enums, surfaces)"
          echo ""
          echo "   ðŸ“„ TEMPLATE VALIDATION:"
          echo "      - template-flows.contract.test.js"
          echo "        â†’ Uses shared fixtures (templates.fixtures.js)"
          echo "        â†’ Custom template full schema access"
          echo "        â†’ Template â†’ Settings mapping"
          echo ""
          echo "   ðŸ”— API CONTRACTS:"
          echo "      - api.contract.test.js"
          echo "      - bundles.contract.test.js"
          echo "      - all-endpoints.contract.test.js"
          echo "      - jwt-security.contract.test.js"
          echo "   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          npm run test:contract

      - name: Verify schema consistency tests ran
        run: |
          echo "ðŸ” Verifying schema consistency tests exist and ran..."

          # Check that the schema consistency test file exists
          if [ ! -f "tests/contract/schema-consistency.contract.test.js" ]; then
            echo "âŒ ERROR: schema-consistency.contract.test.js not found!"
            echo "   This file is required to prevent schema drift."
            exit 1
          fi

          # Check that templates fixtures exist
          if [ ! -f "tests/shared/fixtures/templates.fixtures.js" ]; then
            echo "âŒ ERROR: templates.fixtures.js not found!"
            echo "   This file is required for template validation."
            exit 1
          fi

          echo "âœ… Schema consistency tests verified"
          echo "âœ… Template fixtures verified"

  # ============================================================================
  # CI:ALL GATE - Mandatory pre-deploy validation
  # ============================================================================
  # This job runs npm run ci:all which executes all contract guards:
  #   1. MVP Surfaces (check-surfaces.js)
  #   2. RPC Inventory (check-rpc-inventory.js)
  #   3. API vs Schemas (check-apis-vs-schemas.js)
  #   4. Event Schema (test-event-schema.js)
  #   5. Service Tests (test-services.js)
  #   6. Dead Exports (check-dead-code.js)
  #   7. Schema Fields (check-schema-fields.js)
  #   8. Analytics Schema (test-analytics-schema.js)
  # ============================================================================

  ci-all-gate:
    name: ðŸš¦ CI:ALL Gate (Pre-Deploy)
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, contract-tests, mvp-guards]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run CI:ALL Gate
        run: |
          echo "ðŸš¦ Running ci:all - Mandatory pre-deploy gate"
          echo ""
          echo "This gate runs ALL contract guards. Deployment is blocked if any fail."
          echo ""
          npm run ci:all

      - name: Create gate summary
        if: always()
        run: |
          echo "## ðŸš¦ CI:ALL Gate Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… GATE PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All contract guards passed. Deployment may proceed." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ GATE FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "One or more contract guards failed. **Deployment blocked.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Run locally: \`npm run ci:all:verbose\`" >> $GITHUB_STEP_SUMMARY
          fi

  deploy-to-apps-script:
    name: ðŸš€ Deploy to Apps Script API
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, contract-tests, mvp-guards, ci-all-gate]
    # MVP SRE Policy: Deploy only if Stage 1 passes AND push to main/release branches
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/'))
    outputs:
      deployment_url: ${{ steps.deploy.outputs.url }}
      root_url: ${{ steps.urls.outputs.root_url }}
      abc_url: ${{ steps.urls.outputs.abc_url }}
      cbc_url: ${{ steps.urls.outputs.cbc_url }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Validate deployment secrets
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "ðŸ” Validating deployment secrets..."

          # Check if OAUTH_CREDENTIALS is set
          if [ -z "$CLASPRC_JSON" ]; then
            echo "âŒ ERROR: OAUTH_CREDENTIALS secret not set"
            echo "Please configure the OAUTH_CREDENTIALS secret in GitHub repository settings"
            exit 1
          fi

          # Validate JSON structure
          if ! echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1; then
            echo "âŒ ERROR: Invalid OAUTH_CREDENTIALS format"
            echo "Expected JSON with .token.access_token field"
            exit 1
          fi

          # Check if refresh_token exists (required for token refresh)
          if ! echo "$CLASPRC_JSON" | jq -e '.token.refresh_token' > /dev/null 2>&1; then
            echo "âŒ ERROR: No refresh_token found in OAUTH_CREDENTIALS"
            echo "The refresh_token is required for clasp to refresh expired access tokens."
            echo ""
            echo "ðŸ“– To fix this, regenerate credentials with full scopes:"
            echo "   npx clasp login --no-localhost"
            echo "   cat ~/.clasprc.json"
            echo "   Then update the OAUTH_CREDENTIALS secret in GitHub"
            exit 1
          fi

          # Check token expiry if expiry_date is present
          EXPIRY_DATE=$(echo "$CLASPRC_JSON" | jq -r '.token.expiry_date // empty' 2>/dev/null)
          if [ -n "$EXPIRY_DATE" ]; then
            CURRENT_TIME=$(date +%s)000  # Current time in milliseconds
            if [ "$EXPIRY_DATE" -lt "$CURRENT_TIME" ]; then
              echo "âš ï¸  WARNING: Access token appears to be expired"
              echo "   Expiry: $EXPIRY_DATE, Current: $CURRENT_TIME"
              echo "   clasp should refresh the token using the refresh_token"
            fi
          fi

          echo "âœ… Secrets validation passed"

      # NOTE: Apps Script has a 200 version limit. The Apps Script API does NOT
      # support deleting versions programmatically - they can only be deleted
      # manually via the Google Apps Script web UI.
      #
      # When at the limit, this workflow uses a workaround: deploying with an
      # existing version (-V flag) instead of creating a new one. This updates
      # the deployment to point to the pushed code without creating a new version.
      #
      # To permanently fix: manually delete old versions at:
      # https://script.google.com/home/projects/YOUR_SCRIPT_ID/versions

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "ðŸ” Setting up clasp credentials..."
          echo "$CLASPRC_JSON" > ~/.clasprc.json
          chmod 600 ~/.clasprc.json

          # Pin clasp version for reproducibility
          echo "ðŸ“¦ Installing clasp@2.4.2 (pinned version)..."
          npm install -g @google/clasp@2.4.2

          # Log clasp version for debugging
          echo "ðŸ“‹ Clasp version: $(clasp --version 2>/dev/null || echo 'unknown')"

          # Validate clasprc.json format before proceeding
          echo "ðŸ” Validating credential format..."
          if ! jq -e '.token' ~/.clasprc.json > /dev/null 2>&1; then
            echo "âŒ ERROR: Invalid clasprc.json format - missing 'token' field"
            echo "ðŸ“‹ Debug: File structure (sensitive values redacted):"
            jq 'keys' ~/.clasprc.json 2>/dev/null || echo "   Could not parse JSON"
            exit 1
          fi

          # Check for required token fields
          echo "   Token fields present:"
          jq -r '.token | keys | .[]' ~/.clasprc.json 2>/dev/null | sed 's/^/     - /'

          # Show token expiry status
          EXPIRY_DATE=$(jq -r '.token.expiry_date // empty' ~/.clasprc.json 2>/dev/null)
          CURRENT_TIME=$(date +%s)000
          if [ -n "$EXPIRY_DATE" ]; then
            if [ "$EXPIRY_DATE" -lt "$CURRENT_TIME" ]; then
              echo "   âš ï¸ Access token is expired (will use refresh_token)"
              echo "   Token expiry: $EXPIRY_DATE"
              echo "   Current time: $CURRENT_TIME"
            else
              echo "   âœ… Access token is still valid"
            fi
          fi
          echo "âœ… Credentials configured"

      - name: Verify API authentication
        run: |
          echo "ðŸ” Pre-flight check: Verifying script access..."
          echo "   Testing API authentication with 'clasp list'..."

          # Retry logic for transient API failures
          MAX_RETRIES=4
          RETRY_DELAY=5

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "   Attempt $attempt of $MAX_RETRIES..."

            # Run clasp list and capture output and exit code separately
            set +e
            LIST_OUTPUT=$(clasp list 2>&1)
            LIST_EXIT_CODE=$?
            set -e

            echo "   Exit code: $LIST_EXIT_CODE"

            # Check exit code first
            if [ $LIST_EXIT_CODE -ne 0 ]; then
              echo "   âš ï¸ Command failed with exit code $LIST_EXIT_CODE"
              echo "   Output: $LIST_OUTPUT"

              # Check for specific error types
              if echo "$LIST_OUTPUT" | grep -qiE "invalid_grant|Token has been expired or revoked"; then
                echo ""
                echo "âŒ FATAL: Refresh token is invalid or revoked!"
                echo "   The OAuth credentials need to be regenerated."
                echo ""
                echo "ðŸ“– To fix this:"
                echo "   1. Run locally: npx clasp login"
                echo "   2. Copy ~/.clasprc.json contents"
                echo "   3. Update OAUTH_CREDENTIALS secret in GitHub"
                exit 1
              fi

              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "   Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              fi
            fi

            # Check for error messages in output even if exit code is 0
            if echo "$LIST_OUTPUT" | grep -qiE "(Error|unauthorized|invalid.*token|access.*denied|ECONNRESET|ETIMEDOUT|ENOTFOUND)"; then
              echo "   âš ï¸ Error pattern detected in output"
              echo "   Output: $LIST_OUTPUT"
              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "   Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              fi
            fi

            # Success!
            SCRIPT_COUNT=$(echo "$LIST_OUTPUT" | grep -c 'script.google.com' || echo "0")
            echo "   Found $SCRIPT_COUNT accessible script(s)"
            echo "âœ… API authentication verified"
            exit 0
          done

          # All retries failed
          echo ""
          echo "âŒ ERROR: Cannot authenticate with Google Apps Script API after $MAX_RETRIES attempts"
          echo ""
          echo "ðŸ“‹ Last output:"
          echo "$LIST_OUTPUT"
          echo ""
          echo "ðŸ“‹ Diagnostic information:"
          echo "   Script ID from .clasp.json: $(cat .clasp.json | jq -r '.scriptId' 2>/dev/null || echo 'could not read')"
          echo "   Token expiry_date: $(jq -r '.token.expiry_date // "not set"' ~/.clasprc.json 2>/dev/null)"
          echo "   Current timestamp (ms): $(date +%s)000"
          echo ""
          echo "ðŸ”§ Possible fixes:"
          echo "   1. OAuth token may have expired - regenerate OAUTH_CREDENTIALS secret"
          echo "   2. Script access may have been revoked - check Google Apps Script permissions"
          echo "   3. The refresh_token may have been invalidated"
          echo "   4. Network connectivity issues - check GitHub Actions status"
          echo ""
          echo "ðŸ“– To regenerate credentials locally:"
          echo "   npx clasp login"
          echo "   cat ~/.clasprc.json"
          echo "   Then update the OAUTH_CREDENTIALS secret in GitHub"
          exit 1

      - name: Push code to Apps Script
        run: |
          echo "ðŸš€ Pushing code to Apps Script..."
          echo ""
          echo "ðŸ“‹ Project info:"
          cat .clasp.json
          echo ""
          echo "ðŸ“‹ Files to push:"
          ls -la src/mvp/*.gs src/mvp/*.html 2>/dev/null | head -25
          echo ""
          echo "ðŸ“‹ Total project size:"
          du -sh src/mvp/
          echo ""

          MAX_RETRIES=4
          RETRY_DELAY=5

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "ðŸ“¤ Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "   Exit code: $PUSH_EXIT_CODE"
            echo "   Output:"
            echo "$PUSH_OUTPUT" | sed 's/^/   /'

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              # Check for error patterns in successful output
              if echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT|rate.?limit"; then
                echo "   âš ï¸ Error pattern detected despite exit code 0"
                if [ $attempt -lt $MAX_RETRIES ]; then
                  echo "   Retrying in ${RETRY_DELAY}s..."
                  sleep $RETRY_DELAY
                  RETRY_DELAY=$((RETRY_DELAY * 2))
                  continue
                fi
              else
                echo "âœ… Push successful!"
                exit 0
              fi
            else
              echo "   âš ï¸ Push failed with exit code $PUSH_EXIT_CODE"

              # Check for specific errors
              if echo "$PUSH_OUTPUT" | grep -qiE "invalid_grant|Token has been expired"; then
                echo "âŒ FATAL: Token expired during push"
                exit 1
              fi

              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "   Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              fi
            fi
          done

          echo ""
          echo "âŒ ERROR: clasp push failed after $MAX_RETRIES attempts"
          echo ""
          echo "ðŸ”§ Common causes:"
          echo "   1. Syntax error in .gs or .html files"
          echo "   2. File size exceeds Apps Script limits"
          echo "   3. OAuth token expired mid-operation"
          echo "   4. Google Apps Script API rate limiting"
          echo "   5. Invalid scriptId in .clasp.json"
          echo "   6. Network connectivity issues"
          exit 1

      - name: Check version count and prepare deployment strategy
        id: version_check
        run: |
          echo "ðŸ” Checking Apps Script version count..."
          echo ""
          echo "Google Apps Script has a 200 version limit. This step checks"
          echo "the current count and determines the deployment strategy."
          echo ""

          SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
          ACCESS_TOKEN=$(jq -r '.token.access_token' ~/.clasprc.json)

          # Refresh token if needed by running clasp command
          clasp list > /dev/null 2>&1 || true
          ACCESS_TOKEN=$(jq -r '.token.access_token' ~/.clasprc.json)

          echo "ðŸ“‹ Fetching current versions..."

          # Get all versions
          VERSIONS_RESPONSE=$(curl -s \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

          # Check for API errors
          if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "âš ï¸  Could not fetch versions (API error)"
            echo "   Will attempt normal deployment..."
            echo "use_existing_version=false" >> $GITHUB_OUTPUT
            echo "latest_version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
          echo "   Found $VERSION_COUNT version(s)"

          # Get the latest version number
          LATEST_VERSION=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | last | .versionNumber // empty')
          echo "   Latest version: $LATEST_VERSION"

          # If at or near the 200 limit, we need to use existing version
          if [ "$VERSION_COUNT" -ge 199 ]; then
            echo ""
            echo "âš ï¸  VERSION LIMIT REACHED ($VERSION_COUNT/200)"
            echo ""
            echo "The Apps Script API does NOT support deleting versions programmatically."
            echo "Versions can ONLY be deleted manually through the Google Apps Script UI."
            echo ""
            echo "ðŸ”„ WORKAROUND: Deploying using existing version $LATEST_VERSION"
            echo "   This updates the deployment to point to the latest pushed code"
            echo "   without creating a new version."
            echo ""
            echo "ðŸ“‹ TO PERMANENTLY FIX THIS:"
            echo "   1. Go to: https://script.google.com/home/projects/${SCRIPT_ID}/versions"
            echo "   2. Delete old versions (keep recent 20-50)"
            echo "   3. Future deployments will work normally"
            echo ""
            echo "use_existing_version=true" >> $GITHUB_OUTPUT
            echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          elif [ "$VERSION_COUNT" -ge 180 ]; then
            echo ""
            echo "âš ï¸  WARNING: Approaching version limit ($VERSION_COUNT/200)"
            echo "   Consider manual cleanup soon at:"
            echo "   https://script.google.com/home/projects/${SCRIPT_ID}/versions"
            echo ""
            echo "use_existing_version=false" >> $GITHUB_OUTPUT
            echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          else
            echo "âœ… Version count ($VERSION_COUNT) is healthy"
            echo "use_existing_version=false" >> $GITHUB_OUTPUT
            echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to Apps Script
        id: deploy
        env:
          DEPLOYMENT_ID: ${{ secrets.DEPLOYMENT_ID }}
          USE_EXISTING_VERSION: ${{ steps.version_check.outputs.use_existing_version }}
          LATEST_VERSION: ${{ steps.version_check.outputs.latest_version }}
        run: |
          echo "ðŸ“¦ Creating deployment..."

          MAX_RETRIES=4
          RETRY_DELAY=5
          DEPLOY_OUTPUT=""

          # Check if we need to use existing version (at 200 version limit)
          if [ "$USE_EXISTING_VERSION" == "true" ] && [ -n "$LATEST_VERSION" ]; then
            echo ""
            echo "ðŸ”„ VERSION LIMIT WORKAROUND ACTIVE"
            echo "   Using existing version $LATEST_VERSION instead of creating new version"
            echo ""
          fi

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "ðŸš€ Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            if [ "$USE_EXISTING_VERSION" == "true" ] && [ -n "$LATEST_VERSION" ]; then
              # At version limit: update deployment to point to existing version
              if [ -n "$DEPLOYMENT_ID" ]; then
                echo "   Updating deployment $DEPLOYMENT_ID to version $LATEST_VERSION (no new version created)"
                DEPLOY_OUTPUT=$(clasp deploy -V "$LATEST_VERSION" -i "$DEPLOYMENT_ID" -d "Stage 1 Deploy $(date -Iseconds) [v$LATEST_VERSION]" 2>&1)
              else
                echo "   Creating deployment using version $LATEST_VERSION"
                DEPLOY_OUTPUT=$(clasp deploy -V "$LATEST_VERSION" -d "Stage 1 Deploy $(date -Iseconds) [v$LATEST_VERSION]" 2>&1)
              fi
            else
              # Normal deployment: create new version
              if [ -n "$DEPLOYMENT_ID" ]; then
                echo "   Updating existing deployment: $DEPLOYMENT_ID"
                DEPLOY_OUTPUT=$(clasp deploy -i "$DEPLOYMENT_ID" -d "Stage 1 Deploy $(date -Iseconds)" 2>&1)
              else
                echo "   Creating new deployment (no DEPLOYMENT_ID secret set)"
                DEPLOY_OUTPUT=$(clasp deploy -d "Stage 1 Deploy $(date -Iseconds)" 2>&1)
              fi
            fi
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "   Exit code: $DEPLOY_EXIT_CODE"
            echo "   Output:"
            echo "$DEPLOY_OUTPUT" | sed 's/^/   /'

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              if ! echo "$DEPLOY_OUTPUT" | grep -qiE "^Error|failed|ECONNRESET|ETIMEDOUT"; then
                echo "âœ… Deployment successful!"
                break
              fi
            fi

            # Check for version limit error and provide guidance
            if echo "$DEPLOY_OUTPUT" | grep -qi "200 versions"; then
              SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
              echo ""
              echo "âŒ FATAL: Hit 200 version limit!"
              echo ""
              echo "ðŸ“‹ MANUAL ACTION REQUIRED:"
              echo "   1. Go to: https://script.google.com/home/projects/${SCRIPT_ID}/versions"
              echo "   2. Delete old versions (keep the 20-50 most recent)"
              echo "   3. Re-run this workflow"
              echo ""
              echo "Note: The Apps Script API does not support programmatic version deletion."
              echo "This must be done manually through the Google Apps Script web UI."
              exit 1
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "   Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            else
              echo ""
              echo "âŒ ERROR: clasp deploy failed after $MAX_RETRIES attempts"
              echo ""
              echo "ðŸ“‹ Listing current deployments for diagnostics..."
              clasp deployments 2>&1 || echo "   Could not list deployments"
              echo ""
              echo "ðŸ”§ Possible causes:"
              echo "   1. Invalid deployment ID - check DEPLOYMENT_ID secret"
              echo "   2. Deployment quota exceeded (max 20 deployments)"
              echo "   3. OAuth token issues"
              echo "   4. Version limit reached (max 200 versions)"
              exit 1
            fi
          done

          VERSION_ID=$(echo "$DEPLOY_OUTPUT" | grep -oP 'Created version \K\d+' || echo "$DEPLOY_OUTPUT" | grep -oP 'Updated deployment \K\w+' || echo "unknown")

          # Get the deployment ID and construct the web app URL
          echo "ðŸ“‹ Fetching deployment URL..."
          DEPLOYMENTS_OUTPUT=$(clasp deployments 2>&1)
          echo "$DEPLOYMENTS_OUTPUT"

          # Extract deployment ID from the deploy output first
          DEPLOYMENT_ID_FROM_OUTPUT=$(echo "$DEPLOY_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)

          # If not found in deploy output, try to get from deployments list
          if [ -z "$DEPLOYMENT_ID_FROM_OUTPUT" ]; then
            echo "Extracting deployment ID from deployments list..."
            DEPLOYMENT_ID_FROM_OUTPUT=$(echo "$DEPLOYMENTS_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)
          fi

          # Construct the Web App URL from the deployment ID
          if [ -n "$DEPLOYMENT_ID_FROM_OUTPUT" ]; then
            WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID_FROM_OUTPUT}/exec"
            echo "âœ… Found deployment ID: ${DEPLOYMENT_ID_FROM_OUTPUT}"
          else
            echo "âš ï¸ Warning: Could not extract deployment ID from deployments"
            echo "Please check clasp deployments manually"
            exit 1
          fi

          echo "url=$WEB_APP_URL" >> $GITHUB_OUTPUT
          echo "deployment_id=$DEPLOYMENT_ID_FROM_OUTPUT" >> $GITHUB_OUTPUT
          echo "âœ… Deployment complete! Base URL: $WEB_APP_URL"

      - name: Update Cloudflare Worker (Optional)
        if: success()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        run: |
          echo "â˜ï¸ Checking Cloudflare Worker configuration..."

          # Check if Cloudflare secrets are configured
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "â„¹ï¸ Cloudflare secrets not configured - skipping Worker update"
            echo "   To enable Cloudflare Workers, add these secrets:"
            echo "   - CLOUDFLARE_API_TOKEN"
            echo "   - CLOUDFLARE_ACCOUNT_ID"
            echo ""
            echo "   See: cloudflare-proxy/CLOUDFLARE_SETUP.md"
            exit 0
          fi

          echo "ðŸ”„ Updating Cloudflare Worker with new deployment ID..."

          # Update wrangler.toml with new deployment ID
          sed -i "s/DEPLOYMENT_ID = \"[^\"]*\"/DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"/" cloudflare-proxy/wrangler.toml

          # Also update the worker.js default
          sed -i "s/const DEFAULT_DEPLOYMENT_ID = '[^']*'/const DEFAULT_DEPLOYMENT_ID = '${DEPLOYMENT_ID}'/" cloudflare-proxy/worker.js

          # Install and deploy with Wrangler
          npm install -g wrangler

          cd cloudflare-proxy
          wrangler deploy

          echo ""
          echo "âœ… Cloudflare Worker updated!"
          echo "ðŸ”— Worker URL: https://eventangle.workers.dev/status"

      - name: Generate comprehensive brand URLs
        id: urls
        run: |
          APPS_SCRIPT_BASE="${{ steps.deploy.outputs.url }}"
          CLOUDFLARE_BASE="https://eventangle.com"

          # Brands: root, abc, cbc, cbl
          BRANDS=("root" "abc" "cbc" "cbl")

          # Friendly URL aliases (maps to pages internally)
          # events -> public page, manage -> admin page, etc.
          ALIASES=("status" "manage" "events" "display")

          echo ""
          echo "=============================================="
          echo "ðŸ“‹ DEPLOYMENT URLS - READY FOR TESTING"
          echo "=============================================="
          echo ""
          echo "ðŸš€ Apps Script Base URL:"
          echo "$APPS_SCRIPT_BASE"
          echo ""
          echo "ðŸŒ Cloudflare Base URL:"
          echo "$CLOUDFLARE_BASE"
          echo ""
          echo "=============================================="
          echo ""

          # Generate friendly URLs for each brand
          for brand in "${BRANDS[@]}"; do
            echo "ðŸŽ¯ Brand: ${brand^^}"
            echo "----------------------------------------"
            for alias in "${ALIASES[@]}"; do
              # Friendly URL format: /{alias} for root, /{brand}/{alias} for others
              if [ "$brand" == "root" ]; then
                FRIENDLY_PATH="/${alias}"
              else
                FRIENDLY_PATH="/${brand}/${alias}"
              fi

              APPS_URL="${APPS_SCRIPT_BASE}${FRIENDLY_PATH}"
              CF_URL="${CLOUDFLARE_BASE}${FRIENDLY_PATH}"

              echo "  ${alias}:"
              echo "    Apps Script: $APPS_URL"
              echo "    Cloudflare:  $CF_URL"
            done
            echo ""
          done

          echo "=============================================="
          echo "ðŸ’¡ Full clickable URLs available in Job Summary below"
          echo "=============================================="
          echo ""

          # Save primary URLs for backward compatibility with Stage 2
          echo "root_url=${APPS_SCRIPT_BASE}/events" >> $GITHUB_OUTPUT
          echo "abc_url=${APPS_SCRIPT_BASE}/abc/events" >> $GITHUB_OUTPUT
          echo "cbc_url=${APPS_SCRIPT_BASE}/cbc/events" >> $GITHUB_OUTPUT
          echo "cbl_url=${APPS_SCRIPT_BASE}/cbl/events" >> $GITHUB_OUTPUT

      - name: Save deployment URL for Stage 2
        run: |
          mkdir -p deployment-info
          # Use the Cloudflare friendly URL for Stage 2 testing
          # This ensures tests run against the production-ready endpoint
          CLOUDFLARE_URL="https://eventangle.com"
          echo "$CLOUDFLARE_URL" > deployment-info/deployment-url.txt
          echo "âœ… Saved Cloudflare URL for Stage 2 auto-trigger: $CLOUDFLARE_URL"
          echo ""
          echo "ðŸ“‹ Stage 2 will test against: $CLOUDFLARE_URL"
          echo "   (Apps Script URL also available: ${{ steps.deploy.outputs.url }})"

      - name: Upload deployment info artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: deployment-info/deployment-url.txt
          retention-days: 1

      - name: Create comprehensive deployment summary
        run: |
          APPS_SCRIPT_BASE="${{ steps.deploy.outputs.url }}"
          CLOUDFLARE_BASE="https://eventangle.com"

          echo "## ðŸš€ Stage 1 Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Quality Gates Passed" >> $GITHUB_STEP_SUMMARY
          echo "- Code Quality (ESLint)" >> $GITHUB_STEP_SUMMARY
          echo "- Unit Tests (Jest)" >> $GITHUB_STEP_SUMMARY
          echo "- Contract Tests" >> $GITHUB_STEP_SUMMARY
          echo "- MVP Guards (Surfaces + Dead Exports + V2 Files)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸŒ Comprehensive Test URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note:** Test both Apps Script and Cloudflare URLs to verify which works best for your use case." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Base Deployment URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | Base URL |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|----------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸš€ **Apps Script** | \`${APPS_SCRIPT_BASE}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŒ **Cloudflare** | \`${CLOUDFLARE_BASE}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Generate comprehensive URL tables for each brand
          BRANDS=("root" "abc" "cbc" "cbl")
          BRAND_NAMES=("ROOT (Eventangle)" "ABC (American Bocce Co.)" "CBC (Chicago Bocce Club)" "CBL (Chicago Bocce League)")

          for i in "${!BRANDS[@]}"; do
            brand="${BRANDS[$i]}"
            brand_name="${BRAND_NAMES[$i]}"

            # Build brand prefix for friendly URLs
            if [ "$brand" == "root" ]; then
              PREFIX=""
            else
              PREFIX="/${brand}"
            fi

            echo "### ðŸŽ¯ Brand: ${brand_name}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Page | Apps Script URL | Cloudflare URL |" >> $GITHUB_STEP_SUMMARY
            echo "|------|-----------------|---------------|" >> $GITHUB_STEP_SUMMARY

            # Status (friendly URL: /status or /{brand}/status)
            echo "| ðŸ” **Status** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/status) | [Test](${CLOUDFLARE_BASE}${PREFIX}/status) |" >> $GITHUB_STEP_SUMMARY

            # Manage/Admin (friendly URL: /manage or /{brand}/manage)
            echo "| âš™ï¸ **Manage** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/manage) | [Test](${CLOUDFLARE_BASE}${PREFIX}/manage) |" >> $GITHUB_STEP_SUMMARY

            # Events (friendly URL: /events or /{brand}/events)
            echo "| ðŸ“… **Events** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/events) | [Test](${CLOUDFLARE_BASE}${PREFIX}/events) |" >> $GITHUB_STEP_SUMMARY

            # Display (friendly URL: /display or /{brand}/display)
            echo "| ðŸ“º **Display** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/display) | [Test](${CLOUDFLARE_BASE}${PREFIX}/display) |" >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
          done

          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ’¡ Testing Instructions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **Status Page** (\`/status\`): Verify API health and connectivity" >> $GITHUB_STEP_SUMMARY
          echo "2. **Manage Page** (\`/manage\`): Test event management interface (requires admin key)" >> $GITHUB_STEP_SUMMARY
          echo "3. **Events Page** (\`/events\`): Test public event listing" >> $GITHUB_STEP_SUMMARY
          echo "4. **Display Page** (\`/display\`): Test TV/kiosk display mode" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š **Next Step**: Stage 2 will automatically run Playwright tests against these URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Quick Copy-Paste URLs (Friendly URLs)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Apps Script - Status Endpoints (API Health)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/status" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/abc/status" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbc/status" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbl/status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Cloudflare - Status Endpoints (API Health)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/status" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/abc/status" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbc/status" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbl/status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Apps Script - Manage Pages (Event Management)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/manage" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/abc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbl/manage" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Cloudflare - Manage Pages (Event Management)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/manage" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/abc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbl/manage" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ¤– **Stage 2 will auto-trigger in a few seconds!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cost-Optimized Progressive Testing Strategy:**" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Stage 1 Complete (ESLint + Jest Unit + Contract tests passed)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸš€ Stage 2 Starting automatically..." >> $GITHUB_STEP_SUMMARY
          echo "  - ðŸ”¥ **Critical Tests** (run first):" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright API Tests (validates REST endpoints)" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright Smoke Tests (validates critical user paths)" >> $GITHUB_STEP_SUMMARY
          echo "  - ðŸš¦ **Failure Gate**: Calculate failure rate" >> $GITHUB_STEP_SUMMARY
          echo "  - ðŸ’° **Expensive Tests** (only if failure rate < 50%):" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright Flow Tests (multi-step user workflows)" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright Page Tests (comprehensive page validation)" >> $GITHUB_STEP_SUMMARY
          echo "  - ðŸŽ¯ **Quality Gate**: All tests must pass" >> $GITHUB_STEP_SUMMARY
          echo "  - ðŸš€ **QA Deployment**: Deploy to QA environment if approved" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the **Actions** tab to monitor Stage 2 progress." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
