name: Stage 1 - Build & Deploy

on:
  push:
    branches:
      - main           # Deploy to STAGING on main push
      - 'release/**'   # Deploy to STAGING on release branches
      - 'release/*'
  pull_request:
    branches: [ main ]  # Validate PRs (no deploy)

  # Manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_tests:
        description: 'Skip quality gate tests (emergency deploy only)'
        required: false
        type: boolean
        default: false

# Prevent duplicate runs: cancel in-progress runs for the same PR/branch
concurrency:
  group: stage1-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Environment configuration
env:
  # Script IDs - zeventbook@gmail.com owned
  STAGING_SCRIPT_ID: '1gHiPuj7eXNk09dDyk17SJ6QsCJg7LMqXBRrkowljL3z2TaAKFIvBLhHJ'
  PRODUCTION_SCRIPT_ID: '1YO4apLOQoAIh208AcAqWO3pWtx_O3yas_QC4z-pkurgMem9UgYOsp86l'
  # URLs
  STAGING_URL: 'https://stg.eventangle.com'
  PRODUCTION_URL: 'https://eventangle.com'

jobs:
  # ============================================================================
  # ENVIRONMENT DETERMINATION
  # ============================================================================
  # Determines target environment: staging (default) or production (opt-in)
  # - Push to main/release â†’ STAGING
  # - workflow_dispatch â†’ User choice (default: staging)
  # ============================================================================
  determine-environment:
    name: ğŸ¯ Determine Target Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      script_id: ${{ steps.env.outputs.script_id }}
      base_url: ${{ steps.env.outputs.base_url }}
      is_production: ${{ steps.env.outputs.is_production }}
    steps:
      - name: Determine environment
        id: env
        run: |
          echo "=================================================="
          echo "ğŸ¯ Environment Selection"
          echo "=================================================="
          echo ""

          # Default to staging
          ENVIRONMENT="staging"
          SCRIPT_ID="${{ env.STAGING_SCRIPT_ID }}"
          BASE_URL="${{ env.STAGING_URL }}"
          IS_PRODUCTION="false"

          # Check if this is a manual trigger with production selected
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ inputs.environment }}" == "production" ]]; then
              ENVIRONMENT="production"
              SCRIPT_ID="${{ env.PRODUCTION_SCRIPT_ID }}"
              BASE_URL="${{ env.PRODUCTION_URL }}"
              IS_PRODUCTION="true"
              echo "âš ï¸  PRODUCTION DEPLOYMENT REQUESTED"
              echo "   This will deploy to the live production environment!"
            else
              echo "ğŸ“‹ Manual trigger: STAGING selected"
            fi
          else
            echo "ğŸ“‹ Automatic trigger: defaulting to STAGING"
          fi

          echo ""
          echo "Environment: $ENVIRONMENT"
          echo "Script ID: $SCRIPT_ID"
          echo "Base URL: $BASE_URL"
          echo ""
          echo "=================================================="

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "script_id=$SCRIPT_ID" >> $GITHUB_OUTPUT
          echo "base_url=$BASE_URL" >> $GITHUB_OUTPUT
          echo "is_production=$IS_PRODUCTION" >> $GITHUB_OUTPUT

  # ============================================================================
  # STAGE 1: BUILD, TEST & DEPLOY
  # ============================================================================
  #
  # CANONICAL LOCAL EQUIVALENT: npm run test:ci:stage1
  #
  # This is the single source of truth for Stage 1 validation.
  # Stage 1 is HERMETIC: tests + GAS deploy only. No BASE_URL, no HTTP calls.
  #
  # DEFAULT: Deploy to STAGING
  # PRODUCTION: Only via workflow_dispatch with explicit selection
  #
  # Components (env-agnostic - zero external HTTP dependencies):
  #   - lint          â†’ ESLint code quality
  #   - test:unit     â†’ Jest unit tests (mocked, no network)
  #   - test:contract â†’ Contract tests (schema, API, bundles - all local)
  #   - check:guards  â†’ Surface, dead-code, schema-fields, API-schema checks
  #   - deploy        â†’ Apps Script deploy + URL artifact (for Stage 2)
  #
  # Stage 1 red â†’ DO NOT DEPLOY
  # ============================================================================

  lint:
    name: ğŸ” Code Quality (ESLint)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # ========================================================================
      # HERMETIC GUARD: Stage 1 must have zero BASE_URL dependency
      # Story B: Ensures Stage 1 cannot be broken by staging/prod DNS or CF issues
      # ========================================================================
      - name: ğŸ”’ Verify Stage 1 is hermetic (no BASE_URL)
        run: |
          if [ -n "$BASE_URL" ]; then
            echo "âŒ ERROR: BASE_URL is set in Stage 1!"
            echo ""
            echo "Stage 1 must be hermetic - it cannot depend on external URLs."
            echo "BASE_URL should only be used in Stage 2 (post-deploy validation)."
            echo ""
            echo "Found BASE_URL: $BASE_URL"
            echo ""
            echo "Please remove BASE_URL from this workflow or environment."
            exit 1
          fi
          echo "âœ… Stage 1 is hermetic: no BASE_URL dependency"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: |
          echo "ğŸ” Running ESLint to check code quality..."
          npm run lint
          echo "âœ… Linting passed! Code quality verified."

  unit-tests:
    name: âœ… Unit Tests (MVP Gate)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: |
          echo "â„¹ï¸ Running Jest unit tests (MVP Gate)"
          echo "ğŸ“‹ MVP Unit Test Coverage:"
          echo "   - template-service.test.js (applyTemplateToEvent_, sections, CTAs)"
          echo "   - validation.test.js (event data validation)"
          echo "   - forms.test.js (form template management)"
          echo "   - sponsor-utils.test.js (sponsor utilities)"
          echo "   - shared-reporting.test.js (analytics)"
          echo "   - security.test.js (auth, XSS, CSRF)"
          echo "   - multi-brand.test.js (brand isolation)"
          npm run test:unit

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  mvp-guards:
    name: ğŸ›¡ï¸ MVP Guards (Surface + Dead Export + V2 Files)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run MVP Surface Check
        run: |
          echo "ğŸ” Checking MVP surfaces..."
          echo "   Only 5 MVP surfaces allowed: admin, public, display, poster, report"
          echo ""
          node scripts/check-surfaces.js

      - name: Run Dead Export Check
        run: |
          echo "ğŸ” Checking for dead/zombie exports in Code.gs..."
          echo "   Unused api_* functions will fail the build"
          echo ""
          node scripts/check-dead-code.js --fail-on-dead

      - name: Run V2 File Check
        run: |
          echo "ğŸ” Checking for V2 files in src/mvp..."
          echo "   No V2 files allowed in MVP directory"
          echo ""
          node scripts/check-v2-files.js

  contract-tests:
    name: ğŸ“‹ Contract Tests (Schema Gate)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run contract tests
        run: |
          echo "â„¹ï¸ Running contract tests (validates API response structure & schema consistency)"
          echo ""
          echo "ğŸ“‹ Contract Test Coverage:"
          echo "   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "   ğŸ”’ SCHEMA CONSISTENCY (MVP Gate):"
          echo "      - schema-consistency.contract.test.js"
          echo "        â†’ Validates JSON schemas match ApiSchemas.gs"
          echo "        â†’ Validates Settings includes all template toggles"
          echo "        â†’ Cross-schema consistency (enums, surfaces)"
          echo ""
          echo "   ğŸ“„ TEMPLATE VALIDATION:"
          echo "      - template-flows.contract.test.js"
          echo "        â†’ Uses shared fixtures (templates.fixtures.js)"
          echo "        â†’ Custom template full schema access"
          echo "        â†’ Template â†’ Settings mapping"
          echo ""
          echo "   ğŸ”— API CONTRACTS:"
          echo "      - api.contract.test.js"
          echo "      - bundles.contract.test.js"
          echo "      - all-endpoints.contract.test.js"
          echo "      - jwt-security.contract.test.js"
          echo "   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          npm run test:contract

      - name: Verify schema consistency tests ran
        run: |
          echo "ğŸ” Verifying schema consistency tests exist and ran..."

          # Check that the schema consistency test file exists
          if [ ! -f "tests/contract/schema-consistency.contract.test.js" ]; then
            echo "âŒ ERROR: schema-consistency.contract.test.js not found!"
            echo "   This file is required to prevent schema drift."
            exit 1
          fi

          # Check that templates fixtures exist
          if [ ! -f "tests/shared/fixtures/templates.fixtures.js" ]; then
            echo "âŒ ERROR: templates.fixtures.js not found!"
            echo "   This file is required for template validation."
            exit 1
          fi

          echo "âœ… Schema consistency tests verified"
          echo "âœ… Template fixtures verified"

  # ============================================================================
  # CI:ALL GATE - Mandatory pre-deploy validation
  # ============================================================================
  # This job runs npm run ci:all which executes all contract guards:
  #   1. MVP Surfaces (check-surfaces.js)
  #   2. RPC Inventory (check-rpc-inventory.js)
  #   3. API vs Schemas (check-apis-vs-schemas.js)
  #   4. Event Schema (test-event-schema.js)
  #   5. Service Tests (test-services.js)
  #   6. Dead Exports (check-dead-code.js)
  #   7. Schema Fields (check-schema-fields.js)
  #   8. Analytics Schema (test-analytics-schema.js)
  # ============================================================================

  ci-all-gate:
    name: ğŸš¦ CI:ALL Gate (Pre-Deploy)
    runs-on: ubuntu-latest
    needs: [lint, unit-tests, contract-tests, mvp-guards]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run CI:ALL Gate
        run: |
          echo "ğŸš¦ Running ci:all - Mandatory pre-deploy gate"
          echo ""
          echo "This gate runs ALL contract guards. Deployment is blocked if any fail."
          echo ""
          npm run ci:all

      - name: Create gate summary
        if: always()
        run: |
          echo "## ğŸš¦ CI:ALL Gate Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… GATE PASSED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All contract guards passed. Deployment may proceed." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ GATE FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "One or more contract guards failed. **Deployment blocked.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Run locally: \`npm run ci:all:verbose\`" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # DEPLOY JOB: Apps Script Deploy (Staging or Production)
  # ============================================================================
  # PURPOSE:
  #   1. Push code to Google Apps Script (GAS)
  #   2. Create/update GAS web app deployment
  #   3. Produce URL artifact for Stage 2
  #
  # DEFAULT: Deploy to STAGING
  # PRODUCTION: Only via workflow_dispatch with explicit selection
  #
  # IMPORTANT:
  #   - This job does NOT make HTTP calls to validate the deployment
  #   - Stage 1 correctness is determined by LOCAL tests (lint, unit, contract)
  #   - The URL artifact (deployment-url.txt) is consumed by Stage 2
  #   - Stage 2 performs POST-DEPLOY HTTP validation, not Stage 1
  # ============================================================================
  deploy-to-apps-script:
    name: ğŸš€ Deploy to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, lint, unit-tests, contract-tests, mvp-guards, ci-all-gate]
    # Deploy on push to main/release OR on manual workflow_dispatch
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/'))) ||
      github.event_name == 'workflow_dispatch'
    env:
      TARGET_ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      TARGET_SCRIPT_ID: ${{ needs.determine-environment.outputs.script_id }}
      TARGET_BASE_URL: ${{ needs.determine-environment.outputs.base_url }}
      IS_PRODUCTION: ${{ needs.determine-environment.outputs.is_production }}
    outputs:
      deployment_url: ${{ steps.deploy.outputs.url }}
      environment: ${{ needs.determine-environment.outputs.environment }}
      base_url: ${{ needs.determine-environment.outputs.base_url }}
      root_url: ${{ steps.urls.outputs.root_url }}
      abc_url: ${{ steps.urls.outputs.abc_url }}
      cbc_url: ${{ steps.urls.outputs.cbc_url }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Validate deployment secrets
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "ğŸ” Validating deployment secrets..."

          # Check if OAUTH_CREDENTIALS is set
          if [ -z "$CLASPRC_JSON" ]; then
            echo "âŒ ERROR: OAUTH_CREDENTIALS secret not set"
            echo "Please configure the OAUTH_CREDENTIALS secret in GitHub repository settings"
            exit 1
          fi

          # First check if it's valid JSON at all
          if ! echo "$CLASPRC_JSON" | jq -e '.' > /dev/null 2>&1; then
            echo "âŒ ERROR: OAUTH_CREDENTIALS is not valid JSON"
            echo ""
            echo "ğŸ“‹ Expected format (clasp OAuth credentials):"
            echo '   {"token": {"access_token": "...", "refresh_token": "...", ...}}'
            echo ""
            echo "ğŸ“– To get the correct format:"
            echo "   1. Run locally: npx clasp login"
            echo "   2. Copy contents of ~/.clasprc.json"
            echo "   3. Update OAUTH_CREDENTIALS secret in GitHub"
            exit 1
          fi

          # Show structure for debugging (keys only, no sensitive values)
          echo "ğŸ“‹ Credential structure detected:"
          echo "$CLASPRC_JSON" | jq -r 'keys | .[]' 2>/dev/null | sed 's/^/   - /'

          # Validate JSON structure - support both legacy and new clasp formats
          # Legacy format: {"token": {"access_token": "...", "refresh_token": "..."}}
          # New format: {"tokens": {"default": {"access_token": "...", "refresh_token": "..."}}}

          HAS_LEGACY_TOKEN=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW_TOKEN=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY_TOKEN" = "false" ] && [ "$HAS_NEW_TOKEN" = "false" ]; then
            echo ""
            echo "âŒ ERROR: Missing access_token in OAUTH_CREDENTIALS"
            echo ""
            echo "ğŸ“‹ Expected formats (clasp OAuth credentials):"
            echo '   Legacy: {"token": {"access_token": "...", "refresh_token": "...", ...}}'
            echo '   New:    {"tokens": {"default": {"access_token": "...", "refresh_token": "...", ...}}}'
            echo ""
            echo "ğŸ“‹ Your credential has these top-level keys:"
            echo "$CLASPRC_JSON" | jq -r 'keys | .[]' 2>/dev/null | sed 's/^/   - /'
            echo ""
            echo "ğŸ“– To fix this:"
            echo "   1. Run locally: npx clasp login"
            echo "   2. Copy the ENTIRE contents of ~/.clasprc.json"
            echo "   3. Update OAUTH_CREDENTIALS secret in GitHub"
            exit 1
          fi

          # Determine which format is being used and set variables for later checks
          if [ "$HAS_NEW_TOKEN" = "true" ]; then
            echo "âœ… Detected NEW clasp credential format (tokens.default)"
            TOKEN_PATH=".tokens.default"
          else
            echo "âœ… Detected LEGACY clasp credential format (token)"
            TOKEN_PATH=".token"
          fi

          echo "âœ… JSON structure validated (access_token present)"

          # Check if refresh_token exists (required for token refresh)
          if ! echo "$CLASPRC_JSON" | jq -e "${TOKEN_PATH}.refresh_token" > /dev/null 2>&1; then
            echo "âŒ ERROR: No refresh_token found in OAUTH_CREDENTIALS"
            echo "The refresh_token is required for clasp to refresh expired access tokens."
            echo ""
            echo "ğŸ“– To fix this, regenerate credentials with full scopes:"
            echo "   npx clasp login --no-localhost"
            echo "   cat ~/.clasprc.json"
            echo "   Then update the OAUTH_CREDENTIALS secret in GitHub"
            exit 1
          fi

          # Check token expiry if expiry_date is present
          EXPIRY_DATE=$(echo "$CLASPRC_JSON" | jq -r "${TOKEN_PATH}.expiry_date // empty" 2>/dev/null)
          if [ -n "$EXPIRY_DATE" ]; then
            CURRENT_TIME=$(date +%s)000  # Current time in milliseconds
            if [ "$EXPIRY_DATE" -lt "$CURRENT_TIME" ]; then
              echo "âš ï¸  WARNING: Access token appears to be expired"
              echo "   Expiry: $EXPIRY_DATE, Current: $CURRENT_TIME"
              echo "   clasp should refresh the token using the refresh_token"
            fi
          fi

          echo "âœ… Secrets validation passed"

      # NOTE: Apps Script has a 200 version limit. The Apps Script API does NOT
      # support deleting versions programmatically - they can only be deleted
      # manually via the Google Apps Script web UI.
      #
      # When at the limit, this workflow uses a workaround: deploying with an
      # existing version (-V flag) instead of creating a new one. This updates
      # the deployment to point to the pushed code without creating a new version.
      #
      # To permanently fix: manually delete old versions at:
      # https://script.google.com/home/projects/YOUR_SCRIPT_ID/versions

      - name: Setup clasp credentials
        env:
          CLASPRC_JSON: ${{ secrets.OAUTH_CREDENTIALS }}
        run: |
          echo "ğŸ” Setting up clasp credentials..."

          # Pin clasp version for reproducibility
          echo "ğŸ“¦ Installing clasp@2.4.2 (pinned version)..."
          npm install -g @google/clasp@2.4.2

          # Log clasp version for debugging
          echo "ğŸ“‹ Clasp version: $(clasp --version 2>/dev/null || echo 'unknown')"

          # Validate and convert credential format
          # clasp 2.4.2 ONLY supports the legacy format: {"token": {...}}
          # New clasp format is: {"tokens": {"default": {...}}}
          # We must convert new format to legacy format for clasp 2.4.2 to work
          echo "ğŸ” Checking credential format..."

          HAS_LEGACY=$(echo "$CLASPRC_JSON" | jq -e '.token.access_token' > /dev/null 2>&1 && echo "true" || echo "false")
          HAS_NEW=$(echo "$CLASPRC_JSON" | jq -e '.tokens.default.access_token' > /dev/null 2>&1 && echo "true" || echo "false")

          if [ "$HAS_LEGACY" = "false" ] && [ "$HAS_NEW" = "false" ]; then
            echo "âŒ ERROR: Invalid credential format - no valid token structure found"
            echo "ğŸ“‹ Debug: JSON structure (sensitive values redacted):"
            echo "$CLASPRC_JSON" | jq 'keys' 2>/dev/null || echo "   Could not parse JSON"
            exit 1
          fi

          # Convert new format to legacy format that clasp 2.4.2 understands
          if [ "$HAS_NEW" = "true" ]; then
            echo "   Detected NEW clasp format (tokens.default)"
            echo "   ğŸ”„ Converting to legacy format for clasp 2.4.2 compatibility..."

            # Extract the token object from new format and create legacy format
            CONVERTED_JSON=$(echo "$CLASPRC_JSON" | jq '{token: .tokens.default}')

            if ! echo "$CONVERTED_JSON" | jq -e '.token.access_token' > /dev/null 2>&1; then
              echo "âŒ ERROR: Conversion failed - could not extract token"
              exit 1
            fi

            echo "$CONVERTED_JSON" > ~/.clasprc.json
            echo "   âœ… Converted to legacy format"
            TOKEN_PATH=".token"
          else
            echo "   Using LEGACY clasp format (token) - no conversion needed"
            echo "$CLASPRC_JSON" > ~/.clasprc.json
            TOKEN_PATH=".token"
          fi

          chmod 600 ~/.clasprc.json

          # Check for required token fields
          echo "   Token fields present:"
          jq -r "${TOKEN_PATH} | keys | .[]" ~/.clasprc.json 2>/dev/null | sed 's/^/     - /'

          # Show token expiry status
          EXPIRY_DATE=$(jq -r "${TOKEN_PATH}.expiry_date // empty" ~/.clasprc.json 2>/dev/null)
          CURRENT_TIME=$(date +%s)000
          if [ -n "$EXPIRY_DATE" ]; then
            if [ "$EXPIRY_DATE" -lt "$CURRENT_TIME" ]; then
              echo "   âš ï¸ Access token is expired (will use refresh_token)"
              echo "   Token expiry: $EXPIRY_DATE"
              echo "   Current time: $CURRENT_TIME"
            else
              echo "   âœ… Access token is still valid"
            fi
          fi
          echo "âœ… Credentials configured"

      - name: Configure target Script ID
        run: |
          echo "ğŸ¯ Configuring deployment target..."
          echo ""
          echo "   Environment: $TARGET_ENVIRONMENT"
          echo "   Script ID: $TARGET_SCRIPT_ID"
          echo ""

          # Update .clasp.json with the target Script ID
          jq --arg scriptId "$TARGET_SCRIPT_ID" '.scriptId = $scriptId' .clasp.json > .clasp.json.tmp
          mv .clasp.json.tmp .clasp.json

          echo "ğŸ“‹ Updated .clasp.json:"
          cat .clasp.json

          echo ""
          if [ "$IS_PRODUCTION" == "true" ]; then
            echo "âš ï¸  DEPLOYING TO PRODUCTION"
          else
            echo "ğŸ“‹ Deploying to staging (default)"
          fi

      - name: Verify API authentication
        run: |
          echo "ğŸ” Pre-flight check: Verifying script access..."
          echo "   Testing API authentication with 'clasp list'..."

          # Retry logic for transient API failures
          MAX_RETRIES=4
          RETRY_DELAY=5

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "   Attempt $attempt of $MAX_RETRIES..."

            # Run clasp list and capture output and exit code separately
            set +e
            LIST_OUTPUT=$(clasp list 2>&1)
            LIST_EXIT_CODE=$?
            set -e

            echo "   Exit code: $LIST_EXIT_CODE"

            # Check exit code first
            if [ $LIST_EXIT_CODE -ne 0 ]; then
              echo "   âš ï¸ Command failed with exit code $LIST_EXIT_CODE"
              echo "   Output: $LIST_OUTPUT"

              # Check for specific error types
              if echo "$LIST_OUTPUT" | grep -qiE "invalid_grant|Token has been expired or revoked"; then
                echo ""
                echo "âŒ FATAL: Refresh token is invalid or revoked!"
                echo "   The OAuth credentials need to be regenerated."
                echo ""
                echo "ğŸ“– To fix this:"
                echo "   1. Run locally: npx clasp login"
                echo "   2. Copy ~/.clasprc.json contents"
                echo "   3. Update OAUTH_CREDENTIALS secret in GitHub"
                exit 1
              fi

              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "   Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              fi
            fi

            # Check for error messages in output even if exit code is 0
            if echo "$LIST_OUTPUT" | grep -qiE "(Error|unauthorized|invalid.*token|access.*denied|ECONNRESET|ETIMEDOUT|ENOTFOUND)"; then
              echo "   âš ï¸ Error pattern detected in output"
              echo "   Output: $LIST_OUTPUT"
              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "   Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              fi
            fi

            # Success!
            SCRIPT_COUNT=$(echo "$LIST_OUTPUT" | grep -c 'script.google.com' || echo "0")
            echo "   Found $SCRIPT_COUNT accessible script(s)"
            echo "âœ… API authentication verified"
            exit 0
          done

          # All retries failed
          echo ""
          echo "âŒ ERROR: Cannot authenticate with Google Apps Script API after $MAX_RETRIES attempts"
          echo ""
          echo "ğŸ“‹ Last output:"
          echo "$LIST_OUTPUT"
          echo ""
          echo "ğŸ“‹ Diagnostic information:"
          echo "   Script ID from .clasp.json: $(cat .clasp.json | jq -r '.scriptId' 2>/dev/null || echo 'could not read')"
          echo "   Token expiry_date: $(jq -r '.token.expiry_date // "not set"' ~/.clasprc.json 2>/dev/null)"
          echo "   Current timestamp (ms): $(date +%s)000"
          echo ""
          echo "ğŸ”§ Possible fixes:"
          echo "   1. OAuth token may have expired - regenerate OAUTH_CREDENTIALS secret"
          echo "   2. Script access may have been revoked - check Google Apps Script permissions"
          echo "   3. The refresh_token may have been invalidated"
          echo "   4. Network connectivity issues - check GitHub Actions status"
          echo ""
          echo "ğŸ“– To regenerate credentials locally:"
          echo "   npx clasp login"
          echo "   cat ~/.clasprc.json"
          echo "   Then update the OAUTH_CREDENTIALS secret in GitHub"
          exit 1

      - name: Push code to Apps Script
        run: |
          echo "ğŸš€ Pushing code to Apps Script..."
          echo ""
          echo "ğŸ“‹ Project info:"
          cat .clasp.json
          echo ""
          echo "ğŸ“‹ Files to push:"
          ls -la src/mvp/*.gs src/mvp/*.html 2>/dev/null | head -25
          echo ""
          echo "ğŸ“‹ Total project size:"
          du -sh src/mvp/
          echo ""

          MAX_RETRIES=4
          RETRY_DELAY=5

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "ğŸ“¤ Push attempt $attempt of $MAX_RETRIES..."

            set +e
            PUSH_OUTPUT=$(clasp push --force 2>&1)
            PUSH_EXIT_CODE=$?
            set -e

            echo "   Exit code: $PUSH_EXIT_CODE"
            echo "   Output:"
            echo "$PUSH_OUTPUT" | sed 's/^/   /'

            if [ $PUSH_EXIT_CODE -eq 0 ]; then
              # Check for error patterns in successful output
              if echo "$PUSH_OUTPUT" | grep -qiE "^Error|failed to|ECONNRESET|ETIMEDOUT|rate.?limit"; then
                echo "   âš ï¸ Error pattern detected despite exit code 0"
                if [ $attempt -lt $MAX_RETRIES ]; then
                  echo "   Retrying in ${RETRY_DELAY}s..."
                  sleep $RETRY_DELAY
                  RETRY_DELAY=$((RETRY_DELAY * 2))
                  continue
                fi
              else
                echo "âœ… Push successful!"
                exit 0
              fi
            else
              echo "   âš ï¸ Push failed with exit code $PUSH_EXIT_CODE"

              # Check for specific errors
              if echo "$PUSH_OUTPUT" | grep -qiE "invalid_grant|Token has been expired"; then
                echo "âŒ FATAL: Token expired during push"
                exit 1
              fi

              if [ $attempt -lt $MAX_RETRIES ]; then
                echo "   Retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
                continue
              fi
            fi
          done

          echo ""
          echo "âŒ ERROR: clasp push failed after $MAX_RETRIES attempts"
          echo ""
          echo "ğŸ”§ Common causes:"
          echo "   1. Syntax error in .gs or .html files"
          echo "   2. File size exceeds Apps Script limits"
          echo "   3. OAuth token expired mid-operation"
          echo "   4. Google Apps Script API rate limiting"
          echo "   5. Invalid scriptId in .clasp.json"
          echo "   6. Network connectivity issues"
          exit 1

      - name: Check version count and prepare deployment strategy
        id: version_check
        run: |
          echo "ğŸ” Checking Apps Script version count..."
          echo ""
          echo "Google Apps Script has a 200 version limit. This step checks"
          echo "the current count and determines the deployment strategy."
          echo ""

          SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
          ACCESS_TOKEN=$(jq -r '.token.access_token' ~/.clasprc.json)

          # Refresh token if needed by running clasp command
          clasp list > /dev/null 2>&1 || true
          ACCESS_TOKEN=$(jq -r '.token.access_token' ~/.clasprc.json)

          echo "ğŸ“‹ Fetching current versions..."

          # Get all versions
          VERSIONS_RESPONSE=$(curl -s \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            "https://script.googleapis.com/v1/projects/${SCRIPT_ID}/versions")

          # Check for API errors
          if echo "$VERSIONS_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            echo "âš ï¸  Could not fetch versions (API error)"
            echo "   Will attempt normal deployment..."
            echo "use_existing_version=false" >> $GITHUB_OUTPUT
            echo "latest_version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          VERSION_COUNT=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | length // 0')
          echo "   Found $VERSION_COUNT version(s)"

          # Get the latest version number (handle null/empty versions array for new projects)
          if [ "$VERSION_COUNT" -eq 0 ] || [ "$VERSION_COUNT" == "0" ]; then
            echo "   No versions exist yet (new project) - will create first version"
            LATEST_VERSION=""
          else
            LATEST_VERSION=$(echo "$VERSIONS_RESPONSE" | jq -r '.versions | sort_by(.versionNumber | tonumber) | last | .versionNumber // empty')
            echo "   Latest version: $LATEST_VERSION"
          fi

          # If at or near the 200 limit, we need to use existing version
          if [ "$VERSION_COUNT" -ge 199 ]; then
            echo ""
            echo "âš ï¸  VERSION LIMIT REACHED ($VERSION_COUNT/200)"
            echo ""
            echo "The Apps Script API does NOT support deleting versions programmatically."
            echo "Versions can ONLY be deleted manually through the Google Apps Script UI."
            echo ""
            echo "ğŸ”„ WORKAROUND: Deploying using existing version $LATEST_VERSION"
            echo "   This updates the deployment to point to the latest pushed code"
            echo "   without creating a new version."
            echo ""
            echo "ğŸ“‹ TO PERMANENTLY FIX THIS:"
            echo "   1. Go to: https://script.google.com/home/projects/${SCRIPT_ID}/versions"
            echo "   2. Delete old versions (keep recent 20-50)"
            echo "   3. Future deployments will work normally"
            echo ""
            echo "use_existing_version=true" >> $GITHUB_OUTPUT
            echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          elif [ "$VERSION_COUNT" -ge 180 ]; then
            echo ""
            echo "âš ï¸  WARNING: Approaching version limit ($VERSION_COUNT/200)"
            echo "   Consider manual cleanup soon at:"
            echo "   https://script.google.com/home/projects/${SCRIPT_ID}/versions"
            echo ""
            echo "use_existing_version=false" >> $GITHUB_OUTPUT
            echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          else
            echo "âœ… Version count ($VERSION_COUNT) is healthy"
            echo "use_existing_version=false" >> $GITHUB_OUTPUT
            echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to Apps Script
        id: deploy
        env:
          DEPLOYMENT_ID: ${{ secrets.DEPLOYMENT_ID }}
          USE_EXISTING_VERSION: ${{ steps.version_check.outputs.use_existing_version }}
          LATEST_VERSION: ${{ steps.version_check.outputs.latest_version }}
        run: |
          echo "ğŸ“¦ Creating deployment..."

          MAX_RETRIES=4
          RETRY_DELAY=5
          DEPLOY_OUTPUT=""

          # Check if we need to use existing version (at 200 version limit)
          if [ "$USE_EXISTING_VERSION" == "true" ] && [ -n "$LATEST_VERSION" ]; then
            echo ""
            echo "ğŸ”„ VERSION LIMIT WORKAROUND ACTIVE"
            echo "   Using existing version $LATEST_VERSION instead of creating new version"
            echo ""
          fi

          # Validate DEPLOYMENT_ID exists before attempting to use it
          # This handles cases where the secret is set but the deployment doesn't exist
          # (e.g., new project, deployment was deleted, wrong ID for this environment)
          VALID_DEPLOYMENT_ID=""
          if [ -n "$DEPLOYMENT_ID" ]; then
            echo "ğŸ” Validating DEPLOYMENT_ID: $DEPLOYMENT_ID"
            DEPLOYMENTS_LIST=$(clasp deployments 2>&1 || echo "")

            if echo "$DEPLOYMENTS_LIST" | grep -q "$DEPLOYMENT_ID"; then
              echo "   âœ… Deployment ID exists in this project"
              VALID_DEPLOYMENT_ID="$DEPLOYMENT_ID"
            else
              echo "   âš ï¸  Deployment ID NOT found in this project"
              echo "   Will create a new deployment instead"
              echo ""
              echo "ğŸ“‹ Current deployments:"
              echo "$DEPLOYMENTS_LIST" | sed 's/^/   /'
              echo ""
              echo "ğŸ’¡ TIP: After this deployment succeeds, update the DEPLOYMENT_ID secret"
              echo "   with the new deployment ID shown below to enable updates in future runs."
              echo ""
            fi
          fi

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "ğŸš€ Deploy attempt $attempt of $MAX_RETRIES..."

            set +e
            if [ "$USE_EXISTING_VERSION" == "true" ] && [ -n "$LATEST_VERSION" ]; then
              # At version limit: update deployment to point to existing version
              if [ -n "$VALID_DEPLOYMENT_ID" ]; then
                echo "   Updating deployment $VALID_DEPLOYMENT_ID to version $LATEST_VERSION (no new version created)"
                DEPLOY_OUTPUT=$(clasp deploy -V "$LATEST_VERSION" -i "$VALID_DEPLOYMENT_ID" -d "Stage 1 Deploy $(date -Iseconds) [v$LATEST_VERSION]" 2>&1)
              else
                echo "   Creating deployment using version $LATEST_VERSION"
                DEPLOY_OUTPUT=$(clasp deploy -V "$LATEST_VERSION" -d "Stage 1 Deploy $(date -Iseconds) [v$LATEST_VERSION]" 2>&1)
              fi
            else
              # Normal deployment: create new version
              if [ -n "$VALID_DEPLOYMENT_ID" ]; then
                echo "   Updating existing deployment: $VALID_DEPLOYMENT_ID"
                DEPLOY_OUTPUT=$(clasp deploy -i "$VALID_DEPLOYMENT_ID" -d "Stage 1 Deploy $(date -Iseconds)" 2>&1)
              else
                echo "   Creating new deployment (no valid DEPLOYMENT_ID)"
                DEPLOY_OUTPUT=$(clasp deploy -d "Stage 1 Deploy $(date -Iseconds)" 2>&1)
              fi
            fi
            DEPLOY_EXIT_CODE=$?
            set -e

            echo "   Exit code: $DEPLOY_EXIT_CODE"
            echo "   Output:"
            echo "$DEPLOY_OUTPUT" | sed 's/^/   /'

            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              if ! echo "$DEPLOY_OUTPUT" | grep -qiE "^Error|failed|ECONNRESET|ETIMEDOUT"; then
                echo "âœ… Deployment successful!"
                break
              fi
            fi

            # Check for version limit error and provide guidance
            if echo "$DEPLOY_OUTPUT" | grep -qi "200 versions"; then
              SCRIPT_ID=$(jq -r '.scriptId' .clasp.json)
              echo ""
              echo "âŒ FATAL: Hit 200 version limit!"
              echo ""
              echo "ğŸ“‹ MANUAL ACTION REQUIRED:"
              echo "   1. Go to: https://script.google.com/home/projects/${SCRIPT_ID}/versions"
              echo "   2. Delete old versions (keep the 20-50 most recent)"
              echo "   3. Re-run this workflow"
              echo ""
              echo "Note: The Apps Script API does not support programmatic version deletion."
              echo "This must be done manually through the Google Apps Script web UI."
              exit 1
            fi

            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "   Retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
              RETRY_DELAY=$((RETRY_DELAY * 2))
            else
              echo ""
              echo "âŒ ERROR: clasp deploy failed after $MAX_RETRIES attempts"
              echo ""
              echo "ğŸ“‹ Listing current deployments for diagnostics..."
              clasp deployments 2>&1 || echo "   Could not list deployments"
              echo ""
              echo "ğŸ”§ Possible causes:"
              echo "   1. Invalid deployment ID - check DEPLOYMENT_ID secret"
              echo "   2. Deployment quota exceeded (max 20 deployments)"
              echo "   3. OAuth token issues"
              echo "   4. Version limit reached (max 200 versions)"
              exit 1
            fi
          done

          VERSION_ID=$(echo "$DEPLOY_OUTPUT" | grep -oP 'Created version \K\d+' || echo "$DEPLOY_OUTPUT" | grep -oP 'Updated deployment \K\w+' || echo "unknown")

          # Get the deployment ID and construct the web app URL
          echo "ğŸ“‹ Fetching deployment URL..."
          DEPLOYMENTS_OUTPUT=$(clasp deployments 2>&1)
          echo "$DEPLOYMENTS_OUTPUT"

          # Extract deployment ID from the deploy output first
          DEPLOYMENT_ID_FROM_OUTPUT=$(echo "$DEPLOY_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)

          # If not found in deploy output, try to get from deployments list
          if [ -z "$DEPLOYMENT_ID_FROM_OUTPUT" ]; then
            echo "Extracting deployment ID from deployments list..."
            DEPLOYMENT_ID_FROM_OUTPUT=$(echo "$DEPLOYMENTS_OUTPUT" | grep -oP 'AKfycb[a-zA-Z0-9_-]+' | head -1)
          fi

          # Construct the Web App URL from the deployment ID
          if [ -n "$DEPLOYMENT_ID_FROM_OUTPUT" ]; then
            WEB_APP_URL="https://script.google.com/macros/s/${DEPLOYMENT_ID_FROM_OUTPUT}/exec"
            echo "âœ… Found deployment ID: ${DEPLOYMENT_ID_FROM_OUTPUT}"
          else
            echo "âš ï¸ Warning: Could not extract deployment ID from deployments"
            echo "Please check clasp deployments manually"
            exit 1
          fi

          echo "url=$WEB_APP_URL" >> $GITHUB_OUTPUT
          echo "deployment_id=$DEPLOYMENT_ID_FROM_OUTPUT" >> $GITHUB_OUTPUT
          echo "âœ… Deployment complete! Base URL: $WEB_APP_URL"

      - name: Update Cloudflare Worker (Optional)
        if: success()
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          DEPLOYMENT_ID: ${{ steps.deploy.outputs.deployment_id }}
        run: |
          echo "â˜ï¸ Checking Cloudflare Worker configuration..."

          # Check if Cloudflare secrets are configured
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "â„¹ï¸ Cloudflare secrets not configured - skipping Worker update"
            echo "   To enable Cloudflare Workers, add these secrets:"
            echo "   - CLOUDFLARE_API_TOKEN"
            echo "   - CLOUDFLARE_ACCOUNT_ID"
            echo ""
            echo "   See: cloudflare-proxy/CLOUDFLARE_SETUP.md"
            exit 0
          fi

          echo "ğŸ”„ Updating Cloudflare Worker with new deployment ID..."

          # Update wrangler.toml with new deployment ID
          sed -i "s/DEPLOYMENT_ID = \"[^\"]*\"/DEPLOYMENT_ID = \"${DEPLOYMENT_ID}\"/" cloudflare-proxy/wrangler.toml

          # Also update the worker.js default
          sed -i "s/const DEFAULT_DEPLOYMENT_ID = '[^']*'/const DEFAULT_DEPLOYMENT_ID = '${DEPLOYMENT_ID}'/" cloudflare-proxy/worker.js

          # Install and deploy with Wrangler
          npm install -g wrangler

          cd cloudflare-proxy
          wrangler deploy

          echo ""
          echo "âœ… Cloudflare Worker updated!"
          echo "ğŸ”— Worker URL: https://eventangle.workers.dev/status"

      - name: Generate comprehensive brand URLs
        id: urls
        run: |
          APPS_SCRIPT_BASE="${{ steps.deploy.outputs.url }}"
          CLOUDFLARE_BASE="https://eventangle.com"

          # Brands: root, abc, cbc, cbl
          BRANDS=("root" "abc" "cbc" "cbl")

          # Friendly URL aliases (maps to pages internally)
          # events -> public page, manage -> admin page, etc.
          ALIASES=("status" "manage" "events" "display")

          echo ""
          echo "=============================================="
          echo "ğŸ“‹ DEPLOYMENT URLS - READY FOR TESTING"
          echo "=============================================="
          echo ""
          echo "ğŸš€ Apps Script Base URL:"
          echo "$APPS_SCRIPT_BASE"
          echo ""
          echo "ğŸŒ Cloudflare Base URL:"
          echo "$CLOUDFLARE_BASE"
          echo ""
          echo "=============================================="
          echo ""

          # Generate friendly URLs for each brand
          for brand in "${BRANDS[@]}"; do
            echo "ğŸ¯ Brand: ${brand^^}"
            echo "----------------------------------------"
            for alias in "${ALIASES[@]}"; do
              # Friendly URL format: /{alias} for root, /{brand}/{alias} for others
              if [ "$brand" == "root" ]; then
                FRIENDLY_PATH="/${alias}"
              else
                FRIENDLY_PATH="/${brand}/${alias}"
              fi

              APPS_URL="${APPS_SCRIPT_BASE}${FRIENDLY_PATH}"
              CF_URL="${CLOUDFLARE_BASE}${FRIENDLY_PATH}"

              echo "  ${alias}:"
              echo "    Apps Script: $APPS_URL"
              echo "    Cloudflare:  $CF_URL"
            done
            echo ""
          done

          echo "=============================================="
          echo "ğŸ’¡ Full clickable URLs available in Job Summary below"
          echo "=============================================="
          echo ""

          # Save primary URLs for backward compatibility with Stage 2
          echo "root_url=${APPS_SCRIPT_BASE}/events" >> $GITHUB_OUTPUT
          echo "abc_url=${APPS_SCRIPT_BASE}/abc/events" >> $GITHUB_OUTPUT
          echo "cbc_url=${APPS_SCRIPT_BASE}/cbc/events" >> $GITHUB_OUTPUT
          echo "cbl_url=${APPS_SCRIPT_BASE}/cbl/events" >> $GITHUB_OUTPUT

      # ========================================================================
      # URL ARTIFACT: For Stage 2 POST-DEPLOY validation
      # ========================================================================
      # Creates artifact with target environment URL for Stage 2 E2E tests
      # - Staging (default): https://stg.eventangle.com
      # - Production (opt-in): https://eventangle.com
      # ========================================================================
      - name: Save URL artifact for Stage 2
        run: |
          mkdir -p deployment-info

          # Use the target environment URL
          TARGET_URL="$TARGET_BASE_URL"
          echo "$TARGET_URL" > deployment-info/deployment-url.txt
          echo "$TARGET_ENVIRONMENT" > deployment-info/environment.txt

          echo "============================================================"
          echo "ğŸ“¦ DEPLOYMENT ARTIFACT CREATED"
          echo "============================================================"
          echo ""
          echo "   Environment: $TARGET_ENVIRONMENT"
          echo "   URL: $TARGET_URL"
          echo ""
          echo "   Files:"
          echo "   - deployment-info/deployment-url.txt"
          echo "   - deployment-info/environment.txt"
          echo ""
          echo "   Apps Script URL: ${{ steps.deploy.outputs.url }}"
          echo "============================================================"

      - name: Upload deployment artifact for Stage 2
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: deployment-info/
          retention-days: 1

      - name: Create comprehensive deployment summary
        run: |
          APPS_SCRIPT_BASE="${{ steps.deploy.outputs.url }}"
          CLOUDFLARE_BASE="$TARGET_BASE_URL"

          echo "## ğŸš€ Stage 1 Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ¯ Target Environment: **${TARGET_ENVIRONMENT^^}**" >> $GITHUB_STEP_SUMMARY
          if [ "$IS_PRODUCTION" == "true" ]; then
            echo "> âš ï¸ This deployment went to **PRODUCTION**" >> $GITHUB_STEP_SUMMARY
          else
            echo "> This deployment went to **STAGING** (default)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Quality Gates Passed" >> $GITHUB_STEP_SUMMARY
          echo "- Code Quality (ESLint)" >> $GITHUB_STEP_SUMMARY
          echo "- Unit Tests (Jest)" >> $GITHUB_STEP_SUMMARY
          echo "- Contract Tests" >> $GITHUB_STEP_SUMMARY
          echo "- MVP Guards (Surfaces + Dead Exports + V2 Files)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ğŸŒ Comprehensive Test URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note:** Test both Apps Script and Cloudflare URLs to verify which works best for your use case." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Base Deployment URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | Base URL |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|----------|" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸš€ **Apps Script** | \`${APPS_SCRIPT_BASE}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| ğŸŒ **Cloudflare** | \`${CLOUDFLARE_BASE}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Generate comprehensive URL tables for each brand
          BRANDS=("root" "abc" "cbc" "cbl")
          BRAND_NAMES=("ROOT (Eventangle)" "ABC (American Bocce Co.)" "CBC (Chicago Bocce Club)" "CBL (Chicago Bocce League)")

          for i in "${!BRANDS[@]}"; do
            brand="${BRANDS[$i]}"
            brand_name="${BRAND_NAMES[$i]}"

            # Build brand prefix for friendly URLs
            if [ "$brand" == "root" ]; then
              PREFIX=""
            else
              PREFIX="/${brand}"
            fi

            echo "### ğŸ¯ Brand: ${brand_name}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Page | Apps Script URL | Cloudflare URL |" >> $GITHUB_STEP_SUMMARY
            echo "|------|-----------------|---------------|" >> $GITHUB_STEP_SUMMARY

            # Status (friendly URL: /status or /{brand}/status)
            echo "| ğŸ” **Status** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/status) | [Test](${CLOUDFLARE_BASE}${PREFIX}/status) |" >> $GITHUB_STEP_SUMMARY

            # Manage/Admin (friendly URL: /manage or /{brand}/manage)
            echo "| âš™ï¸ **Manage** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/manage) | [Test](${CLOUDFLARE_BASE}${PREFIX}/manage) |" >> $GITHUB_STEP_SUMMARY

            # Events (friendly URL: /events or /{brand}/events)
            echo "| ğŸ“… **Events** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/events) | [Test](${CLOUDFLARE_BASE}${PREFIX}/events) |" >> $GITHUB_STEP_SUMMARY

            # Display (friendly URL: /display or /{brand}/display)
            echo "| ğŸ“º **Display** | [Test](${APPS_SCRIPT_BASE}${PREFIX}/display) | [Test](${CLOUDFLARE_BASE}${PREFIX}/display) |" >> $GITHUB_STEP_SUMMARY

            echo "" >> $GITHUB_STEP_SUMMARY
          done

          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ’¡ Testing Instructions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **Status Page** (\`/status\`): Verify API health and connectivity" >> $GITHUB_STEP_SUMMARY
          echo "2. **Manage Page** (\`/manage\`): Test event management interface (requires admin key)" >> $GITHUB_STEP_SUMMARY
          echo "3. **Events Page** (\`/events\`): Test public event listing" >> $GITHUB_STEP_SUMMARY
          echo "4. **Display Page** (\`/display\`): Test TV/kiosk display mode" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ“Š **Next Step**: Stage 2 will automatically run Playwright tests against these URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“‹ Quick Copy-Paste URLs (Friendly URLs)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Apps Script - Status Endpoints (API Health)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/status" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/abc/status" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbc/status" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbl/status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Cloudflare - Status Endpoints (API Health)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/status" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/abc/status" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbc/status" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbl/status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Apps Script - Manage Pages (Event Management)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/manage" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/abc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${APPS_SCRIPT_BASE}/cbl/manage" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Cloudflare - Manage Pages (Event Management)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/manage" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/abc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbc/manage" >> $GITHUB_STEP_SUMMARY
          echo "${CLOUDFLARE_BASE}/cbl/manage" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“‹ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ¤– **Stage 2 will auto-trigger in a few seconds!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cost-Optimized Progressive Testing Strategy:**" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Stage 1 Complete (ESLint + Jest Unit + Contract tests passed)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸš€ Stage 2 Starting automatically..." >> $GITHUB_STEP_SUMMARY
          echo "  - ğŸ”¥ **Critical Tests** (run first):" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright API Tests (validates REST endpoints)" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright Smoke Tests (validates critical user paths)" >> $GITHUB_STEP_SUMMARY
          echo "  - ğŸš¦ **Failure Gate**: Calculate failure rate" >> $GITHUB_STEP_SUMMARY
          echo "  - ğŸ’° **Expensive Tests** (only if failure rate < 50%):" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright Flow Tests (multi-step user workflows)" >> $GITHUB_STEP_SUMMARY
          echo "    - Playwright Page Tests (comprehensive page validation)" >> $GITHUB_STEP_SUMMARY
          echo "  - ğŸ¯ **Quality Gate**: All tests must pass" >> $GITHUB_STEP_SUMMARY
          echo "  - ğŸš€ **QA Deployment**: Deploy to QA environment if approved" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the **Actions** tab to monitor Stage 2 progress." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
